{
  "language": "Solidity",
  "sources": {
    "contracts/arbitration/IArbitrable.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"./IArbitrator.sol\";\nimport \"../standards/ERC165.sol\";\n\n\ncontract IArbitrable is ERC165 {\n    bytes4 internal constant ERC165_INTERFACE_ID = bytes4(0x01ffc9a7);\n    bytes4 internal constant ARBITRABLE_INTERFACE_ID = bytes4(0x88f3ee69);\n\n    /**\n    * @dev Emitted when an IArbitrable instance's dispute is ruled by an IArbitrator\n    * @param arbitrator IArbitrator instance ruling the dispute\n    * @param disputeId Identification number of the dispute being ruled by the arbitrator\n    * @param ruling Ruling given by the arbitrator\n    */\n    event Ruled(IArbitrator indexed arbitrator, uint256 indexed disputeId, uint256 ruling);\n\n    /**\n    * @dev Emitted when new evidence is submitted for the IArbitrable instance's dispute\n    * @param arbitrator IArbitrator submitting the evidence for\n    * @param disputeId Identification number of the dispute receiving new evidence\n    * @param submitter Address of the account submitting the evidence\n    * @param evidence Data submitted for the evidence of the dispute\n    * @param finished Whether or not the submitter has finished submitting evidence\n    */\n    event EvidenceSubmitted(IArbitrator indexed arbitrator, uint256 indexed disputeId, address indexed submitter, bytes evidence, bool finished);\n\n    /**\n    * @dev Submit evidence for a dispute\n    * @param _disputeId Id of the dispute in the Court\n    * @param _evidence Data submitted for the evidence related to the dispute\n    * @param _finished Whether or not the submitter has finished submitting evidence\n    */\n    function submitEvidence(uint256 _disputeId, bytes calldata _evidence, bool _finished) external;\n\n    /**\n    * @dev Give a ruling for a certain dispute, the account calling it must have rights to rule on the contract\n    * @param _disputeId Identification number of the dispute to be ruled\n    * @param _ruling Ruling given by the arbitrator, where 0 is reserved for \"refused to make a decision\"\n    */\n    function rule(uint256 _disputeId, uint256 _ruling) external;\n\n    /**\n    * @dev ERC165 - Query if a contract implements a certain interface\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\n    * @return True if this contract supports the given interface, false otherwise\n    */\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\n        return _interfaceId == ARBITRABLE_INTERFACE_ID || _interfaceId == ERC165_INTERFACE_ID;\n    }\n}\n"
    },
    "contracts/arbitration/IArbitrator.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../lib/os/ERC20.sol\";\n\n\ninterface IArbitrator {\n    /**\n    * @dev Create a dispute over the Arbitrable sender with a number of possible rulings\n    * @param _possibleRulings Number of possible rulings allowed for the dispute\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\n    * @return Dispute identification number\n    */\n    function createDispute(uint256 _possibleRulings, bytes calldata _metadata) external returns (uint256);\n\n    /**\n    * @dev Close the evidence period of a dispute\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\n    */\n    function closeEvidencePeriod(uint256 _disputeId) external;\n\n    /**\n    * @dev Execute the Arbitrable associated to a dispute based on its final ruling\n    * @param _disputeId Identification number of the dispute to be executed\n    */\n    function executeRuling(uint256 _disputeId) external;\n\n    /**\n    * @dev Tell the dispute fees information to create a dispute\n    * @return recipient Address where the corresponding dispute fees must be transferred to\n    * @return feeToken ERC20 token used for the fees\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\n    */\n    function getDisputeFees() external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\n\n    /**\n    * @dev Tell the subscription fees information for a subscriber to be up-to-date\n    * @param _subscriber Address of the account paying the subscription fees for\n    * @return recipient Address where the corresponding subscriptions fees must be transferred to\n    * @return feeToken ERC20 token used for the subscription fees\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\n    */\n    function getSubscriptionFees(address _subscriber) external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\n}\n"
    },
    "contracts/lib/os/ERC20.sol": {
      "content": "// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/token/ERC20.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 {\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address _who) public view returns (uint256);\n\n    function allowance(address _owner, address _spender) public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) public returns (bool);\n\n    function approve(address _spender, uint256 _value) public returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "contracts/standards/ERC165.sol": {
      "content": "pragma solidity ^0.5.8;\n\n\ninterface ERC165 {\n    /**\n    * @dev Query if a contract implements a certain interface\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\n    * @return True if the contract implements the requested interface and if its not 0xffffffff, false otherwise\n    */\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool);\n}\n"
    },
    "contracts/court/AragonCourt.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../lib/os/Uint256Helpers.sol\";\n\nimport \"./controller/Controller.sol\";\nimport \"../arbitration/IArbitrator.sol\";\nimport \"../arbitration/IArbitrable.sol\";\nimport \"../disputes/IDisputeManager.sol\";\nimport \"../subscriptions/ISubscriptions.sol\";\n\n\ncontract AragonCourt is Controller, IArbitrator {\n    using Uint256Helpers for uint256;\n\n    string private constant ERROR_SUBSCRIPTION_NOT_PAID = \"AC_SUBSCRIPTION_NOT_PAID\";\n    string private constant ERROR_SENDER_NOT_ARBITRABLE = \"AC_SENDER_NOT_ARBITRABLE\";\n\n    // Arbitrable interface ID based on ERC-165\n    bytes4 private constant ARBITRABLE_INTERFACE_ID = bytes4(0x88f3ee69);\n\n    /**\n    * @dev Constructor function\n    * @param _termParams Array containing:\n    *        0. _termDuration Duration in seconds per term\n    *        1. _firstTermStartTime Timestamp in seconds when the court will open (to give time for juror on-boarding)\n    * @param _governors Array containing:\n    *        0. _fundsGovernor Address of the funds governor\n    *        1. _configGovernor Address of the config governor\n    *        2. _modulesGovernor Address of the modules governor\n    * @param _feeToken Address of the token contract that is used to pay for fees\n    * @param _fees Array containing:\n    *        0. jurorFee Amount of fee tokens that is paid per juror per dispute\n    *        1. draftFee Amount of fee tokens per juror to cover the drafting cost\n    *        2. settleFee Amount of fee tokens per juror to cover round settlement cost\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n    *        0. evidenceTerms Max submitting evidence period duration in terms\n    *        1. commitTerms Commit period duration in terms\n    *        2. revealTerms Reveal period duration in terms\n    *        3. appealTerms Appeal period duration in terms\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\n    * @param _pcts Array containing:\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked to each drafted jurors (‱ - 1/10,000)\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\n    * @param _roundParams Array containing params for rounds:\n    *        0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\n    *        1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n    *        3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\n    * @param _appealCollateralParams Array containing params for appeal collateral:\n    *        1. appealCollateralFactor Permyriad multiple of dispute fees required to appeal a preliminary ruling\n    *        2. appealConfirmCollateralFactor Permyriad multiple of dispute fees required to confirm appeal\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\n    */\n    constructor(\n        uint64[2] memory _termParams,\n        address[3] memory _governors,\n        ERC20 _feeToken,\n        uint256[3] memory _fees,\n        uint64[5] memory _roundStateDurations,\n        uint16[2] memory _pcts,\n        uint64[4] memory _roundParams,\n        uint256[2] memory _appealCollateralParams,\n        uint256 _minActiveBalance\n    )\n        public\n        Controller(\n            _termParams,\n            _governors,\n            _feeToken,\n            _fees,\n            _roundStateDurations,\n            _pcts,\n            _roundParams,\n            _appealCollateralParams,\n            _minActiveBalance\n        )\n    {\n        // solium-disable-previous-line no-empty-blocks\n    }\n\n    /**\n    * @notice Create a dispute with `_possibleRulings` possible rulings\n    * @param _possibleRulings Number of possible rulings allowed for the drafted jurors to vote on the dispute\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\n    * @return Dispute identification number\n    */\n    function createDispute(uint256 _possibleRulings, bytes calldata _metadata) external returns (uint256) {\n        IArbitrable subject = IArbitrable(msg.sender);\n        require(subject.supportsInterface(ARBITRABLE_INTERFACE_ID), ERROR_SENDER_NOT_ARBITRABLE);\n\n        ISubscriptions subscriptions = ISubscriptions(_getSubscriptions());\n        require(subscriptions.isUpToDate(address(subject)), ERROR_SUBSCRIPTION_NOT_PAID);\n\n        IDisputeManager disputeManager = IDisputeManager(_getDisputeManager());\n        return disputeManager.createDispute(subject, _possibleRulings.toUint8(), _metadata);\n    }\n\n    /**\n    * @notice Close the evidence period of dispute #`_disputeId`\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\n    */\n    function closeEvidencePeriod(uint256 _disputeId) external {\n        IArbitrable subject = IArbitrable(msg.sender);\n        IDisputeManager disputeManager = IDisputeManager(_getDisputeManager());\n        disputeManager.closeEvidencePeriod(subject, _disputeId);\n    }\n\n    /**\n    * @notice Execute the Arbitrable associated to dispute #`_disputeId` based on its final ruling\n    * @param _disputeId Identification number of the dispute to be executed\n    */\n    function executeRuling(uint256 _disputeId) external {\n        IDisputeManager disputeManager = IDisputeManager(_getDisputeManager());\n        (IArbitrable subject, uint8 ruling) = disputeManager.computeRuling(_disputeId);\n        subject.rule(_disputeId, uint256(ruling));\n    }\n\n    /**\n    * @dev Tell the dispute fees information to create a dispute\n    * @return recipient Address where the corresponding dispute fees must be transferred to\n    * @return feeToken ERC20 token used for the fees\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\n    */\n    function getDisputeFees() external view returns (address recipient, ERC20 feeToken, uint256 feeAmount) {\n        recipient = _getDisputeManager();\n        IDisputeManager disputeManager = IDisputeManager(recipient);\n        (feeToken, feeAmount) = disputeManager.getDisputeFees();\n    }\n\n    /**\n    * @dev Tell the subscription fees information for a subscriber to be up-to-date\n    * @param _subscriber Address of the account paying the subscription fees for\n    * @return recipient Address where the corresponding subscriptions fees must be transferred to\n    * @return feeToken ERC20 token used for the subscription fees\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\n    */\n    function getSubscriptionFees(address _subscriber) external view returns (address recipient, ERC20 feeToken, uint256 feeAmount) {\n        recipient = _getSubscriptions();\n        ISubscriptions subscriptions = ISubscriptions(recipient);\n        (feeToken, feeAmount,) = subscriptions.getOwedFeesDetails(_subscriber);\n    }\n}\n"
    },
    "contracts/lib/os/Uint256Helpers.sol": {
      "content": "// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/Uint256Helpers.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\n\nlibrary Uint256Helpers {\n    uint256 private constant MAX_UINT8 = uint8(-1);\n    uint256 private constant MAX_UINT64 = uint64(-1);\n\n    string private constant ERROR_UINT8_NUMBER_TOO_BIG = \"UINT8_NUMBER_TOO_BIG\";\n    string private constant ERROR_UINT64_NUMBER_TOO_BIG = \"UINT64_NUMBER_TOO_BIG\";\n\n    function toUint8(uint256 a) internal pure returns (uint8) {\n        require(a <= MAX_UINT8, ERROR_UINT8_NUMBER_TOO_BIG);\n        return uint8(a);\n    }\n\n    function toUint64(uint256 a) internal pure returns (uint64) {\n        require(a <= MAX_UINT64, ERROR_UINT64_NUMBER_TOO_BIG);\n        return uint64(a);\n    }\n}\n"
    },
    "contracts/court/controller/Controller.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../lib/os/IsContract.sol\";\n\nimport \"../clock/CourtClock.sol\";\nimport \"../config/CourtConfig.sol\";\n\n\ncontract Controller is IsContract, CourtClock, CourtConfig {\n    string private constant ERROR_SENDER_NOT_GOVERNOR = \"CTR_SENDER_NOT_GOVERNOR\";\n    string private constant ERROR_INVALID_GOVERNOR_ADDRESS = \"CTR_INVALID_GOVERNOR_ADDRESS\";\n    string private constant ERROR_IMPLEMENTATION_NOT_CONTRACT = \"CTR_IMPLEMENTATION_NOT_CONTRACT\";\n    string private constant ERROR_INVALID_IMPLS_INPUT_LENGTH = \"CTR_INVALID_IMPLS_INPUT_LENGTH\";\n\n    address private constant ZERO_ADDRESS = address(0);\n\n    // DisputeManager module ID - keccak256(abi.encodePacked(\"DISPUTE_MANAGER\"))\n    bytes32 internal constant DISPUTE_MANAGER = 0x14a6c70f0f6d449c014c7bbc9e68e31e79e8474fb03b7194df83109a2d888ae6;\n\n    // Treasury module ID - keccak256(abi.encodePacked(\"TREASURY\"))\n    bytes32 internal constant TREASURY = 0x06aa03964db1f7257357ef09714a5f0ca3633723df419e97015e0c7a3e83edb7;\n\n    // Voting module ID - keccak256(abi.encodePacked(\"VOTING\"))\n    bytes32 internal constant VOTING = 0x7cbb12e82a6d63ff16fe43977f43e3e2b247ecd4e62c0e340da8800a48c67346;\n\n    // JurorsRegistry module ID - keccak256(abi.encodePacked(\"JURORS_REGISTRY\"))\n    bytes32 internal constant JURORS_REGISTRY = 0x3b21d36b36308c830e6c4053fb40a3b6d79dde78947fbf6b0accd30720ab5370;\n\n    // Subscriptions module ID - keccak256(abi.encodePacked(\"SUBSCRIPTIONS\"))\n    bytes32 internal constant SUBSCRIPTIONS = 0x2bfa3327fe52344390da94c32a346eeb1b65a8b583e4335a419b9471e88c1365;\n\n    /**\n    * @dev Governor of the whole system. Set of three addresses to recover funds, change configuration settings and setup modules\n    */\n    struct Governor {\n        address funds;      // This address can be unset at any time. It is allowed to recover funds from the ControlledRecoverable modules\n        address config;     // This address is meant not to be unset. It is allowed to change the different configurations of the whole system\n        address modules;    // This address can be unset at any time. It is allowed to plug/unplug modules from the system\n    }\n\n    // Governor addresses of the system\n    Governor private governor;\n\n    // List of modules registered for the system indexed by ID\n    mapping (bytes32 => address) internal modules;\n\n    event ModuleSet(bytes32 id, address addr);\n    event FundsGovernorChanged(address previousGovernor, address currentGovernor);\n    event ConfigGovernorChanged(address previousGovernor, address currentGovernor);\n    event ModulesGovernorChanged(address previousGovernor, address currentGovernor);\n\n    /**\n    * @dev Ensure the msg.sender is the funds governor\n    */\n    modifier onlyFundsGovernor {\n        require(msg.sender == governor.funds, ERROR_SENDER_NOT_GOVERNOR);\n        _;\n    }\n\n    /**\n    * @dev Ensure the msg.sender is the modules governor\n    */\n    modifier onlyConfigGovernor {\n        require(msg.sender == governor.config, ERROR_SENDER_NOT_GOVERNOR);\n        _;\n    }\n\n    /**\n    * @dev Ensure the msg.sender is the modules governor\n    */\n    modifier onlyModulesGovernor {\n        require(msg.sender == governor.modules, ERROR_SENDER_NOT_GOVERNOR);\n        _;\n    }\n\n    /**\n    * @dev Constructor function\n    * @param _termParams Array containing:\n    *        0. _termDuration Duration in seconds per term\n    *        1. _firstTermStartTime Timestamp in seconds when the court will open (to give time for juror on-boarding)\n    * @param _governors Array containing:\n    *        0. _fundsGovernor Address of the funds governor\n    *        1. _configGovernor Address of the config governor\n    *        2. _modulesGovernor Address of the modules governor\n    * @param _feeToken Address of the token contract that is used to pay for fees\n    * @param _fees Array containing:\n    *        0. jurorFee Amount of fee tokens that is paid per juror per dispute\n    *        1. draftFee Amount of fee tokens per juror to cover the drafting cost\n    *        2. settleFee Amount of fee tokens per juror to cover round settlement cost\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n    *        0. evidenceTerms Max submitting evidence period duration in terms\n    *        1. commitTerms Commit period duration in terms\n    *        2. revealTerms Reveal period duration in terms\n    *        3. appealTerms Appeal period duration in terms\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\n    * @param _pcts Array containing:\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked to each drafted jurors (‱ - 1/10,000)\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\n    * @param _roundParams Array containing params for rounds:\n    *        0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\n    *        1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n    *        3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\n    * @param _appealCollateralParams Array containing params for appeal collateral:\n    *        1. appealCollateralFactor Permyriad multiple of dispute fees required to appeal a preliminary ruling\n    *        2. appealConfirmCollateralFactor Permyriad multiple of dispute fees required to confirm appeal\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\n    */\n    constructor(\n        uint64[2] memory _termParams,\n        address[3] memory _governors,\n        ERC20 _feeToken,\n        uint256[3] memory _fees,\n        uint64[5] memory _roundStateDurations,\n        uint16[2] memory _pcts,\n        uint64[4] memory _roundParams,\n        uint256[2] memory _appealCollateralParams,\n        uint256 _minActiveBalance\n    )\n        public\n        CourtClock(_termParams)\n        CourtConfig(_feeToken, _fees, _roundStateDurations, _pcts, _roundParams, _appealCollateralParams, _minActiveBalance)\n    {\n        _setFundsGovernor(_governors[0]);\n        _setConfigGovernor(_governors[1]);\n        _setModulesGovernor(_governors[2]);\n    }\n\n    /**\n    * @notice Change Court configuration params\n    * @param _fromTermId Identification number of the term in which the config will be effective at\n    * @param _feeToken Address of the token contract that is used to pay for fees\n    * @param _fees Array containing:\n    *        0. jurorFee Amount of fee tokens that is paid per juror per dispute\n    *        1. draftFee Amount of fee tokens per juror to cover the drafting cost\n    *        2. settleFee Amount of fee tokens per juror to cover round settlement cost\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n    *        0. evidenceTerms Max submitting evidence period duration in terms\n    *        1. commitTerms Commit period duration in terms\n    *        2. revealTerms Reveal period duration in terms\n    *        3. appealTerms Appeal period duration in terms\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\n    * @param _pcts Array containing:\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked to each drafted jurors (‱ - 1/10,000)\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\n    * @param _roundParams Array containing params for rounds:\n    *        0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\n    *        1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n    *        3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\n    * @param _appealCollateralParams Array containing params for appeal collateral:\n    *        1. appealCollateralFactor Permyriad multiple of dispute fees required to appeal a preliminary ruling\n    *        2. appealConfirmCollateralFactor Permyriad multiple of dispute fees required to confirm appeal\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\n    */\n    function setConfig(\n        uint64 _fromTermId,\n        ERC20 _feeToken,\n        uint256[3] calldata _fees,\n        uint64[5] calldata _roundStateDurations,\n        uint16[2] calldata _pcts,\n        uint64[4] calldata _roundParams,\n        uint256[2] calldata _appealCollateralParams,\n        uint256 _minActiveBalance\n    )\n        external\n        onlyConfigGovernor\n    {\n        uint64 currentTermId = _ensureCurrentTerm();\n        _setConfig(\n            currentTermId,\n            _fromTermId,\n            _feeToken,\n            _fees,\n            _roundStateDurations,\n            _pcts,\n            _roundParams,\n            _appealCollateralParams,\n            _minActiveBalance\n        );\n    }\n\n    /**\n    * @notice Delay the Court start time to `_newFirstTermStartTime`\n    * @param _newFirstTermStartTime New timestamp in seconds when the court will open\n    */\n    function delayStartTime(uint64 _newFirstTermStartTime) external onlyConfigGovernor {\n        _delayStartTime(_newFirstTermStartTime);\n    }\n\n    /**\n    * @notice Change funds governor address to `_newFundsGovernor`\n    * @param _newFundsGovernor Address of the new funds governor to be set\n    */\n    function changeFundsGovernor(address _newFundsGovernor) external onlyFundsGovernor {\n        require(_newFundsGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\n        _setFundsGovernor(_newFundsGovernor);\n    }\n\n    /**\n    * @notice Change config governor address to `_newConfigGovernor`\n    * @param _newConfigGovernor Address of the new config governor to be set\n    */\n    function changeConfigGovernor(address _newConfigGovernor) external onlyConfigGovernor {\n        require(_newConfigGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\n        _setConfigGovernor(_newConfigGovernor);\n    }\n\n    /**\n    * @notice Change modules governor address to `_newModulesGovernor`\n    * @param _newModulesGovernor Address of the new governor to be set\n    */\n    function changeModulesGovernor(address _newModulesGovernor) external onlyModulesGovernor {\n        require(_newModulesGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\n        _setModulesGovernor(_newModulesGovernor);\n    }\n\n    /**\n    * @notice Remove the funds governor. Set the funds governor to the zero address.\n    * @dev This action cannot be rolled back, once the funds governor has been unset, funds cannot be recovered from recoverable modules anymore\n    */\n    function ejectFundsGovernor() external onlyFundsGovernor {\n        _setFundsGovernor(ZERO_ADDRESS);\n    }\n\n    /**\n    * @notice Remove the modules governor. Set the modules governor to the zero address.\n    * @dev This action cannot be rolled back, once the modules governor has been unset, system modules cannot be changed anymore\n    */\n    function ejectModulesGovernor() external onlyModulesGovernor {\n        _setModulesGovernor(ZERO_ADDRESS);\n    }\n\n    /**\n    * @notice Set module `_id` to `_addr`\n    * @param _id ID of the module to be set\n    * @param _addr Address of the module to be set\n    */\n    function setModule(bytes32 _id, address _addr) external onlyModulesGovernor {\n        _setModule(_id, _addr);\n    }\n\n    /**\n    * @notice Set many modules at once\n    * @param _ids List of ids of each module to be set\n    * @param _addresses List of addressed of each the module to be set\n    */\n    function setModules(bytes32[] calldata _ids, address[] calldata _addresses) external onlyModulesGovernor {\n        require(_ids.length == _addresses.length, ERROR_INVALID_IMPLS_INPUT_LENGTH);\n\n        for (uint256 i = 0; i < _ids.length; i++) {\n            _setModule(_ids[i], _addresses[i]);\n        }\n    }\n\n    /**\n    * @dev Tell the full Court configuration parameters at a certain term\n    * @param _termId Identification number of the term querying the Court config of\n    * @return token Address of the token used to pay for fees\n    * @return fees Array containing:\n    *         0. jurorFee Amount of fee tokens that is paid per juror per dispute\n    *         1. draftFee Amount of fee tokens per juror to cover the drafting cost\n    *         2. settleFee Amount of fee tokens per juror to cover round settlement cost\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n    *         0. evidenceTerms Max submitting evidence period duration in terms\n    *         1. commitTerms Commit period duration in terms\n    *         2. revealTerms Reveal period duration in terms\n    *         3. appealTerms Appeal period duration in terms\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\n    * @return pcts Array containing:\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\n    * @return roundParams Array containing params for rounds:\n    *         0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\n    *         1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n    *         3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\n    * @return appealCollateralParams Array containing params for appeal collateral:\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n    */\n    function getConfig(uint64 _termId) external view\n        returns (\n            ERC20 feeToken,\n            uint256[3] memory fees,\n            uint64[5] memory roundStateDurations,\n            uint16[2] memory pcts,\n            uint64[4] memory roundParams,\n            uint256[2] memory appealCollateralParams,\n            uint256 minActiveBalance\n        )\n    {\n        uint64 lastEnsuredTermId = _lastEnsuredTermId();\n        return _getConfigAt(_termId, lastEnsuredTermId);\n    }\n\n    /**\n    * @dev Tell the draft config at a certain term\n    * @param _termId Identification number of the term querying the draft config of\n    * @return feeToken Address of the token used to pay for fees\n    * @return draftFee Amount of fee tokens per juror to cover the drafting cost\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    */\n    function getDraftConfig(uint64 _termId) external view returns (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct) {\n        uint64 lastEnsuredTermId = _lastEnsuredTermId();\n        return _getDraftConfig(_termId, lastEnsuredTermId);\n    }\n\n    /**\n    * @dev Tell the min active balance config at a certain term\n    * @param _termId Identification number of the term querying the min active balance config of\n    * @return Minimum amount of tokens jurors have to activate to participate in the Court\n    */\n    function getMinActiveBalance(uint64 _termId) external view returns (uint256) {\n        uint64 lastEnsuredTermId = _lastEnsuredTermId();\n        return _getMinActiveBalance(_termId, lastEnsuredTermId);\n    }\n\n    /**\n    * @dev Tell the address of the funds governor\n    * @return Address of the funds governor\n    */\n    function getFundsGovernor() external view returns (address) {\n        return governor.funds;\n    }\n\n    /**\n    * @dev Tell the address of the config governor\n    * @return Address of the config governor\n    */\n    function getConfigGovernor() external view returns (address) {\n        return governor.config;\n    }\n\n    /**\n    * @dev Tell the address of the modules governor\n    * @return Address of the modules governor\n    */\n    function getModulesGovernor() external view returns (address) {\n        return governor.modules;\n    }\n\n    /**\n    * @dev Tell address of a module based on a given ID\n    * @param _id ID of the module being queried\n    * @return Address of the requested module\n    */\n    function getModule(bytes32 _id) external view returns (address) {\n        return _getModule(_id);\n    }\n\n    /**\n    * @dev Tell the address of the DisputeManager module\n    * @return Address of the DisputeManager module\n    */\n    function getDisputeManager() external view returns (address) {\n        return _getDisputeManager();\n    }\n\n    /**\n    * @dev Tell the address of the Treasury module\n    * @return Address of the Treasury module\n    */\n    function getTreasury() external view returns (address) {\n        return _getModule(TREASURY);\n    }\n\n    /**\n    * @dev Tell the address of the Voting module\n    * @return Address of the Voting module\n    */\n    function getVoting() external view returns (address) {\n        return _getModule(VOTING);\n    }\n\n    /**\n    * @dev Tell the address of the JurorsRegistry module\n    * @return Address of the JurorsRegistry module\n    */\n    function getJurorsRegistry() external view returns (address) {\n        return _getModule(JURORS_REGISTRY);\n    }\n\n    /**\n    * @dev Tell the address of the Subscriptions module\n    * @return Address of the Subscriptions module\n    */\n    function getSubscriptions() external view returns (address) {\n        return _getSubscriptions();\n    }\n\n    /**\n    * @dev Internal function to set the address of the funds governor\n    * @param _newFundsGovernor Address of the new config governor to be set\n    */\n    function _setFundsGovernor(address _newFundsGovernor) internal {\n        emit FundsGovernorChanged(governor.funds, _newFundsGovernor);\n        governor.funds = _newFundsGovernor;\n    }\n\n    /**\n    * @dev Internal function to set the address of the config governor\n    * @param _newConfigGovernor Address of the new config governor to be set\n    */\n    function _setConfigGovernor(address _newConfigGovernor) internal {\n        emit ConfigGovernorChanged(governor.config, _newConfigGovernor);\n        governor.config = _newConfigGovernor;\n    }\n\n    /**\n    * @dev Internal function to set the address of the modules governor\n    * @param _newModulesGovernor Address of the new modules governor to be set\n    */\n    function _setModulesGovernor(address _newModulesGovernor) internal {\n        emit ModulesGovernorChanged(governor.modules, _newModulesGovernor);\n        governor.modules = _newModulesGovernor;\n    }\n\n    /**\n    * @dev Internal function to set a module\n    * @param _id Id of the module to be set\n    * @param _addr Address of the module to be set\n    */\n    function _setModule(bytes32 _id, address _addr) internal {\n        require(isContract(_addr), ERROR_IMPLEMENTATION_NOT_CONTRACT);\n        modules[_id] = _addr;\n        emit ModuleSet(_id, _addr);\n    }\n\n    /**\n    * @dev Internal function to notify when a term has been transitioned\n    * @param _termId Identification number of the new current term that has been transitioned\n    */\n    function _onTermTransitioned(uint64 _termId) internal {\n        _ensureTermConfig(_termId);\n    }\n\n    /**\n    * @dev Internal function to tell the address of the DisputeManager module\n    * @return Address of the DisputeManager module\n    */\n    function _getDisputeManager() internal view returns (address) {\n        return _getModule(DISPUTE_MANAGER);\n    }\n\n    /**\n    * @dev Internal function to tell the address of the Subscriptions module\n    * @return Address of the Subscriptions module\n    */\n    function _getSubscriptions() internal view returns (address) {\n        return _getModule(SUBSCRIPTIONS);\n    }\n\n    /**\n    * @dev Internal function to tell address of a module based on a given ID\n    * @param _id ID of the module being queried\n    * @return Address of the requested module\n    */\n    function _getModule(bytes32 _id) internal view returns (address) {\n        return modules[_id];\n    }\n}\n"
    },
    "contracts/lib/os/IsContract.sol": {
      "content": "// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/IsContract.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\n\ncontract IsContract {\n    /*\n    * NOTE: this should NEVER be used for authentication\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\n    *\n    * This is only intended to be used as a sanity check that an address is actually a contract,\n    * RATHER THAN an address not being a contract.\n    */\n    function isContract(address _target) internal view returns (bool) {\n        if (_target == address(0)) {\n            return false;\n        }\n\n        uint256 size;\n        assembly { size := extcodesize(_target) }\n        return size > 0;\n    }\n}\n"
    },
    "contracts/court/clock/CourtClock.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../lib/os/SafeMath64.sol\";\nimport \"../../lib/os/TimeHelpers.sol\";\n\nimport \"./IClock.sol\";\n\n\ncontract CourtClock is IClock, TimeHelpers {\n    using SafeMath64 for uint64;\n\n    string private constant ERROR_TERM_DOES_NOT_EXIST = \"CLK_TERM_DOES_NOT_EXIST\";\n    string private constant ERROR_TERM_DURATION_TOO_LONG = \"CLK_TERM_DURATION_TOO_LONG\";\n    string private constant ERROR_TERM_RANDOMNESS_NOT_YET = \"CLK_TERM_RANDOMNESS_NOT_YET\";\n    string private constant ERROR_TERM_RANDOMNESS_UNAVAILABLE = \"CLK_TERM_RANDOMNESS_UNAVAILABLE\";\n    string private constant ERROR_BAD_FIRST_TERM_START_TIME = \"CLK_BAD_FIRST_TERM_START_TIME\";\n    string private constant ERROR_TOO_MANY_TRANSITIONS = \"CLK_TOO_MANY_TRANSITIONS\";\n    string private constant ERROR_INVALID_TRANSITION_TERMS = \"CLK_INVALID_TRANSITION_TERMS\";\n    string private constant ERROR_CANNOT_DELAY_STARTED_COURT = \"CLK_CANNOT_DELAY_STARTED_COURT\";\n    string private constant ERROR_CANNOT_DELAY_PAST_START_TIME = \"CLK_CANNOT_DELAY_PAST_START_TIME\";\n\n    // Maximum number of term transitions a callee may have to assume in order to call certain functions that require the Court being up-to-date\n    uint64 internal constant MAX_AUTO_TERM_TRANSITIONS_ALLOWED = 1;\n\n    // Max duration in seconds that a term can last\n    uint64 internal constant MAX_TERM_DURATION = 365 days;\n\n    // Max time until first term starts since contract is deployed\n    uint64 internal constant MAX_FIRST_TERM_DELAY_PERIOD = 2 * MAX_TERM_DURATION;\n\n    struct Term {\n        uint64 startTime;              // Timestamp when the term started\n        uint64 randomnessBN;           // Block number for entropy\n        bytes32 randomness;            // Entropy from randomnessBN block hash\n    }\n\n    // Duration in seconds for each term of the Court\n    uint64 private termDuration;\n\n    // Last ensured term id\n    uint64 private termId;\n\n    // List of Court terms indexed by id\n    mapping (uint64 => Term) private terms;\n\n    event Heartbeat(uint64 previousTermId, uint64 currentTermId);\n    event StartTimeDelayed(uint64 previousStartTime, uint64 currentStartTime);\n\n    /**\n    * @dev Ensure a certain term has already been processed\n    * @param _termId Identification number of the term to be checked\n    */\n    modifier termExists(uint64 _termId) {\n        require(_termId <= termId, ERROR_TERM_DOES_NOT_EXIST);\n        _;\n    }\n\n    /**\n    * @dev Constructor function\n    * @param _termParams Array containing:\n    *        0. _termDuration Duration in seconds per term\n    *        1. _firstTermStartTime Timestamp in seconds when the court will open (to give time for juror on-boarding)\n    */\n    constructor(uint64[2] memory _termParams) public {\n        uint64 _termDuration = _termParams[0];\n        uint64 _firstTermStartTime = _termParams[1];\n\n        require(_termDuration < MAX_TERM_DURATION, ERROR_TERM_DURATION_TOO_LONG);\n        require(_firstTermStartTime >= getTimestamp64() + _termDuration, ERROR_BAD_FIRST_TERM_START_TIME);\n        require(_firstTermStartTime <= getTimestamp64() + MAX_FIRST_TERM_DELAY_PERIOD, ERROR_BAD_FIRST_TERM_START_TIME);\n\n        termDuration = _termDuration;\n\n        // No need for SafeMath: we already checked values above\n        terms[0].startTime = _firstTermStartTime - _termDuration;\n    }\n\n    /**\n    * @notice Ensure that the current term of the Court is up-to-date. If the Court is outdated by more than `MAX_AUTO_TERM_TRANSITIONS_ALLOWED`\n    *         terms, the heartbeat function must be called manually instead.\n    * @return Identification number of the current term\n    */\n    function ensureCurrentTerm() external returns (uint64) {\n        return _ensureCurrentTerm();\n    }\n\n    /**\n    * @notice Transition up to `_maxRequestedTransitions` terms\n    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\n    * @return Identification number of the term ID after executing the heartbeat transitions\n    */\n    function heartbeat(uint64 _maxRequestedTransitions) external returns (uint64) {\n        return _heartbeat(_maxRequestedTransitions);\n    }\n\n    /**\n    * @notice Ensure that a certain term has its randomness set. As we allow to draft disputes requested for previous terms, if there\n    *      were mined more than 256 blocks for the current term, the blockhash of its randomness BN is no longer available, given\n    *      round will be able to be drafted in the following term.\n    * @return Randomness of the current term\n    */\n    function ensureCurrentTermRandomness() external returns (bytes32) {\n        // If the randomness for the given term was already computed, return\n        uint64 currentTermId = termId;\n        Term storage term = terms[currentTermId];\n        bytes32 termRandomness = term.randomness;\n        if (termRandomness != bytes32(0)) {\n            return termRandomness;\n        }\n\n        // Compute term randomness\n        bytes32 newRandomness = _computeTermRandomness(currentTermId);\n        require(newRandomness != bytes32(0), ERROR_TERM_RANDOMNESS_UNAVAILABLE);\n        term.randomness = newRandomness;\n        return newRandomness;\n    }\n\n    /**\n    * @dev Tell the term duration of the Court\n    * @return Duration in seconds of the Court term\n    */\n    function getTermDuration() external view returns (uint64) {\n        return termDuration;\n    }\n\n    /**\n    * @dev Tell the last ensured term identification number\n    * @return Identification number of the last ensured term\n    */\n    function getLastEnsuredTermId() external view returns (uint64) {\n        return _lastEnsuredTermId();\n    }\n\n    /**\n    * @dev Tell the current term identification number. Note that there may be pending term transitions.\n    * @return Identification number of the current term\n    */\n    function getCurrentTermId() external view returns (uint64) {\n        return _currentTermId();\n    }\n\n    /**\n    * @dev Tell the number of terms the Court should transition to be up-to-date\n    * @return Number of terms the Court should transition to be up-to-date\n    */\n    function getNeededTermTransitions() external view returns (uint64) {\n        return _neededTermTransitions();\n    }\n\n    /**\n    * @dev Tell the information related to a term based on its ID. Note that if the term has not been reached, the\n    *      information returned won't be computed yet. This function allows querying future terms that were not computed yet.\n    * @param _termId ID of the term being queried\n    * @return startTime Term start time\n    * @return randomnessBN Block number used for randomness in the requested term\n    * @return randomness Randomness computed for the requested term\n    */\n    function getTerm(uint64 _termId) external view returns (uint64 startTime, uint64 randomnessBN, bytes32 randomness) {\n        Term storage term = terms[_termId];\n        return (term.startTime, term.randomnessBN, term.randomness);\n    }\n\n    /**\n    * @dev Tell the randomness of a term even if it wasn't computed yet\n    * @param _termId Identification number of the term being queried\n    * @return Randomness of the requested term\n    */\n    function getTermRandomness(uint64 _termId) external view termExists(_termId) returns (bytes32) {\n        return _computeTermRandomness(_termId);\n    }\n\n    /**\n    * @dev Internal function to ensure that the current term of the Court is up-to-date. If the Court is outdated by more than\n    *      `MAX_AUTO_TERM_TRANSITIONS_ALLOWED` terms, the heartbeat function must be called manually.\n    * @return Identification number of the resultant term ID after executing the corresponding transitions\n    */\n    function _ensureCurrentTerm() internal returns (uint64) {\n        // Check the required number of transitions does not exceeds the max allowed number to be processed automatically\n        uint64 requiredTransitions = _neededTermTransitions();\n        require(requiredTransitions <= MAX_AUTO_TERM_TRANSITIONS_ALLOWED, ERROR_TOO_MANY_TRANSITIONS);\n\n        // If there are no transitions pending, return the last ensured term id\n        if (uint256(requiredTransitions) == 0) {\n            return termId;\n        }\n\n        // Process transition if there is at least one pending\n        return _heartbeat(requiredTransitions);\n    }\n\n    /**\n    * @dev Internal function to transition the Court terms up to a requested number of terms\n    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\n    * @return Identification number of the resultant term ID after executing the requested transitions\n    */\n    function _heartbeat(uint64 _maxRequestedTransitions) internal returns (uint64) {\n        // Transition the minimum number of terms between the amount requested and the amount actually needed\n        uint64 neededTransitions = _neededTermTransitions();\n        uint256 transitions = uint256(_maxRequestedTransitions < neededTransitions ? _maxRequestedTransitions : neededTransitions);\n        require(transitions > 0, ERROR_INVALID_TRANSITION_TERMS);\n\n        uint64 blockNumber = getBlockNumber64();\n        uint64 previousTermId = termId;\n        uint64 currentTermId = previousTermId;\n        for (uint256 transition = 1; transition <= transitions; transition++) {\n            // Term IDs are incremented by one based on the number of time periods since the Court started. Since time is represented in uint64,\n            // even if we chose the minimum duration possible for a term (1 second), we can ensure terms will never reach 2^64 since time is\n            // already assumed to fit in uint64.\n            Term storage previousTerm = terms[currentTermId++];\n            Term storage currentTerm = terms[currentTermId];\n            _onTermTransitioned(currentTermId);\n\n            // Set the start time of the new term. Note that we are using a constant term duration value to guarantee\n            // equally long terms, regardless of heartbeats.\n            currentTerm.startTime = previousTerm.startTime.add(termDuration);\n\n            // In order to draft a random number of jurors in a term, we use a randomness factor for each term based on a\n            // block number that is set once the term has started. Note that this information could not be known beforehand.\n            currentTerm.randomnessBN = blockNumber + 1;\n        }\n\n        termId = currentTermId;\n        emit Heartbeat(previousTermId, currentTermId);\n        return currentTermId;\n    }\n\n    /**\n    * @dev Internal function to delay the first term start time only if it wasn't reached yet\n    * @param _newFirstTermStartTime New timestamp in seconds when the court will open\n    */\n    function _delayStartTime(uint64 _newFirstTermStartTime) internal {\n        require(_currentTermId() == 0, ERROR_CANNOT_DELAY_STARTED_COURT);\n\n        Term storage term = terms[0];\n        uint64 currentFirstTermStartTime = term.startTime.add(termDuration);\n        require(_newFirstTermStartTime > currentFirstTermStartTime, ERROR_CANNOT_DELAY_PAST_START_TIME);\n\n        // No need for SafeMath: we already checked above that `_newFirstTermStartTime` > `currentFirstTermStartTime` >= `termDuration`\n        term.startTime = _newFirstTermStartTime - termDuration;\n        emit StartTimeDelayed(currentFirstTermStartTime, _newFirstTermStartTime);\n    }\n\n    /**\n    * @dev Internal function to notify when a term has been transitioned. This function must be overridden to provide custom behavior.\n    * @param _termId Identification number of the new current term that has been transitioned\n    */\n    function _onTermTransitioned(uint64 _termId) internal;\n\n    /**\n    * @dev Internal function to tell the last ensured term identification number\n    * @return Identification number of the last ensured term\n    */\n    function _lastEnsuredTermId() internal view returns (uint64) {\n        return termId;\n    }\n\n    /**\n    * @dev Internal function to tell the current term identification number. Note that there may be pending term transitions.\n    * @return Identification number of the current term\n    */\n    function _currentTermId() internal view returns (uint64) {\n        return termId.add(_neededTermTransitions());\n    }\n\n    /**\n    * @dev Internal function to tell the number of terms the Court should transition to be up-to-date\n    * @return Number of terms the Court should transition to be up-to-date\n    */\n    function _neededTermTransitions() internal view returns (uint64) {\n        // Note that the Court is always initialized providing a start time for the first-term in the future. If that's the case,\n        // no term transitions are required.\n        uint64 currentTermStartTime = terms[termId].startTime;\n        if (getTimestamp64() < currentTermStartTime) {\n            return uint64(0);\n        }\n\n        // No need for SafeMath: we already know that the start time of the current term is in the past\n        return (getTimestamp64() - currentTermStartTime) / termDuration;\n    }\n\n    /**\n    * @dev Internal function to compute the randomness that will be used to draft jurors for the given term. This\n    *      function assumes the given term exists. To determine the randomness factor for a term we use the hash of a\n    *      block number that is set once the term has started to ensure it cannot be known beforehand. Note that the\n    *      hash function being used only works for the 256 most recent block numbers.\n    * @param _termId Identification number of the term being queried\n    * @return Randomness computed for the given term\n    */\n    function _computeTermRandomness(uint64 _termId) internal view returns (bytes32) {\n        Term storage term = terms[_termId];\n        require(getBlockNumber64() > term.randomnessBN, ERROR_TERM_RANDOMNESS_NOT_YET);\n        return blockhash(term.randomnessBN);\n    }\n}\n"
    },
    "contracts/lib/os/SafeMath64.sol": {
      "content": "// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/math/SafeMath64.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\n\n/**\n * @title SafeMath64\n * @dev Math operations for uint64 with safety checks that revert on error\n */\nlibrary SafeMath64 {\n    string private constant ERROR_ADD_OVERFLOW = \"MATH64_ADD_OVERFLOW\";\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH64_SUB_UNDERFLOW\";\n    string private constant ERROR_MUL_OVERFLOW = \"MATH64_MUL_OVERFLOW\";\n    string private constant ERROR_DIV_ZERO = \"MATH64_DIV_ZERO\";\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint64 _a, uint64 _b) internal pure returns (uint64) {\n        uint256 c = uint256(_a) * uint256(_b);\n        require(c < 0x010000000000000000, ERROR_MUL_OVERFLOW); // 2**64 (less gas this way)\n\n        return uint64(c);\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint64 _a, uint64 _b) internal pure returns (uint64) {\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n        uint64 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint64 _a, uint64 _b) internal pure returns (uint64) {\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n        uint64 c = _a - _b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint64 _a, uint64 _b) internal pure returns (uint64) {\n        uint64 c = _a + _b;\n        require(c >= _a, ERROR_ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\n        require(b != 0, ERROR_DIV_ZERO);\n        return a % b;\n    }\n}\n"
    },
    "contracts/lib/os/TimeHelpers.sol": {
      "content": "// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/TimeHelpers.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\nimport \"./Uint256Helpers.sol\";\n\n\ncontract TimeHelpers {\n    using Uint256Helpers for uint256;\n\n    /**\n    * @dev Returns the current block number.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n    * @dev Returns the current block number, converted to uint64.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber64() internal view returns (uint64) {\n        return getBlockNumber().toUint64();\n    }\n\n    /**\n    * @dev Returns the current timestamp.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp() internal view returns (uint256) {\n        return block.timestamp; // solium-disable-line security/no-block-members\n    }\n\n    /**\n    * @dev Returns the current timestamp, converted to uint64.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp64() internal view returns (uint64) {\n        return getTimestamp().toUint64();\n    }\n}\n"
    },
    "contracts/court/clock/IClock.sol": {
      "content": "pragma solidity ^0.5.8;\n\n\ninterface IClock {\n    /**\n    * @dev Ensure that the current term of the clock is up-to-date\n    * @return Identification number of the current term\n    */\n    function ensureCurrentTerm() external returns (uint64);\n\n    /**\n    * @dev Transition up to a certain number of terms to leave the clock up-to-date\n    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\n    * @return Identification number of the term ID after executing the heartbeat transitions\n    */\n    function heartbeat(uint64 _maxRequestedTransitions) external returns (uint64);\n\n    /**\n    * @dev Ensure that a certain term has its randomness set\n    * @return Randomness of the current term\n    */\n    function ensureCurrentTermRandomness() external returns (bytes32);\n\n    /**\n    * @dev Tell the last ensured term identification number\n    * @return Identification number of the last ensured term\n    */\n    function getLastEnsuredTermId() external view returns (uint64);\n\n    /**\n    * @dev Tell the current term identification number. Note that there may be pending term transitions.\n    * @return Identification number of the current term\n    */\n    function getCurrentTermId() external view returns (uint64);\n\n    /**\n    * @dev Tell the number of terms the clock should transition to be up-to-date\n    * @return Number of terms the clock should transition to be up-to-date\n    */\n    function getNeededTermTransitions() external view returns (uint64);\n\n    /**\n    * @dev Tell the information related to a term based on its ID\n    * @param _termId ID of the term being queried\n    * @return startTime Term start time\n    * @return randomnessBN Block number used for randomness in the requested term\n    * @return randomness Randomness computed for the requested term\n    */\n    function getTerm(uint64 _termId) external view returns (uint64 startTime, uint64 randomnessBN, bytes32 randomness);\n\n    /**\n    * @dev Tell the randomness of a term even if it wasn't computed yet\n    * @param _termId Identification number of the term being queried\n    * @return Randomness of the requested term\n    */\n    function getTermRandomness(uint64 _termId) external view returns (bytes32);\n}\n"
    },
    "contracts/court/config/CourtConfig.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../lib/os/ERC20.sol\";\nimport \"../../lib/os/SafeMath64.sol\";\n\nimport \"./IConfig.sol\";\nimport \"./CourtConfigData.sol\";\nimport \"../../lib/PctHelpers.sol\";\n\n\ncontract CourtConfig is IConfig, CourtConfigData {\n    using SafeMath64 for uint64;\n    using PctHelpers for uint256;\n\n    string private constant ERROR_TOO_OLD_TERM = \"CONF_TOO_OLD_TERM\";\n    string private constant ERROR_INVALID_PENALTY_PCT = \"CONF_INVALID_PENALTY_PCT\";\n    string private constant ERROR_INVALID_FINAL_ROUND_REDUCTION_PCT = \"CONF_INVALID_FINAL_ROUND_RED_PCT\";\n    string private constant ERROR_INVALID_MAX_APPEAL_ROUNDS = \"CONF_INVALID_MAX_APPEAL_ROUNDS\";\n    string private constant ERROR_LARGE_ROUND_PHASE_DURATION = \"CONF_LARGE_ROUND_PHASE_DURATION\";\n    string private constant ERROR_BAD_INITIAL_JURORS_NUMBER = \"CONF_BAD_INITIAL_JURORS_NUMBER\";\n    string private constant ERROR_BAD_APPEAL_STEP_FACTOR = \"CONF_BAD_APPEAL_STEP_FACTOR\";\n    string private constant ERROR_ZERO_COLLATERAL_FACTOR = \"CONF_ZERO_COLLATERAL_FACTOR\";\n    string private constant ERROR_ZERO_MIN_ACTIVE_BALANCE = \"CONF_ZERO_MIN_ACTIVE_BALANCE\";\n\n    // Max number of terms that each of the different adjudication states can last (if lasted 1h, this would be a year)\n    uint64 internal constant MAX_ADJ_STATE_DURATION = 8670;\n\n    // Cap the max number of regular appeal rounds\n    uint256 internal constant MAX_REGULAR_APPEAL_ROUNDS_LIMIT = 10;\n\n    // Future term ID in which a config change has been scheduled\n    uint64 private configChangeTermId;\n\n    // List of all the configs used in the Court\n    Config[] private configs;\n\n    // List of configs indexed by id\n    mapping (uint64 => uint256) private configIdByTerm;\n\n    // Holders opt-in config for automatic withdrawals\n    mapping (address => bool) private withdrawalsAllowed;\n\n    event NewConfig(uint64 fromTermId, uint64 courtConfigId);\n    event AutomaticWithdrawalsAllowedChanged(address indexed holder, bool allowed);\n\n    /**\n    * @dev Constructor function\n    * @param _feeToken Address of the token contract that is used to pay for fees\n    * @param _fees Array containing:\n    *        0. jurorFee Amount of fee tokens that is paid per juror per dispute\n    *        1. draftFee Amount of fee tokens per juror to cover the drafting cost\n    *        2. settleFee Amount of fee tokens per juror to cover round settlement cost\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n    *        0. evidenceTerms Max submitting evidence period duration in terms\n    *        1. commitTerms Commit period duration in terms\n    *        2. revealTerms Reveal period duration in terms\n    *        3. appealTerms Appeal period duration in terms\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\n    * @param _pcts Array containing:\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\n    * @param _roundParams Array containing params for rounds:\n    *        0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\n    *        1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n    *        3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\n    * @param _appealCollateralParams Array containing params for appeal collateral:\n    *        0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n    *        1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\n    */\n    constructor(\n        ERC20 _feeToken,\n        uint256[3] memory _fees,\n        uint64[5] memory _roundStateDurations,\n        uint16[2] memory _pcts,\n        uint64[4] memory _roundParams,\n        uint256[2] memory _appealCollateralParams,\n        uint256 _minActiveBalance\n    )\n        public\n    {\n        // Leave config at index 0 empty for non-scheduled config changes\n        configs.length = 1;\n        _setConfig(\n            0,\n            0,\n            _feeToken,\n            _fees,\n            _roundStateDurations,\n            _pcts,\n            _roundParams,\n            _appealCollateralParams,\n            _minActiveBalance\n        );\n    }\n\n    /**\n    * @notice Set the automatic withdrawals config for the sender to `_allowed`\n    * @param _allowed Whether or not the automatic withdrawals are allowed by the sender\n    */\n    function setAutomaticWithdrawals(bool _allowed) external {\n        withdrawalsAllowed[msg.sender] = _allowed;\n        emit AutomaticWithdrawalsAllowedChanged(msg.sender, _allowed);\n    }\n\n    /**\n    * @dev Tell the full Court configuration parameters at a certain term\n    * @param _termId Identification number of the term querying the Court config of\n    * @return token Address of the token used to pay for fees\n    * @return fees Array containing:\n    *         0. jurorFee Amount of fee tokens that is paid per juror per dispute\n    *         1. draftFee Amount of fee tokens per juror to cover the drafting cost\n    *         2. settleFee Amount of fee tokens per juror to cover round settlement cost\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n    *         0. evidenceTerms Max submitting evidence period duration in terms\n    *         1. commitTerms Commit period duration in terms\n    *         2. revealTerms Reveal period duration in terms\n    *         3. appealTerms Appeal period duration in terms\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\n    * @return pcts Array containing:\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\n    * @return roundParams Array containing params for rounds:\n    *         0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\n    *         1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n    * @return appealCollateralParams Array containing params for appeal collateral:\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n    * @return minActiveBalance Minimum amount of tokens jurors have to activate to participate in the Court\n    */\n    function getConfig(uint64 _termId) external view\n        returns (\n            ERC20 feeToken,\n            uint256[3] memory fees,\n            uint64[5] memory roundStateDurations,\n            uint16[2] memory pcts,\n            uint64[4] memory roundParams,\n            uint256[2] memory appealCollateralParams,\n            uint256 minActiveBalance\n        );\n\n    /**\n    * @dev Tell the draft config at a certain term\n    * @param _termId Identification number of the term querying the draft config of\n    * @return feeToken Address of the token used to pay for fees\n    * @return draftFee Amount of fee tokens per juror to cover the drafting cost\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    */\n    function getDraftConfig(uint64 _termId) external view returns (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct);\n\n    /**\n    * @dev Tell the min active balance config at a certain term\n    * @param _termId Term querying the min active balance config of\n    * @return Minimum amount of tokens jurors have to activate to participate in the Court\n    */\n    function getMinActiveBalance(uint64 _termId) external view returns (uint256);\n\n    /**\n    * @dev Tell whether a certain holder accepts automatic withdrawals of tokens or not\n    * @param _holder Address of the token holder querying if withdrawals are allowed for\n    * @return True if the given holder accepts automatic withdrawals of their tokens, false otherwise\n    */\n    function areWithdrawalsAllowedFor(address _holder) external view returns (bool) {\n        return withdrawalsAllowed[_holder];\n    }\n\n    /**\n    * @dev Tell the term identification number of the next scheduled config change\n    * @return Term identification number of the next scheduled config change\n    */\n    function getConfigChangeTermId() external view returns (uint64) {\n        return configChangeTermId;\n    }\n\n    /**\n    * @dev Internal to make sure to set a config for the new term, it will copy the previous term config if none\n    * @param _termId Identification number of the new current term that has been transitioned\n    */\n    function _ensureTermConfig(uint64 _termId) internal {\n        // If the term being transitioned had no config change scheduled, keep the previous one\n        uint256 currentConfigId = configIdByTerm[_termId];\n        if (currentConfigId == 0) {\n            uint256 previousConfigId = configIdByTerm[_termId.sub(1)];\n            configIdByTerm[_termId] = previousConfigId;\n        }\n    }\n\n    /**\n    * @dev Assumes that sender it's allowed (either it's from governor or it's on init)\n    * @param _termId Identification number of the current Court term\n    * @param _fromTermId Identification number of the term in which the config will be effective at\n    * @param _feeToken Address of the token contract that is used to pay for fees.\n    * @param _fees Array containing:\n    *        0. jurorFee Amount of fee tokens that is paid per juror per dispute\n    *        1. draftFee Amount of fee tokens per juror to cover the drafting cost\n    *        2. settleFee Amount of fee tokens per juror to cover round settlement cost\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n    *        0. evidenceTerms Max submitting evidence period duration in terms\n    *        1. commitTerms Commit period duration in terms\n    *        2. revealTerms Reveal period duration in terms\n    *        3. appealTerms Appeal period duration in terms\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\n    * @param _pcts Array containing:\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\n    * @param _roundParams Array containing params for rounds:\n    *        0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\n    *        1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n    *        3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\n    * @param _appealCollateralParams Array containing params for appeal collateral:\n    *        0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n    *        1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\n    */\n    function _setConfig(\n        uint64 _termId,\n        uint64 _fromTermId,\n        ERC20 _feeToken,\n        uint256[3] memory _fees,\n        uint64[5] memory _roundStateDurations,\n        uint16[2] memory _pcts,\n        uint64[4] memory _roundParams,\n        uint256[2] memory _appealCollateralParams,\n        uint256 _minActiveBalance\n    )\n        internal\n    {\n        // If the current term is not zero, changes must be scheduled at least after the current period.\n        // No need to ensure delays for on-going disputes since these already use their creation term for that.\n        require(_termId == 0 || _fromTermId > _termId, ERROR_TOO_OLD_TERM);\n\n        // Make sure appeal collateral factors are greater than zero\n        require(_appealCollateralParams[0] > 0 && _appealCollateralParams[1] > 0, ERROR_ZERO_COLLATERAL_FACTOR);\n\n        // Make sure the given penalty and final round reduction pcts are not greater than 100%\n        require(PctHelpers.isValid(_pcts[0]), ERROR_INVALID_PENALTY_PCT);\n        require(PctHelpers.isValid(_pcts[1]), ERROR_INVALID_FINAL_ROUND_REDUCTION_PCT);\n\n        // Disputes must request at least one juror to be drafted initially\n        require(_roundParams[0] > 0, ERROR_BAD_INITIAL_JURORS_NUMBER);\n\n        // Prevent that further rounds have zero jurors\n        require(_roundParams[1] > 0, ERROR_BAD_APPEAL_STEP_FACTOR);\n\n        // Make sure the max number of appeals allowed does not reach the limit\n        uint256 _maxRegularAppealRounds = _roundParams[2];\n        bool isMaxAppealRoundsValid = _maxRegularAppealRounds > 0 && _maxRegularAppealRounds <= MAX_REGULAR_APPEAL_ROUNDS_LIMIT;\n        require(isMaxAppealRoundsValid, ERROR_INVALID_MAX_APPEAL_ROUNDS);\n\n        // Make sure each adjudication round phase duration is valid\n        for (uint i = 0; i < _roundStateDurations.length; i++) {\n            require(_roundStateDurations[i] > 0 && _roundStateDurations[i] < MAX_ADJ_STATE_DURATION, ERROR_LARGE_ROUND_PHASE_DURATION);\n        }\n\n        // Make sure min active balance is not zero\n        require(_minActiveBalance > 0, ERROR_ZERO_MIN_ACTIVE_BALANCE);\n\n        // If there was a config change already scheduled, reset it (in that case we will overwrite last array item).\n        // Otherwise, schedule a new config.\n        if (configChangeTermId > _termId) {\n            configIdByTerm[configChangeTermId] = 0;\n        } else {\n            configs.length++;\n        }\n\n        uint64 courtConfigId = uint64(configs.length - 1);\n        Config storage config = configs[courtConfigId];\n\n        config.fees = FeesConfig({\n            token: _feeToken,\n            jurorFee: _fees[0],\n            draftFee: _fees[1],\n            settleFee: _fees[2],\n            finalRoundReduction: _pcts[1]\n        });\n\n        config.disputes = DisputesConfig({\n            evidenceTerms: _roundStateDurations[0],\n            commitTerms: _roundStateDurations[1],\n            revealTerms: _roundStateDurations[2],\n            appealTerms: _roundStateDurations[3],\n            appealConfirmTerms: _roundStateDurations[4],\n            penaltyPct: _pcts[0],\n            firstRoundJurorsNumber: _roundParams[0],\n            appealStepFactor: _roundParams[1],\n            maxRegularAppealRounds: _maxRegularAppealRounds,\n            finalRoundLockTerms: _roundParams[3],\n            appealCollateralFactor: _appealCollateralParams[0],\n            appealConfirmCollateralFactor: _appealCollateralParams[1]\n        });\n\n        config.minActiveBalance = _minActiveBalance;\n\n        configIdByTerm[_fromTermId] = courtConfigId;\n        configChangeTermId = _fromTermId;\n\n        emit NewConfig(_fromTermId, courtConfigId);\n    }\n\n    /**\n    * @dev Internal function to get the Court config for a given term\n    * @param _termId Identification number of the term querying the Court config of\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\n    * @return token Address of the token used to pay for fees\n    * @return fees Array containing:\n    *         0. jurorFee Amount of fee tokens that is paid per juror per dispute\n    *         1. draftFee Amount of fee tokens per juror to cover the drafting cost\n    *         2. settleFee Amount of fee tokens per juror to cover round settlement cost\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n    *         0. evidenceTerms Max submitting evidence period duration in terms\n    *         1. commitTerms Commit period duration in terms\n    *         2. revealTerms Reveal period duration in terms\n    *         3. appealTerms Appeal period duration in terms\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\n    * @return pcts Array containing:\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\n    * @return roundParams Array containing params for rounds:\n    *         0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\n    *         1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n    *         3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\n    * @return appealCollateralParams Array containing params for appeal collateral:\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n    * @return minActiveBalance Minimum amount of juror tokens that can be activated\n    */\n    function _getConfigAt(uint64 _termId, uint64 _lastEnsuredTermId) internal view\n        returns (\n            ERC20 feeToken,\n            uint256[3] memory fees,\n            uint64[5] memory roundStateDurations,\n            uint16[2] memory pcts,\n            uint64[4] memory roundParams,\n            uint256[2] memory appealCollateralParams,\n            uint256 minActiveBalance\n        )\n    {\n        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\n\n        FeesConfig storage feesConfig = config.fees;\n        feeToken = feesConfig.token;\n        fees = [feesConfig.jurorFee, feesConfig.draftFee, feesConfig.settleFee];\n\n        DisputesConfig storage disputesConfig = config.disputes;\n        roundStateDurations = [\n            disputesConfig.evidenceTerms,\n            disputesConfig.commitTerms,\n            disputesConfig.revealTerms,\n            disputesConfig.appealTerms,\n            disputesConfig.appealConfirmTerms\n        ];\n        pcts = [disputesConfig.penaltyPct, feesConfig.finalRoundReduction];\n        roundParams = [\n            disputesConfig.firstRoundJurorsNumber,\n            disputesConfig.appealStepFactor,\n            uint64(disputesConfig.maxRegularAppealRounds),\n            disputesConfig.finalRoundLockTerms\n        ];\n        appealCollateralParams = [disputesConfig.appealCollateralFactor, disputesConfig.appealConfirmCollateralFactor];\n\n        minActiveBalance = config.minActiveBalance;\n    }\n\n    /**\n    * @dev Tell the draft config at a certain term\n    * @param _termId Identification number of the term querying the draft config of\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\n    * @return feeToken Address of the token used to pay for fees\n    * @return draftFee Amount of fee tokens per juror to cover the drafting cost\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    */\n    function _getDraftConfig(uint64 _termId,  uint64 _lastEnsuredTermId) internal view\n        returns (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct)\n    {\n        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\n        return (config.fees.token, config.fees.draftFee, config.disputes.penaltyPct);\n    }\n\n    /**\n    * @dev Internal function to get the min active balance config for a given term\n    * @param _termId Identification number of the term querying the min active balance config of\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\n    * @return Minimum amount of juror tokens that can be activated at the given term\n    */\n    function _getMinActiveBalance(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (uint256) {\n        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\n        return config.minActiveBalance;\n    }\n\n    /**\n    * @dev Internal function to get the Court config for a given term\n    * @param _termId Identification number of the term querying the min active balance config of\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\n    * @return Court config for the given term\n    */\n    function _getConfigFor(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (Config storage) {\n        uint256 id = _getConfigIdFor(_termId, _lastEnsuredTermId);\n        return configs[id];\n    }\n\n    /**\n    * @dev Internal function to get the Court config ID for a given term\n    * @param _termId Identification number of the term querying the Court config of\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\n    * @return Identification number of the config for the given terms\n    */\n    function _getConfigIdFor(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (uint256) {\n        // If the given term is lower or equal to the last ensured Court term, it is safe to use a past Court config\n        if (_termId <= _lastEnsuredTermId) {\n            return configIdByTerm[_termId];\n        }\n\n        // If the given term is in the future but there is a config change scheduled before it, use the incoming config\n        uint64 scheduledChangeTermId = configChangeTermId;\n        if (scheduledChangeTermId <= _termId) {\n            return configIdByTerm[scheduledChangeTermId];\n        }\n\n        // If no changes are scheduled, use the Court config of the last ensured term\n        return configIdByTerm[_lastEnsuredTermId];\n    }\n}\n"
    },
    "contracts/court/config/IConfig.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../lib/os/ERC20.sol\";\n\n\ninterface IConfig {\n\n    /**\n    * @dev Tell the full Court configuration parameters at a certain term\n    * @param _termId Identification number of the term querying the Court config of\n    * @return token Address of the token used to pay for fees\n    * @return fees Array containing:\n    *         0. jurorFee Amount of fee tokens that is paid per juror per dispute\n    *         1. draftFee Amount of fee tokens per juror to cover the drafting cost\n    *         2. settleFee Amount of fee tokens per juror to cover round settlement cost\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n    *         0. evidenceTerms Max submitting evidence period duration in terms\n    *         1. commitTerms Commit period duration in terms\n    *         2. revealTerms Reveal period duration in terms\n    *         3. appealTerms Appeal period duration in terms\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\n    * @return pcts Array containing:\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\n    * @return roundParams Array containing params for rounds:\n    *         0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\n    *         1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n    * @return appealCollateralParams Array containing params for appeal collateral:\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n    * @return minActiveBalance Minimum amount of tokens jurors have to activate to participate in the Court\n    */\n    function getConfig(uint64 _termId) external view\n        returns (\n            ERC20 feeToken,\n            uint256[3] memory fees,\n            uint64[5] memory roundStateDurations,\n            uint16[2] memory pcts,\n            uint64[4] memory roundParams,\n            uint256[2] memory appealCollateralParams,\n            uint256 minActiveBalance\n        );\n\n    /**\n    * @dev Tell the draft config at a certain term\n    * @param _termId Identification number of the term querying the draft config of\n    * @return feeToken Address of the token used to pay for fees\n    * @return draftFee Amount of fee tokens per juror to cover the drafting cost\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n    */\n    function getDraftConfig(uint64 _termId) external view returns (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct);\n\n    /**\n    * @dev Tell the min active balance config at a certain term\n    * @param _termId Term querying the min active balance config of\n    * @return Minimum amount of tokens jurors have to activate to participate in the Court\n    */\n    function getMinActiveBalance(uint64 _termId) external view returns (uint256);\n\n    /**\n    * @dev Tell whether a certain holder accepts automatic withdrawals of tokens or not\n    * @return True if the given holder accepts automatic withdrawals of their tokens, false otherwise\n    */\n    function areWithdrawalsAllowedFor(address _holder) external view returns (bool);\n}\n"
    },
    "contracts/court/config/CourtConfigData.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../lib/os/ERC20.sol\";\n\n\ncontract CourtConfigData {\n    struct Config {\n        FeesConfig fees;                        // Full fees-related config\n        DisputesConfig disputes;                // Full disputes-related config\n        uint256 minActiveBalance;               // Minimum amount of tokens jurors have to activate to participate in the Court\n    }\n\n    struct FeesConfig {\n        ERC20 token;                            // ERC20 token to be used for the fees of the Court\n        uint16 finalRoundReduction;             // Permyriad of fees reduction applied for final appeal round (‱ - 1/10,000)\n        uint256 jurorFee;                       // Amount of tokens paid to draft a juror to adjudicate a dispute\n        uint256 draftFee;                       // Amount of tokens paid per round to cover the costs of drafting jurors\n        uint256 settleFee;                      // Amount of tokens paid per round to cover the costs of slashing jurors\n    }\n\n    struct DisputesConfig {\n        uint64 evidenceTerms;                   // Max submitting evidence period duration in terms\n        uint64 commitTerms;                     // Committing period duration in terms\n        uint64 revealTerms;                     // Revealing period duration in terms\n        uint64 appealTerms;                     // Appealing period duration in terms\n        uint64 appealConfirmTerms;              // Confirmation appeal period duration in terms\n        uint16 penaltyPct;                      // Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n        uint64 firstRoundJurorsNumber;          // Number of jurors drafted on first round\n        uint64 appealStepFactor;                // Factor in which the jurors number is increased on each appeal\n        uint64 finalRoundLockTerms;             // Period a coherent juror in the final round will remain locked\n        uint256 maxRegularAppealRounds;         // Before the final appeal\n        uint256 appealCollateralFactor;         // Permyriad multiple of dispute fees required to appeal a preliminary ruling (‱ - 1/10,000)\n        uint256 appealConfirmCollateralFactor;  // Permyriad multiple of dispute fees required to confirm appeal (‱ - 1/10,000)\n    }\n\n    struct DraftConfig {\n        ERC20 feeToken;                         // ERC20 token to be used for the fees of the Court\n        uint16 penaltyPct;                      // Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\n        uint256 draftFee;                       // Amount of tokens paid per round to cover the costs of drafting jurors\n    }\n}\n"
    },
    "contracts/lib/PctHelpers.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../lib/os/SafeMath.sol\";\n\n\nlibrary PctHelpers {\n    using SafeMath for uint256;\n\n    uint256 internal constant PCT_BASE = 10000; // ‱ (1 / 10,000)\n\n    function isValid(uint16 _pct) internal pure returns (bool) {\n        return _pct <= PCT_BASE;\n    }\n\n    function pct(uint256 self, uint16 _pct) internal pure returns (uint256) {\n        return self.mul(uint256(_pct)) / PCT_BASE;\n    }\n\n    function pct256(uint256 self, uint256 _pct) internal pure returns (uint256) {\n        return self.mul(_pct) / PCT_BASE;\n    }\n\n    function pctIncrease(uint256 self, uint16 _pct) internal pure returns (uint256) {\n        // No need for SafeMath: for addition note that `PCT_BASE` is lower than (2^256 - 2^16)\n        return self.mul(PCT_BASE + uint256(_pct)) / PCT_BASE;\n    }\n}\n"
    },
    "contracts/lib/os/SafeMath.sol": {
      "content": "// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/math/SafeMath.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    string private constant ERROR_ADD_OVERFLOW = \"MATH_ADD_OVERFLOW\";\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH_SUB_UNDERFLOW\";\n    string private constant ERROR_MUL_OVERFLOW = \"MATH_MUL_OVERFLOW\";\n    string private constant ERROR_DIV_ZERO = \"MATH_DIV_ZERO\";\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        uint256 c = _a * _b;\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n        uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n        uint256 c = _a - _b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        uint256 c = _a + _b;\n        require(c >= _a, ERROR_ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, ERROR_DIV_ZERO);\n        return a % b;\n    }\n}\n"
    },
    "contracts/disputes/IDisputeManager.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../lib/os/ERC20.sol\";\nimport \"../arbitration/IArbitrable.sol\";\n\n\ninterface IDisputeManager {\n    enum DisputeState {\n        PreDraft,\n        Adjudicating,\n        Ruled\n    }\n\n    enum AdjudicationState {\n        Invalid,\n        Committing,\n        Revealing,\n        Appealing,\n        ConfirmingAppeal,\n        Ended\n    }\n\n    /**\n    * @dev Create a dispute to be drafted in a future term\n    * @param _subject Arbitrable instance creating the dispute\n    * @param _possibleRulings Number of possible rulings allowed for the drafted jurors to vote on the dispute\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\n    * @return Dispute identification number\n    */\n    function createDispute(IArbitrable _subject, uint8 _possibleRulings, bytes calldata _metadata) external returns (uint256);\n\n    /**\n    * @dev Close the evidence period of a dispute\n    * @param _subject IArbitrable instance requesting to close the evidence submission period\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\n    */\n    function closeEvidencePeriod(IArbitrable _subject, uint256 _disputeId) external;\n\n    /**\n    * @dev Draft jurors for the next round of a dispute\n    * @param _disputeId Identification number of the dispute to be drafted\n    */\n    function draft(uint256 _disputeId) external;\n\n    /**\n    * @dev Appeal round of a dispute in favor of a certain ruling\n    * @param _disputeId Identification number of the dispute being appealed\n    * @param _roundId Identification number of the dispute round being appealed\n    * @param _ruling Ruling appealing a dispute round in favor of\n    */\n    function createAppeal(uint256 _disputeId, uint256 _roundId, uint8 _ruling) external;\n\n    /**\n    * @dev Confirm appeal for a round of a dispute in favor of a ruling\n    * @param _disputeId Identification number of the dispute confirming an appeal of\n    * @param _roundId Identification number of the dispute round confirming an appeal of\n    * @param _ruling Ruling being confirmed against a dispute round appeal\n    */\n    function confirmAppeal(uint256 _disputeId, uint256 _roundId, uint8 _ruling) external;\n\n    /**\n    * @dev Compute the final ruling for a dispute\n    * @param _disputeId Identification number of the dispute to compute its final ruling\n    * @return subject Arbitrable instance associated to the dispute\n    * @return finalRuling Final ruling decided for the given dispute\n    */\n    function computeRuling(uint256 _disputeId) external returns (IArbitrable subject, uint8 finalRuling);\n\n    /**\n    * @dev Settle penalties for a round of a dispute\n    * @param _disputeId Identification number of the dispute to settle penalties for\n    * @param _roundId Identification number of the dispute round to settle penalties for\n    * @param _jurorsToSettle Maximum number of jurors to be slashed in this call\n    */\n    function settlePenalties(uint256 _disputeId, uint256 _roundId, uint256 _jurorsToSettle) external;\n\n    /**\n    * @dev Claim rewards for a round of a dispute for juror\n    * @dev For regular rounds, it will only reward winning jurors\n    * @param _disputeId Identification number of the dispute to settle rewards for\n    * @param _roundId Identification number of the dispute round to settle rewards for\n    * @param _juror Address of the juror to settle their rewards\n    */\n    function settleReward(uint256 _disputeId, uint256 _roundId, address _juror) external;\n\n    /**\n    * @dev Settle appeal deposits for a round of a dispute\n    * @param _disputeId Identification number of the dispute to settle appeal deposits for\n    * @param _roundId Identification number of the dispute round to settle appeal deposits for\n    */\n    function settleAppealDeposit(uint256 _disputeId, uint256 _roundId) external;\n\n    /**\n    * @dev Tell the amount of token fees required to create a dispute\n    * @return feeToken ERC20 token used for the fees\n    * @return feeAmount Total amount of fees to be paid for a dispute at the given term\n    */\n    function getDisputeFees() external view returns (ERC20 feeToken, uint256 feeAmount);\n\n    /**\n    * @dev Tell information of a certain dispute\n    * @param _disputeId Identification number of the dispute being queried\n    * @return subject Arbitrable subject being disputed\n    * @return possibleRulings Number of possible rulings allowed for the drafted jurors to vote on the dispute\n    * @return state Current state of the dispute being queried: pre-draft, adjudicating, or ruled\n    * @return finalRuling The winning ruling in case the dispute is finished\n    * @return lastRoundId Identification number of the last round created for the dispute\n    * @return createTermId Identification number of the term when the dispute was created\n    */\n    function getDispute(uint256 _disputeId) external view\n        returns (IArbitrable subject, uint8 possibleRulings, DisputeState state, uint8 finalRuling, uint256 lastRoundId, uint64 createTermId);\n\n    /**\n    * @dev Tell information of a certain adjudication round\n    * @param _disputeId Identification number of the dispute being queried\n    * @param _roundId Identification number of the round being queried\n    * @return draftTerm Term from which the requested round can be drafted\n    * @return delayedTerms Number of terms the given round was delayed based on its requested draft term id\n    * @return jurorsNumber Number of jurors requested for the round\n    * @return selectedJurors Number of jurors already selected for the requested round\n    * @return settledPenalties Whether or not penalties have been settled for the requested round\n    * @return collectedTokens Amount of juror tokens that were collected from slashed jurors for the requested round\n    * @return coherentJurors Number of jurors that voted in favor of the final ruling in the requested round\n    * @return state Adjudication state of the requested round\n    */\n    function getRound(uint256 _disputeId, uint256 _roundId) external view\n        returns (\n            uint64 draftTerm,\n            uint64 delayedTerms,\n            uint64 jurorsNumber,\n            uint64 selectedJurors,\n            uint256 jurorFees,\n            bool settledPenalties,\n            uint256 collectedTokens,\n            uint64 coherentJurors,\n            AdjudicationState state\n        );\n\n    /**\n    * @dev Tell appeal-related information of a certain adjudication round\n    * @param _disputeId Identification number of the dispute being queried\n    * @param _roundId Identification number of the round being queried\n    * @return maker Address of the account appealing the given round\n    * @return appealedRuling Ruling confirmed by the appealer of the given round\n    * @return taker Address of the account confirming the appeal of the given round\n    * @return opposedRuling Ruling confirmed by the appeal taker of the given round\n    */\n    function getAppeal(uint256 _disputeId, uint256 _roundId) external view\n        returns (address maker, uint64 appealedRuling, address taker, uint64 opposedRuling);\n\n    /**\n    * @dev Tell information related to the next round due to an appeal of a certain round given.\n    * @param _disputeId Identification number of the dispute being queried\n    * @param _roundId Identification number of the round requesting the appeal details of\n    * @return nextRoundStartTerm Term ID from which the next round will start\n    * @return nextRoundJurorsNumber Jurors number for the next round\n    * @return newDisputeState New state for the dispute associated to the given round after the appeal\n    * @return feeToken ERC20 token used for the next round fees\n    * @return jurorFees Total amount of fees to be distributed between the winning jurors of the next round\n    * @return totalFees Total amount of fees for a regular round at the given term\n    * @return appealDeposit Amount to be deposit of fees for a regular round at the given term\n    * @return confirmAppealDeposit Total amount of fees for a regular round at the given term\n    */\n    function getNextRoundDetails(uint256 _disputeId, uint256 _roundId) external view\n        returns (\n            uint64 nextRoundStartTerm,\n            uint64 nextRoundJurorsNumber,\n            DisputeState newDisputeState,\n            ERC20 feeToken,\n            uint256 totalFees,\n            uint256 jurorFees,\n            uint256 appealDeposit,\n            uint256 confirmAppealDeposit\n        );\n\n    /**\n    * @dev Tell juror-related information of a certain adjudication round\n    * @param _disputeId Identification number of the dispute being queried\n    * @param _roundId Identification number of the round being queried\n    * @param _juror Address of the juror being queried\n    * @return weight Juror weight drafted for the requested round\n    * @return rewarded Whether or not the given juror was rewarded based on the requested round\n    */\n    function getJuror(uint256 _disputeId, uint256 _roundId, address _juror) external view returns (uint64 weight, bool rewarded);\n}\n"
    },
    "contracts/subscriptions/ISubscriptions.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../lib/os/ERC20.sol\";\n\n\ninterface ISubscriptions {\n    /**\n    * @dev Tell whether a certain subscriber has paid all the fees up to current period or not\n    * @param _subscriber Address of subscriber being checked\n    * @return True if subscriber has paid all the fees up to current period, false otherwise\n    */\n    function isUpToDate(address _subscriber) external view returns (bool);\n\n    /**\n    * @dev Tell the minimum amount of fees to pay and resulting last paid period for a given subscriber in order to be up-to-date\n    * @param _subscriber Address of the subscriber willing to pay\n    * @return feeToken ERC20 token used for the subscription fees\n    * @return amountToPay Amount of subscription fee tokens to be paid\n    * @return newLastPeriodId Identification number of the resulting last paid period\n    */\n    function getOwedFeesDetails(address _subscriber) external view returns (ERC20, uint256, uint256);\n}\n"
    },
    "contracts/court/config/ConfigConsumer.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../lib/os/ERC20.sol\";\n\nimport \"./IConfig.sol\";\nimport \"./CourtConfigData.sol\";\n\n\ncontract ConfigConsumer is CourtConfigData {\n    /**\n    * @dev Internal function to fetch the address of the Config module from the controller\n    * @return Address of the Config module\n    */\n    function _courtConfig() internal view returns (IConfig);\n\n    /**\n    * @dev Internal function to get the Court config for a certain term\n    * @param _termId Identification number of the term querying the Court config of\n    * @return Court config for the given term\n    */\n    function _getConfigAt(uint64 _termId) internal view returns (Config memory) {\n        (ERC20 _feeToken,\n        uint256[3] memory _fees,\n        uint64[5] memory _roundStateDurations,\n        uint16[2] memory _pcts,\n        uint64[4] memory _roundParams,\n        uint256[2] memory _appealCollateralParams,\n        uint256 _minActiveBalance) = _courtConfig().getConfig(_termId);\n\n        Config memory config;\n\n        config.fees = FeesConfig({\n            token: _feeToken,\n            jurorFee: _fees[0],\n            draftFee: _fees[1],\n            settleFee: _fees[2],\n            finalRoundReduction: _pcts[1]\n        });\n\n        config.disputes = DisputesConfig({\n            evidenceTerms: _roundStateDurations[0],\n            commitTerms: _roundStateDurations[1],\n            revealTerms: _roundStateDurations[2],\n            appealTerms: _roundStateDurations[3],\n            appealConfirmTerms: _roundStateDurations[4],\n            penaltyPct: _pcts[0],\n            firstRoundJurorsNumber: _roundParams[0],\n            appealStepFactor: _roundParams[1],\n            maxRegularAppealRounds: _roundParams[2],\n            finalRoundLockTerms: _roundParams[3],\n            appealCollateralFactor: _appealCollateralParams[0],\n            appealConfirmCollateralFactor: _appealCollateralParams[1]\n        });\n\n        config.minActiveBalance = _minActiveBalance;\n\n        return config;\n    }\n\n    /**\n    * @dev Internal function to get the draft config for a given term\n    * @param _termId Identification number of the term querying the draft config of\n    * @return Draft config for the given term\n    */\n    function _getDraftConfig(uint64 _termId) internal view returns (DraftConfig memory) {\n        (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct) = _courtConfig().getDraftConfig(_termId);\n        return DraftConfig({ feeToken: feeToken, draftFee: draftFee, penaltyPct: penaltyPct });\n    }\n\n    /**\n    * @dev Internal function to get the min active balance config for a given term\n    * @param _termId Identification number of the term querying the min active balance config of\n    * @return Minimum amount of juror tokens that can be activated\n    */\n    function _getMinActiveBalance(uint64 _termId) internal view returns (uint256) {\n        return _courtConfig().getMinActiveBalance(_termId);\n    }\n}\n"
    },
    "contracts/court/controller/Controlled.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../lib/os/IsContract.sol\";\n\nimport \"./Controller.sol\";\nimport \"../clock/IClock.sol\";\nimport \"../config/ConfigConsumer.sol\";\nimport \"../../voting/ICRVoting.sol\";\nimport \"../../treasury/ITreasury.sol\";\nimport \"../../registry/IJurorsRegistry.sol\";\nimport \"../../disputes/IDisputeManager.sol\";\nimport \"../../subscriptions/ISubscriptions.sol\";\n\n\ncontract Controlled is IsContract, ConfigConsumer {\n    string private constant ERROR_CONTROLLER_NOT_CONTRACT = \"CTD_CONTROLLER_NOT_CONTRACT\";\n    string private constant ERROR_SENDER_NOT_CONTROLLER = \"CTD_SENDER_NOT_CONTROLLER\";\n    string private constant ERROR_SENDER_NOT_CONFIG_GOVERNOR = \"CTD_SENDER_NOT_CONFIG_GOVERNOR\";\n    string private constant ERROR_SENDER_NOT_DISPUTES_MODULE = \"CTD_SENDER_NOT_DISPUTES_MODULE\";\n\n    // Address of the controller\n    Controller internal controller;\n\n    /**\n    * @dev Ensure the msg.sender is the controller's config governor\n    */\n    modifier onlyConfigGovernor {\n        require(msg.sender == _configGovernor(), ERROR_SENDER_NOT_CONFIG_GOVERNOR);\n        _;\n    }\n\n    /**\n    * @dev Ensure the msg.sender is the controller\n    */\n    modifier onlyController() {\n        require(msg.sender == address(controller), ERROR_SENDER_NOT_CONTROLLER);\n        _;\n    }\n\n    /**\n    * @dev Ensure the msg.sender is the DisputeManager module\n    */\n    modifier onlyDisputeManager() {\n        require(msg.sender == address(_disputeManager()), ERROR_SENDER_NOT_DISPUTES_MODULE);\n        _;\n    }\n\n    /**\n    * @dev Constructor function\n    * @param _controller Address of the controller\n    */\n    constructor(Controller _controller) public {\n        require(isContract(address(_controller)), ERROR_CONTROLLER_NOT_CONTRACT);\n        controller = _controller;\n    }\n\n    /**\n    * @dev Tell the address of the controller\n    * @return Address of the controller\n    */\n    function getController() external view returns (Controller) {\n        return controller;\n    }\n\n    /**\n    * @dev Internal function to ensure the Court term is up-to-date, it will try to update it if not\n    * @return Identification number of the current Court term\n    */\n    function _ensureCurrentTerm() internal returns (uint64) {\n        return _clock().ensureCurrentTerm();\n    }\n\n    /**\n    * @dev Internal function to fetch the last ensured term ID of the Court\n    * @return Identification number of the last ensured term\n    */\n    function _getLastEnsuredTermId() internal view returns (uint64) {\n        return _clock().getLastEnsuredTermId();\n    }\n\n    /**\n    * @dev Internal function to tell the current term identification number\n    * @return Identification number of the current term\n    */\n    function _getCurrentTermId() internal view returns (uint64) {\n        return _clock().getCurrentTermId();\n    }\n\n    /**\n    * @dev Internal function to fetch the controller's config governor\n    * @return Address of the controller's governor\n    */\n    function _configGovernor() internal view returns (address) {\n        return controller.getConfigGovernor();\n    }\n\n    /**\n    * @dev Internal function to fetch the address of the DisputeManager module from the controller\n    * @return Address of the DisputeManager module\n    */\n    function _disputeManager() internal view returns (IDisputeManager) {\n        return IDisputeManager(controller.getDisputeManager());\n    }\n\n    /**\n    * @dev Internal function to fetch the address of the Treasury module implementation from the controller\n    * @return Address of the Treasury module implementation\n    */\n    function _treasury() internal view returns (ITreasury) {\n        return ITreasury(controller.getTreasury());\n    }\n\n    /**\n    * @dev Internal function to fetch the address of the Voting module implementation from the controller\n    * @return Address of the Voting module implementation\n    */\n    function _voting() internal view returns (ICRVoting) {\n        return ICRVoting(controller.getVoting());\n    }\n\n    /**\n    * @dev Internal function to fetch the address of the Voting module owner from the controller\n    * @return Address of the Voting module owner\n    */\n    function _votingOwner() internal view returns (ICRVotingOwner) {\n        return ICRVotingOwner(address(_disputeManager()));\n    }\n\n    /**\n    * @dev Internal function to fetch the address of the JurorRegistry module implementation from the controller\n    * @return Address of the JurorRegistry module implementation\n    */\n    function _jurorsRegistry() internal view returns (IJurorsRegistry) {\n        return IJurorsRegistry(controller.getJurorsRegistry());\n    }\n\n    /**\n    * @dev Internal function to fetch the address of the Subscriptions module implementation from the controller\n    * @return Address of the Subscriptions module implementation\n    */\n    function _subscriptions() internal view returns (ISubscriptions) {\n        return ISubscriptions(controller.getSubscriptions());\n    }\n\n    /**\n    * @dev Internal function to fetch the address of the Clock module from the controller\n    * @return Address of the Clock module\n    */\n    function _clock() internal view returns (IClock) {\n        return IClock(controller);\n    }\n\n    /**\n    * @dev Internal function to fetch the address of the Config module from the controller\n    * @return Address of the Config module\n    */\n    function _courtConfig() internal view returns (IConfig) {\n        return IConfig(controller);\n    }\n}\n"
    },
    "contracts/voting/ICRVoting.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"./ICRVotingOwner.sol\";\n\n\ninterface ICRVoting {\n    /**\n    * @dev Create a new vote instance\n    * @dev This function can only be called by the CRVoting owner\n    * @param _voteId ID of the new vote instance to be created\n    * @param _possibleOutcomes Number of possible outcomes for the new vote instance to be created\n    */\n    function create(uint256 _voteId, uint8 _possibleOutcomes) external;\n\n    /**\n    * @dev Get the winning outcome of a vote instance\n    * @param _voteId ID of the vote instance querying the winning outcome of\n    * @return Winning outcome of the given vote instance or refused in case it's missing\n    */\n    function getWinningOutcome(uint256 _voteId) external view returns (uint8);\n\n    /**\n    * @dev Get the tally of an outcome for a certain vote instance\n    * @param _voteId ID of the vote instance querying the tally of\n    * @param _outcome Outcome querying the tally of\n    * @return Tally of the outcome being queried for the given vote instance\n    */\n    function getOutcomeTally(uint256 _voteId, uint8 _outcome) external view returns (uint256);\n\n    /**\n    * @dev Tell whether an outcome is valid for a given vote instance or not\n    * @param _voteId ID of the vote instance to check the outcome of\n    * @param _outcome Outcome to check if valid or not\n    * @return True if the given outcome is valid for the requested vote instance, false otherwise\n    */\n    function isValidOutcome(uint256 _voteId, uint8 _outcome) external view returns (bool);\n\n    /**\n    * @dev Get the outcome voted by a voter for a certain vote instance\n    * @param _voteId ID of the vote instance querying the outcome of\n    * @param _voter Address of the voter querying the outcome of\n    * @return Outcome of the voter for the given vote instance\n    */\n    function getVoterOutcome(uint256 _voteId, address _voter) external view returns (uint8);\n\n    /**\n    * @dev Tell whether a voter voted in favor of a certain outcome in a vote instance or not\n    * @param _voteId ID of the vote instance to query if a voter voted in favor of a certain outcome\n    * @param _outcome Outcome to query if the given voter voted in favor of\n    * @param _voter Address of the voter to query if voted in favor of the given outcome\n    * @return True if the given voter voted in favor of the given outcome, false otherwise\n    */\n    function hasVotedInFavorOf(uint256 _voteId, uint8 _outcome, address _voter) external view returns (bool);\n\n    /**\n    * @dev Filter a list of voters based on whether they voted in favor of a certain outcome in a vote instance or not\n    * @param _voteId ID of the vote instance to be checked\n    * @param _outcome Outcome to filter the list of voters of\n    * @param _voters List of addresses of the voters to be filtered\n    * @return List of results to tell whether a voter voted in favor of the given outcome or not\n    */\n    function getVotersInFavorOf(uint256 _voteId, uint8 _outcome, address[] calldata _voters) external view returns (bool[] memory);\n}\n"
    },
    "contracts/voting/ICRVotingOwner.sol": {
      "content": "pragma solidity ^0.5.8;\n\n\ninterface ICRVotingOwner {\n    /**\n    * @dev Ensure votes can be committed for a vote instance, revert otherwise\n    * @param _voteId ID of the vote instance to request the weight of a voter for\n    */\n    function ensureCanCommit(uint256 _voteId) external;\n\n    /**\n    * @dev Ensure a certain voter can commit votes for a vote instance, revert otherwise\n    * @param _voteId ID of the vote instance to request the weight of a voter for\n    * @param _voter Address of the voter querying the weight of\n    */\n    function ensureCanCommit(uint256 _voteId, address _voter) external;\n\n    /**\n    * @dev Ensure a certain voter can reveal votes for vote instance, revert otherwise\n    * @param _voteId ID of the vote instance to request the weight of a voter for\n    * @param _voter Address of the voter querying the weight of\n    * @return Weight of the requested juror for the requested vote instance\n    */\n    function ensureCanReveal(uint256 _voteId, address _voter) external returns (uint64);\n}\n"
    },
    "contracts/treasury/ITreasury.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../lib/os/ERC20.sol\";\n\n\ninterface ITreasury {\n    /**\n    * @dev Assign a certain amount of tokens to an account\n    * @param _token ERC20 token to be assigned\n    * @param _to Address of the recipient that will be assigned the tokens to\n    * @param _amount Amount of tokens to be assigned to the recipient\n    */\n    function assign(ERC20 _token, address _to, uint256 _amount) external;\n\n    /**\n    * @dev Withdraw a certain amount of tokens\n    * @param _token ERC20 token to be withdrawn\n    * @param _to Address of the recipient that will receive the tokens\n    * @param _amount Amount of tokens to be withdrawn from the sender\n    */\n    function withdraw(ERC20 _token, address _to, uint256 _amount) external;\n}\n"
    },
    "contracts/registry/IJurorsRegistry.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../lib/os/ERC20.sol\";\n\n\ninterface IJurorsRegistry {\n\n    /**\n    * @dev Assign a requested amount of juror tokens to a juror\n    * @param _juror Juror to add an amount of tokens to\n    * @param _amount Amount of tokens to be added to the available balance of a juror\n    */\n    function assignTokens(address _juror, uint256 _amount) external;\n\n    /**\n    * @dev Burn a requested amount of juror tokens\n    * @param _amount Amount of tokens to be burned\n    */\n    function burnTokens(uint256 _amount) external;\n\n    /**\n    * @dev Draft a set of jurors based on given requirements for a term id\n    * @param _params Array containing draft requirements:\n    *        0. bytes32 Term randomness\n    *        1. uint256 Dispute id\n    *        2. uint64  Current term id\n    *        3. uint256 Number of seats already filled\n    *        4. uint256 Number of seats left to be filled\n    *        5. uint64  Number of jurors required for the draft\n    *        6. uint16  Permyriad of the minimum active balance to be locked for the draft\n    *\n    * @return jurors List of jurors selected for the draft\n    * @return length Size of the list of the draft result\n    */\n    function draft(uint256[7] calldata _params) external returns (address[] memory jurors, uint256 length);\n\n    /**\n    * @dev Slash a set of jurors based on their votes compared to the winning ruling\n    * @param _termId Current term id\n    * @param _jurors List of juror addresses to be slashed\n    * @param _lockedAmounts List of amounts locked for each corresponding juror that will be either slashed or returned\n    * @param _rewardedJurors List of booleans to tell whether a juror's active balance has to be slashed or not\n    * @return Total amount of slashed tokens\n    */\n    function slashOrUnlock(uint64 _termId, address[] calldata _jurors, uint256[] calldata _lockedAmounts, bool[] calldata _rewardedJurors)\n        external\n        returns (uint256 collectedTokens);\n\n    /**\n    * @dev Try to collect a certain amount of tokens from a juror for the next term\n    * @param _juror Juror to collect the tokens from\n    * @param _amount Amount of tokens to be collected from the given juror and for the requested term id\n    * @param _termId Current term id\n    * @return True if the juror has enough unlocked tokens to be collected for the requested term, false otherwise\n    */\n    function collectTokens(address _juror, uint256 _amount, uint64 _termId) external returns (bool);\n\n    /**\n    * @dev Lock a juror's withdrawals until a certain term ID\n    * @param _juror Address of the juror to be locked\n    * @param _termId Term ID until which the juror's withdrawals will be locked\n    */\n    function lockWithdrawals(address _juror, uint64 _termId) external;\n\n    /**\n    * @dev Tell the active balance of a juror for a given term id\n    * @param _juror Address of the juror querying the active balance of\n    * @param _termId Term ID querying the active balance for\n    * @return Amount of active tokens for juror in the requested past term id\n    */\n    function activeBalanceOfAt(address _juror, uint64 _termId) external view returns (uint256);\n\n    /**\n    * @dev Tell the total amount of active juror tokens at the given term id\n    * @param _termId Term ID querying the total active balance for\n    * @return Total amount of active juror tokens at the given term id\n    */\n    function totalActiveBalanceAt(uint64 _termId) external view returns (uint256);\n}\n"
    },
    "contracts/court/controller/ControlledRecoverable.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../lib/os/ERC20.sol\";\nimport \"../../lib/os/SafeERC20.sol\";\n\nimport \"./Controlled.sol\";\n\n\ncontract ControlledRecoverable is Controlled {\n    using SafeERC20 for ERC20;\n\n    string private constant ERROR_SENDER_NOT_FUNDS_GOVERNOR = \"CTD_SENDER_NOT_FUNDS_GOVERNOR\";\n    string private constant ERROR_INSUFFICIENT_RECOVER_FUNDS = \"CTD_INSUFFICIENT_RECOVER_FUNDS\";\n    string private constant ERROR_RECOVER_TOKEN_FUNDS_FAILED = \"CTD_RECOVER_TOKEN_FUNDS_FAILED\";\n\n    event RecoverFunds(ERC20 token, address recipient, uint256 balance);\n\n    /**\n    * @dev Ensure the msg.sender is the controller's funds governor\n    */\n    modifier onlyFundsGovernor {\n        require(msg.sender == controller.getFundsGovernor(), ERROR_SENDER_NOT_FUNDS_GOVERNOR);\n        _;\n    }\n\n    /**\n    * @dev Constructor function\n    * @param _controller Address of the controller\n    */\n    constructor(Controller _controller) Controlled(_controller) public {\n        // solium-disable-previous-line no-empty-blocks\n    }\n\n    /**\n    * @notice Transfer all `_token` tokens to `_to`\n    * @param _token ERC20 token to be recovered\n    * @param _to Address of the recipient that will be receive all the funds of the requested token\n    */\n    function recoverFunds(ERC20 _token, address _to) external onlyFundsGovernor {\n        uint256 balance = _token.balanceOf(address(this));\n        require(balance > 0, ERROR_INSUFFICIENT_RECOVER_FUNDS);\n        require(_token.safeTransfer(_to, balance), ERROR_RECOVER_TOKEN_FUNDS_FAILED);\n        emit RecoverFunds(_token, _to, balance);\n    }\n}\n"
    },
    "contracts/lib/os/SafeERC20.sol": {
      "content": "// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/SafeERC20.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\nimport \"./ERC20.sol\";\n\n\nlibrary SafeERC20 {\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\n    // https://github.com/ethereum/solidity/issues/3544\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            TRANSFER_SELECTOR,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), transferCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), transferFromCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), approveCallData);\n    }\n\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata) private returns (bool) {\n        bool ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            let success := call(\n                gas,                  // forward all gas\n                _addr,                // address\n                0,                    // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n            // Check number of bytes returned from last function call\n                switch returndatasize\n\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                // Only return success if returned data was true\n                // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n\n                // Not sure what was returned: don't mark as success\n                default { }\n            }\n        }\n        return ret;\n    }\n}\n"
    },
    "contracts/disputes/DisputeManager.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../lib/os/ERC20.sol\";\nimport \"../lib/os/SafeERC20.sol\";\nimport \"../lib/os/SafeMath.sol\";\nimport \"../lib/os/SafeMath64.sol\";\nimport \"../lib/os/Uint256Helpers.sol\";\n\nimport \"./IDisputeManager.sol\";\nimport \"../lib/PctHelpers.sol\";\nimport \"../voting/ICRVoting.sol\";\nimport \"../voting/ICRVotingOwner.sol\";\nimport \"../treasury/ITreasury.sol\";\nimport \"../arbitration/IArbitrable.sol\";\nimport \"../registry/IJurorsRegistry.sol\";\nimport \"../subscriptions/ISubscriptions.sol\";\nimport \"../court/controller/ControlledRecoverable.sol\";\n\n\ncontract DisputeManager is ControlledRecoverable, ICRVotingOwner, IDisputeManager {\n    using SafeERC20 for ERC20;\n    using SafeMath for uint256;\n    using SafeMath64 for uint64;\n    using PctHelpers for uint256;\n    using Uint256Helpers for uint256;\n\n    // Voting-related error messages\n    string private constant ERROR_VOTER_WEIGHT_ZERO = \"DM_VOTER_WEIGHT_ZERO\";\n    string private constant ERROR_SENDER_NOT_VOTING = \"DM_SENDER_NOT_VOTING\";\n\n    // Disputes-related error messages\n    string private constant ERROR_SENDER_NOT_DISPUTE_SUBJECT = \"DM_SENDER_NOT_DISPUTE_SUBJECT\";\n    string private constant ERROR_EVIDENCE_PERIOD_IS_CLOSED = \"DM_EVIDENCE_PERIOD_IS_CLOSED\";\n    string private constant ERROR_TERM_OUTDATED = \"DM_TERM_OUTDATED\";\n    string private constant ERROR_DISPUTE_DOES_NOT_EXIST = \"DM_DISPUTE_DOES_NOT_EXIST\";\n    string private constant ERROR_INVALID_RULING_OPTIONS = \"DM_INVALID_RULING_OPTIONS\";\n    string private constant ERROR_SUBSCRIPTION_NOT_PAID = \"DM_SUBSCRIPTION_NOT_PAID\";\n    string private constant ERROR_DEPOSIT_FAILED = \"DM_DEPOSIT_FAILED\";\n    string private constant ERROR_BAD_MAX_DRAFT_BATCH_SIZE = \"DM_BAD_MAX_DRAFT_BATCH_SIZE\";\n\n    // Rounds-related error messages\n    string private constant ERROR_ROUND_IS_FINAL = \"DM_ROUND_IS_FINAL\";\n    string private constant ERROR_ROUND_DOES_NOT_EXIST = \"DM_ROUND_DOES_NOT_EXIST\";\n    string private constant ERROR_INVALID_ADJUDICATION_STATE = \"DM_INVALID_ADJUDICATION_STATE\";\n    string private constant ERROR_ROUND_ALREADY_DRAFTED = \"DM_ROUND_ALREADY_DRAFTED\";\n    string private constant ERROR_DRAFT_TERM_NOT_REACHED = \"DM_DRAFT_TERM_NOT_REACHED\";\n    string private constant ERROR_ROUND_NOT_APPEALED = \"DM_ROUND_NOT_APPEALED\";\n    string private constant ERROR_INVALID_APPEAL_RULING = \"DM_INVALID_APPEAL_RULING\";\n\n    // Settlements-related error messages\n    string private constant ERROR_PREV_ROUND_NOT_SETTLED = \"DM_PREVIOUS_ROUND_NOT_SETTLED\";\n    string private constant ERROR_ROUND_ALREADY_SETTLED = \"DM_ROUND_ALREADY_SETTLED\";\n    string private constant ERROR_ROUND_NOT_SETTLED = \"DM_ROUND_PENALTIES_NOT_SETTLED\";\n    string private constant ERROR_JUROR_ALREADY_REWARDED = \"DM_JUROR_ALREADY_REWARDED\";\n    string private constant ERROR_WONT_REWARD_NON_VOTER_JUROR = \"DM_WONT_REWARD_NON_VOTER_JUROR\";\n    string private constant ERROR_WONT_REWARD_INCOHERENT_JUROR = \"DM_WONT_REWARD_INCOHERENT_JUROR\";\n    string private constant ERROR_ROUND_APPEAL_ALREADY_SETTLED = \"DM_APPEAL_ALREADY_SETTLED\";\n\n    // Minimum possible rulings for a dispute\n    uint8 internal constant MIN_RULING_OPTIONS = 2;\n\n    // Maximum possible rulings for a dispute, equal to minimum limit\n    uint8 internal constant MAX_RULING_OPTIONS = MIN_RULING_OPTIONS;\n\n    // Precision factor used to improve rounding when computing weights for the final round\n    uint256 internal constant FINAL_ROUND_WEIGHT_PRECISION = 1000;\n\n    // Mask used to decode vote IDs\n    uint256 internal constant VOTE_ID_MASK = 0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n    struct Dispute {\n        IArbitrable subject;           // Arbitrable associated to a dispute\n        uint64 createTermId;           // Term ID when the dispute was created\n        uint8 possibleRulings;         // Number of possible rulings jurors can vote for each dispute\n        uint8 finalRuling;             // Winning ruling of a dispute\n        DisputeState state;            // State of a dispute: pre-draft, adjudicating, or ruled\n        AdjudicationRound[] rounds;    // List of rounds for each dispute\n    }\n\n    struct AdjudicationRound {\n        uint64 draftTermId;            // Term from which the jurors of a round can be drafted\n        uint64 jurorsNumber;           // Number of jurors drafted for a round\n        bool settledPenalties;         // Whether or not penalties have been settled for a round\n        uint256 jurorFees;             // Total amount of fees to be distributed between the winning jurors of a round\n        address[] jurors;              // List of jurors drafted for a round\n        mapping (address => JurorState) jurorsStates; // List of states for each drafted juror indexed by address\n        uint64 delayedTerms;           // Number of terms a round was delayed based on its requested draft term id\n        uint64 selectedJurors;         // Number of jurors selected for a round, to allow drafts to be batched\n        uint64 coherentJurors;         // Number of drafted jurors that voted in favor of the dispute final ruling\n        uint64 settledJurors;          // Number of jurors whose rewards were already settled\n        uint256 collectedTokens;       // Total amount of tokens collected from losing jurors\n        Appeal appeal;                 // Appeal-related information of a round\n    }\n\n    struct JurorState {\n        uint64 weight;                 // Weight computed for a juror on a round\n        bool rewarded;                 // Whether or not a drafted juror was rewarded\n    }\n\n    struct Appeal {\n        address maker;                 // Address of the appealer\n        uint8 appealedRuling;          // Ruling appealing in favor of\n        address taker;                 // Address of the one confirming an appeal\n        uint8 opposedRuling;           // Ruling opposed to an appeal\n        bool settled;                  // Whether or not an appeal has been settled\n    }\n\n    struct DraftParams {\n        uint256 disputeId;            // Identification number of the dispute to be drafted\n        uint256 roundId;              // Identification number of the round to be drafted\n        uint64 termId;                // Identification number of the current term of the Court\n        bytes32 draftTermRandomness;  // Randomness of the term in which the dispute was requested to be drafted\n        DraftConfig config;           // Draft config of the Court at the draft term\n    }\n\n    struct NextRoundDetails {\n        uint64 startTerm;              // Term ID from which the next round will start\n        uint64 jurorsNumber;           // Jurors number for the next round\n        DisputeState newDisputeState;  // New state for the dispute associated to the given round after the appeal\n        ERC20 feeToken;                // ERC20 token used for the next round fees\n        uint256 totalFees;             // Total amount of fees to be distributed between the winning jurors of the next round\n        uint256 jurorFees;             // Total amount of fees for a regular round at the given term\n        uint256 appealDeposit;         // Amount to be deposit of fees for a regular round at the given term\n        uint256 confirmAppealDeposit;  // Total amount of fees for a regular round at the given term\n    }\n\n    // Max jurors to be drafted in each batch. To prevent running out of gas. We allow to change it because max gas per tx can vary\n    // As a reference, drafting 100 jurors from a small tree of 4 would cost ~2.4M. Drafting 500, ~7.75M.\n    uint64 public maxJurorsPerDraftBatch;\n\n    // List of all the disputes created in the Court\n    Dispute[] internal disputes;\n\n    event DisputeStateChanged(uint256 indexed disputeId, DisputeState indexed state);\n    event EvidencePeriodClosed(uint256 indexed disputeId, uint64 indexed termId);\n    event NewDispute(uint256 indexed disputeId, IArbitrable indexed subject, uint64 indexed draftTermId, uint64 jurorsNumber, bytes metadata);\n    event JurorDrafted(uint256 indexed disputeId, uint256 indexed roundId, address indexed juror);\n    event RulingAppealed(uint256 indexed disputeId, uint256 indexed roundId, uint8 ruling);\n    event RulingAppealConfirmed(uint256 indexed disputeId, uint256 indexed roundId, uint64 indexed draftTermId, uint256 jurorsNumber);\n    event RulingComputed(uint256 indexed disputeId, uint8 indexed ruling);\n    event PenaltiesSettled(uint256 indexed disputeId, uint256 indexed roundId, uint256 collectedTokens);\n    event RewardSettled(uint256 indexed disputeId, uint256 indexed roundId, address juror, uint256 tokens, uint256 fees);\n    event AppealDepositSettled(uint256 indexed disputeId, uint256 indexed roundId);\n    event MaxJurorsPerDraftBatchChanged(uint64 previousMaxJurorsPerDraftBatch, uint64 currentMaxJurorsPerDraftBatch);\n\n    /**\n    * @dev Ensure the msg.sender is the CR Voting module\n    */\n    modifier onlyVoting() {\n        ICRVoting voting = _voting();\n        require(msg.sender == address(voting), ERROR_SENDER_NOT_VOTING);\n        _;\n    }\n\n    /**\n    * @dev Ensure a dispute exists\n    * @param _disputeId Identification number of the dispute to be ensured\n    */\n    modifier disputeExists(uint256 _disputeId) {\n        _checkDisputeExists(_disputeId);\n        _;\n    }\n\n    /**\n    * @dev Ensure a dispute round exists\n    * @param _disputeId Identification number of the dispute to be ensured\n    * @param _roundId Identification number of the dispute round to be ensured\n    */\n    modifier roundExists(uint256 _disputeId, uint256 _roundId) {\n        _checkRoundExists(_disputeId, _roundId);\n        _;\n    }\n\n    /**\n    * @dev Constructor function\n    * @param _controller Address of the controller\n    * @param _maxJurorsPerDraftBatch Max number of jurors to be drafted per batch\n    * @param _skippedDisputes Number of disputes to be skipped\n    */\n    constructor(Controller _controller, uint64 _maxJurorsPerDraftBatch, uint256 _skippedDisputes) ControlledRecoverable(_controller) public {\n        // No need to explicitly call `Controlled` constructor since `ControlledRecoverable` is already doing it\n        _setMaxJurorsPerDraftBatch(_maxJurorsPerDraftBatch);\n        _skipDisputes(_skippedDisputes);\n    }\n\n    /**\n    * @notice Create a dispute over `_subject` with `_possibleRulings` possible rulings\n    * @param _subject Arbitrable instance creating the dispute\n    * @param _possibleRulings Number of possible rulings allowed for the drafted jurors to vote on the dispute\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\n    * @return Dispute identification number\n    */\n    function createDispute(IArbitrable _subject, uint8 _possibleRulings, bytes calldata _metadata) external onlyController returns (uint256) {\n        uint64 termId = _ensureCurrentTerm();\n        require(_possibleRulings >= MIN_RULING_OPTIONS && _possibleRulings <= MAX_RULING_OPTIONS, ERROR_INVALID_RULING_OPTIONS);\n\n        // Create the dispute\n        uint256 disputeId = disputes.length++;\n        Dispute storage dispute = disputes[disputeId];\n        dispute.subject = _subject;\n        dispute.possibleRulings = _possibleRulings;\n        dispute.createTermId = termId;\n\n        Config memory config = _getConfigAt(termId);\n        uint64 jurorsNumber = config.disputes.firstRoundJurorsNumber;\n        uint64 draftTermId = termId.add(config.disputes.evidenceTerms);\n        emit NewDispute(disputeId, _subject, draftTermId, jurorsNumber, _metadata);\n\n        // Create first adjudication round of the dispute\n        (ERC20 feeToken, uint256 jurorFees, uint256 totalFees) = _getRegularRoundFees(config.fees, jurorsNumber);\n        _createRound(disputeId, DisputeState.PreDraft, draftTermId, jurorsNumber, jurorFees);\n\n        // Pay round fees and return dispute id\n        _depositAmount(address(_subject), feeToken, totalFees);\n        return disputeId;\n    }\n\n    /**\n    * @notice Close the evidence period of dispute #`_disputeId`\n    * @param _subject IArbitrable instance requesting to close the evidence submission period\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\n    */\n    function closeEvidencePeriod(IArbitrable _subject, uint256 _disputeId) external onlyController roundExists(_disputeId, 0) {\n        Dispute storage dispute = disputes[_disputeId];\n        AdjudicationRound storage round = dispute.rounds[0];\n        require(dispute.subject == _subject, ERROR_SENDER_NOT_DISPUTE_SUBJECT);\n\n        // Check current term is within the evidence submission period\n        uint64 termId = _ensureCurrentTerm();\n        uint64 newDraftTermId = termId.add(1);\n        require(newDraftTermId < round.draftTermId, ERROR_EVIDENCE_PERIOD_IS_CLOSED);\n\n        // Update the draft term of the first round to the next term\n        round.draftTermId = newDraftTermId;\n        emit EvidencePeriodClosed(_disputeId, termId);\n    }\n\n    /**\n    * @notice Draft jurors for the next round of dispute #`_disputeId`\n    * @param _disputeId Identification number of the dispute to be drafted\n    */\n    function draft(uint256 _disputeId) external disputeExists(_disputeId) {\n        // Drafts can only be computed when the Court is up-to-date. Note that forcing a term transition won't work since the term randomness\n        // is always based on the next term which means it won't be available anyway.\n        IClock clock = _clock();\n        uint64 requiredTransitions = _clock().getNeededTermTransitions();\n        require(uint256(requiredTransitions) == 0, ERROR_TERM_OUTDATED);\n        uint64 currentTermId = _getLastEnsuredTermId();\n\n        // Ensure dispute has not been drafted yet\n        Dispute storage dispute = disputes[_disputeId];\n        require(dispute.state == DisputeState.PreDraft, ERROR_ROUND_ALREADY_DRAFTED);\n\n        // Ensure draft term randomness can be computed for the current block number\n        uint256 roundId = dispute.rounds.length - 1;\n        AdjudicationRound storage round = dispute.rounds[roundId];\n        uint64 draftTermId = round.draftTermId;\n        require(draftTermId <= currentTermId, ERROR_DRAFT_TERM_NOT_REACHED);\n        bytes32 draftTermRandomness = clock.ensureCurrentTermRandomness();\n\n        // Draft jurors for the given dispute and reimburse fees\n        DraftConfig memory config = _getDraftConfig(draftTermId);\n        bool draftEnded = _draft(round, _buildDraftParams(_disputeId, roundId, currentTermId, draftTermRandomness, config));\n\n        // If the drafting is over, update its state\n        if (draftEnded) {\n            // No need for SafeMath: we ensured `currentTermId` is greater than or equal to `draftTermId` above\n            round.delayedTerms = currentTermId - draftTermId;\n            dispute.state = DisputeState.Adjudicating;\n            emit DisputeStateChanged(_disputeId, DisputeState.Adjudicating);\n        }\n    }\n\n    /**\n    * @notice Appeal round #`_roundId` of dispute #`_disputeId` in favor of ruling `_ruling`\n    * @param _disputeId Identification number of the dispute being appealed\n    * @param _roundId Identification number of the dispute round being appealed\n    * @param _ruling Ruling appealing a dispute round in favor of\n    */\n    function createAppeal(uint256 _disputeId, uint256 _roundId, uint8 _ruling) external roundExists(_disputeId, _roundId) {\n        // Ensure current term and check that the given round can be appealed.\n        // Note that if there was a final appeal the adjudication state will be 'Ended'.\n        Dispute storage dispute = disputes[_disputeId];\n        Config memory config = _getDisputeConfig(dispute);\n        _ensureAdjudicationState(dispute, _roundId, AdjudicationState.Appealing, config.disputes);\n\n        // Ensure that the ruling being appealed in favor of is valid and different from the current winning ruling\n        ICRVoting voting = _voting();\n        uint256 voteId = _getVoteId(_disputeId, _roundId);\n        uint8 roundWinningRuling = voting.getWinningOutcome(voteId);\n        require(roundWinningRuling != _ruling && voting.isValidOutcome(voteId, _ruling), ERROR_INVALID_APPEAL_RULING);\n\n        // Update round appeal state\n        AdjudicationRound storage round = dispute.rounds[_roundId];\n        Appeal storage appeal = round.appeal;\n        appeal.maker = msg.sender;\n        appeal.appealedRuling = _ruling;\n        emit RulingAppealed(_disputeId, _roundId, _ruling);\n\n        // Pay appeal deposit\n        NextRoundDetails memory nextRound = _getNextRoundDetails(round, _roundId, config);\n        _depositAmount(msg.sender, nextRound.feeToken, nextRound.appealDeposit);\n    }\n\n    /**\n    * @notice Confirm appeal for round #`_roundId` of dispute #`_disputeId` in favor of ruling `_ruling`\n    * @param _disputeId Identification number of the dispute confirming an appeal of\n    * @param _roundId Identification number of the dispute round confirming an appeal of\n    * @param _ruling Ruling being confirmed against a dispute round appeal\n    */\n    function confirmAppeal(uint256 _disputeId, uint256 _roundId, uint8 _ruling) external roundExists(_disputeId, _roundId) {\n        // Ensure current term and check that the given round is appealed and can be confirmed.\n        // Note that if there was a final appeal the adjudication state will be 'Ended'.\n        Dispute storage dispute = disputes[_disputeId];\n        Config memory config = _getDisputeConfig(dispute);\n        _ensureAdjudicationState(dispute, _roundId, AdjudicationState.ConfirmingAppeal, config.disputes);\n\n        // Ensure that the ruling being confirmed in favor of is valid and different from the appealed ruling\n        AdjudicationRound storage round = dispute.rounds[_roundId];\n        Appeal storage appeal = round.appeal;\n        uint256 voteId = _getVoteId(_disputeId, _roundId);\n        require(appeal.appealedRuling != _ruling && _voting().isValidOutcome(voteId, _ruling), ERROR_INVALID_APPEAL_RULING);\n\n        // Create a new adjudication round for the dispute\n        NextRoundDetails memory nextRound = _getNextRoundDetails(round, _roundId, config);\n        DisputeState newDisputeState = nextRound.newDisputeState;\n        uint256 newRoundId = _createRound(_disputeId, newDisputeState, nextRound.startTerm, nextRound.jurorsNumber, nextRound.jurorFees);\n\n        // Update previous round appeal state\n        appeal.taker = msg.sender;\n        appeal.opposedRuling = _ruling;\n        emit RulingAppealConfirmed(_disputeId, newRoundId, nextRound.startTerm, nextRound.jurorsNumber);\n\n        // Pay appeal confirm deposit\n        _depositAmount(msg.sender, nextRound.feeToken, nextRound.confirmAppealDeposit);\n    }\n\n    /**\n    * @notice Compute the final ruling for dispute #`_disputeId`\n    * @param _disputeId Identification number of the dispute to compute its final ruling\n    * @return subject Arbitrable instance associated to the dispute\n    * @return finalRuling Final ruling decided for the given dispute\n    */\n    function computeRuling(uint256 _disputeId) external disputeExists(_disputeId) returns (IArbitrable subject, uint8 finalRuling) {\n        Dispute storage dispute = disputes[_disputeId];\n        subject = dispute.subject;\n\n        Config memory config = _getDisputeConfig(dispute);\n        finalRuling = _ensureFinalRuling(dispute, _disputeId, config);\n\n        if (dispute.state != DisputeState.Ruled) {\n            dispute.state = DisputeState.Ruled;\n            emit RulingComputed(_disputeId, finalRuling);\n        }\n    }\n\n    /**\n    * @notice Settle penalties for round #`_roundId` of dispute #`_disputeId`\n    * @dev In case of a regular round, all the drafted jurors that didn't vote in favor of the final ruling of the given dispute will be slashed.\n    *      In case of a final round, jurors are slashed when voting, thus it is considered these rounds settled at once. Rewards have to be\n    *      manually claimed through `settleReward` which will return pre-slashed tokens for the winning jurors of a final round as well.\n    * @param _disputeId Identification number of the dispute to settle penalties for\n    * @param _roundId Identification number of the dispute round to settle penalties for\n    * @param _jurorsToSettle Maximum number of jurors to be slashed in this call. It can be set to zero to slash all the losing jurors of the\n    *        given round. This argument is only used when settling regular rounds.\n    */\n    function settlePenalties(uint256 _disputeId, uint256 _roundId, uint256 _jurorsToSettle) external roundExists(_disputeId, _roundId) {\n        // Enforce that rounds are settled in order to avoid one round without incentive to settle. Even if there is a settle fee\n        // it may not be big enough and all jurors in the round could be slashed.\n        Dispute storage dispute = disputes[_disputeId];\n        require(_roundId == 0 || dispute.rounds[_roundId - 1].settledPenalties, ERROR_PREV_ROUND_NOT_SETTLED);\n\n        // Ensure given round has not been fully settled yet\n        AdjudicationRound storage round = dispute.rounds[_roundId];\n        require(!round.settledPenalties, ERROR_ROUND_ALREADY_SETTLED);\n\n        // Ensure the final ruling of the given dispute is already computed\n        Config memory config = _getDisputeConfig(dispute);\n        uint8 finalRuling = _ensureFinalRuling(dispute, _disputeId, config);\n\n        // Set the number of jurors that voted in favor of the final ruling if we haven't started settling yet\n        uint256 voteId = _getVoteId(_disputeId, _roundId);\n        if (round.settledJurors == 0) {\n            // Note that we are safe to cast the tally of a ruling to uint64 since the highest value a ruling can have is equal to the jurors\n            // number for regular rounds or to the total active balance of the registry for final rounds, and both are ensured to fit in uint64.\n            ICRVoting voting = _voting();\n            round.coherentJurors = uint64(voting.getOutcomeTally(voteId, finalRuling));\n        }\n\n        ITreasury treasury = _treasury();\n        ERC20 feeToken = config.fees.token;\n        if (_isRegularRound(_roundId, config)) {\n            // For regular appeal rounds we compute the amount of locked tokens that needs to get burned in batches.\n            // The callers of this function will get rewarded in this case.\n            uint256 jurorsSettled = _settleRegularRoundPenalties(round, voteId, finalRuling, config.disputes.penaltyPct, _jurorsToSettle, config.minActiveBalance);\n            treasury.assign(feeToken, msg.sender, config.fees.settleFee.mul(jurorsSettled));\n        } else {\n            // For the final appeal round, there is no need to settle in batches since, to guarantee scalability,\n            // all the tokens are collected from jurors when they vote, and those jurors who\n            // voted in favor of the winning ruling can claim their collected tokens back along with their reward.\n            // Note that the caller of this function is not being reimbursed.\n            round.settledPenalties = true;\n        }\n\n        if (round.settledPenalties) {\n            uint256 collectedTokens = round.collectedTokens;\n            emit PenaltiesSettled(_disputeId, _roundId, collectedTokens);\n            _burnCollectedTokensIfNecessary(dispute, round, _roundId, treasury, feeToken, collectedTokens);\n        }\n    }\n\n    /**\n    * @notice Claim reward for round #`_roundId` of dispute #`_disputeId` for juror `_juror`\n    * @dev For regular rounds, it will only reward winning jurors\n    * @param _disputeId Identification number of the dispute to settle rewards for\n    * @param _roundId Identification number of the dispute round to settle rewards for\n    * @param _juror Address of the juror to settle their rewards\n    */\n    function settleReward(uint256 _disputeId, uint256 _roundId, address _juror) external roundExists(_disputeId, _roundId) {\n        // Ensure dispute round penalties are settled first\n        Dispute storage dispute = disputes[_disputeId];\n        AdjudicationRound storage round = dispute.rounds[_roundId];\n        require(round.settledPenalties, ERROR_ROUND_NOT_SETTLED);\n\n        // Ensure given juror was not rewarded yet and was drafted for the given round\n        JurorState storage jurorState = round.jurorsStates[_juror];\n        require(!jurorState.rewarded, ERROR_JUROR_ALREADY_REWARDED);\n        require(uint256(jurorState.weight) > 0, ERROR_WONT_REWARD_NON_VOTER_JUROR);\n        jurorState.rewarded = true;\n\n        // Check if the given juror has voted in favor of the final ruling of the dispute in this round\n        ICRVoting voting = _voting();\n        uint256 voteId = _getVoteId(_disputeId, _roundId);\n        require(voting.hasVotedInFavorOf(voteId, dispute.finalRuling, _juror), ERROR_WONT_REWARD_INCOHERENT_JUROR);\n\n        uint256 collectedTokens = round.collectedTokens;\n        IJurorsRegistry jurorsRegistry = _jurorsRegistry();\n\n        // Distribute the collected tokens of the jurors that were slashed weighted by the winning jurors. Note that we are penalizing jurors\n        // that refused intentionally their vote for the final round.\n        uint256 rewardTokens;\n        if (collectedTokens > 0) {\n            // Note that the number of coherent jurors has to be greater than zero since we already ensured the juror has voted in favor of the\n            // final ruling, therefore there will be at least one coherent juror and divisions below are safe.\n            rewardTokens = _getRoundWeightedAmount(round, jurorState, collectedTokens);\n            jurorsRegistry.assignTokens(_juror, rewardTokens);\n        }\n\n        // Reward the winning juror with fees\n        Config memory config = _getDisputeConfig(dispute);\n        // Note that the number of coherent jurors has to be greater than zero since we already ensured the juror has voted in favor of the\n        // final ruling, therefore there will be at least one coherent juror and divisions below are safe.\n        uint256 rewardFees = _getRoundWeightedAmount(round, jurorState, round.jurorFees);\n        _treasury().assign(config.fees.token, _juror, rewardFees);\n\n        // Set the lock for final round\n        if (!_isRegularRound(_roundId, config)) {\n            // Round end term ID (as it's final there's no draft delay nor appeal) plus the lock period\n            DisputesConfig memory disputesConfig = config.disputes;\n            jurorsRegistry.lockWithdrawals(\n                _juror,\n                round.draftTermId + disputesConfig.commitTerms + disputesConfig.revealTerms + disputesConfig.finalRoundLockTerms\n            );\n        }\n\n        emit RewardSettled(_disputeId, _roundId, _juror, rewardTokens, rewardFees);\n    }\n\n    /**\n    * @notice Settle appeal deposits for round #`_roundId` of dispute #`_disputeId`\n    * @param _disputeId Identification number of the dispute to settle appeal deposits for\n    * @param _roundId Identification number of the dispute round to settle appeal deposits for\n    */\n    function settleAppealDeposit(uint256 _disputeId, uint256 _roundId) external roundExists(_disputeId, _roundId) {\n        // Ensure dispute round penalties are settled first\n        Dispute storage dispute = disputes[_disputeId];\n        AdjudicationRound storage round = dispute.rounds[_roundId];\n        require(round.settledPenalties, ERROR_ROUND_NOT_SETTLED);\n\n        // Ensure given round was appealed and has not been settled yet\n        Appeal storage appeal = round.appeal;\n        require(_existsAppeal(appeal), ERROR_ROUND_NOT_APPEALED);\n        require(!appeal.settled, ERROR_ROUND_APPEAL_ALREADY_SETTLED);\n        appeal.settled = true;\n        emit AppealDepositSettled(_disputeId, _roundId);\n\n        // Load next round details\n        Config memory config = _getDisputeConfig(dispute);\n        NextRoundDetails memory nextRound = _getNextRoundDetails(round, _roundId, config);\n        ERC20 feeToken = nextRound.feeToken;\n        uint256 totalFees = nextRound.totalFees;\n        uint256 appealDeposit = nextRound.appealDeposit;\n        uint256 confirmAppealDeposit = nextRound.confirmAppealDeposit;\n\n        // If the appeal wasn't confirmed, return the entire deposit to appeal maker\n        ITreasury treasury = _treasury();\n        if (!_isAppealConfirmed(appeal)) {\n            treasury.assign(feeToken, appeal.maker, appealDeposit);\n            return;\n        }\n\n        // If the appeal was confirmed and there is a winner, we transfer the total deposit to that party. Otherwise, if the final ruling wasn't\n        // selected by any of the appealing parties or no juror voted in the in favor of the possible outcomes, we split it between both parties.\n        // Note that we are safe to access the dispute final ruling, since we already ensured that round penalties were settled.\n        uint8 finalRuling = dispute.finalRuling;\n        uint256 totalDeposit = appealDeposit.add(confirmAppealDeposit);\n        if (appeal.appealedRuling == finalRuling) {\n            treasury.assign(feeToken, appeal.maker, totalDeposit.sub(totalFees));\n        } else if (appeal.opposedRuling == finalRuling) {\n            treasury.assign(feeToken, appeal.taker, totalDeposit.sub(totalFees));\n        } else {\n            uint256 feesRefund = totalFees / 2;\n            treasury.assign(feeToken, appeal.maker, appealDeposit.sub(feesRefund));\n            treasury.assign(feeToken, appeal.taker, confirmAppealDeposit.sub(feesRefund));\n        }\n    }\n\n    /**\n    * @notice Ensure votes can be committed for vote #`_voteId`, revert otherwise\n    * @dev This function will ensure the current term of the Court and revert in case votes cannot still be committed\n    * @param _voteId ID of the vote instance to request the weight of a voter for\n    */\n    function ensureCanCommit(uint256 _voteId) external {\n        (Dispute storage dispute, uint256 roundId) = _decodeVoteId(_voteId);\n        Config memory config = _getDisputeConfig(dispute);\n\n        // Ensure current term and check that votes can still be committed for the given round\n        _ensureAdjudicationState(dispute, roundId, AdjudicationState.Committing, config.disputes);\n    }\n\n    /**\n    * @notice Ensure `voter` can commit votes for vote #`_voteId`, revert otherwise\n    * @dev This function will ensure the current term of the Court and revert in case the given voter is not allowed to commit votes\n    * @param _voteId ID of the vote instance to request the weight of a voter for\n    * @param _voter Address of the voter querying the weight of\n    */\n    function ensureCanCommit(uint256 _voteId, address _voter) external onlyVoting {\n        (Dispute storage dispute, uint256 roundId) = _decodeVoteId(_voteId);\n        Config memory config = _getDisputeConfig(dispute);\n\n        // Ensure current term and check that votes can still be committed for the given round\n        _ensureAdjudicationState(dispute, roundId, AdjudicationState.Committing, config.disputes);\n        uint64 weight = _computeJurorWeight(dispute, roundId, _voter, config);\n        require(weight > 0, ERROR_VOTER_WEIGHT_ZERO);\n    }\n\n    /**\n    * @notice Ensure `voter` can reveal votes for vote #`_voteId`, revert otherwise\n    * @dev This function will ensure the current term of the Court and revert in case votes cannot still be revealed\n    * @param _voteId ID of the vote instance to request the weight of a voter for\n    * @param _voter Address of the voter querying the weight of\n    * @return Weight of the requested juror for the requested dispute's round\n    */\n    function ensureCanReveal(uint256 _voteId, address _voter) external returns (uint64) {\n        (Dispute storage dispute, uint256 roundId) = _decodeVoteId(_voteId);\n        Config memory config = _getDisputeConfig(dispute);\n\n        // Ensure current term and check that votes can still be revealed for the given round\n        _ensureAdjudicationState(dispute, roundId, AdjudicationState.Revealing, config.disputes);\n        AdjudicationRound storage round = dispute.rounds[roundId];\n        return _getJurorWeight(round, _voter);\n    }\n\n    /**\n    * @notice Sets the global configuration for the max number of jurors to be drafted per batch to `_maxJurorsPerDraftBatch`\n    * @param _maxJurorsPerDraftBatch Max number of jurors to be drafted per batch\n    */\n    function setMaxJurorsPerDraftBatch(uint64 _maxJurorsPerDraftBatch) external onlyConfigGovernor {\n        _setMaxJurorsPerDraftBatch(_maxJurorsPerDraftBatch);\n    }\n\n    /**\n    * @dev Tell the amount of token fees required to create a dispute\n    * @return feeToken ERC20 token used for the fees\n    * @return totalFees Total amount of fees for a regular round at the given term\n    */\n    function getDisputeFees() external view returns (ERC20 feeToken, uint256 totalFees) {\n        uint64 currentTermId = _getCurrentTermId();\n        Config memory config = _getConfigAt(currentTermId);\n        (feeToken,, totalFees) = _getRegularRoundFees(config.fees, config.disputes.firstRoundJurorsNumber);\n    }\n\n    /**\n    * @dev Tell information of a certain dispute\n    * @param _disputeId Identification number of the dispute being queried\n    * @return subject Arbitrable subject being disputed\n    * @return possibleRulings Number of possible rulings allowed for the drafted jurors to vote on the dispute\n    * @return state Current state of the dispute being queried: pre-draft, adjudicating, or ruled\n    * @return finalRuling The winning ruling in case the dispute is finished\n    * @return lastRoundId Identification number of the last round created for the dispute\n    * @return createTermId Identification number of the term when the dispute was created\n    */\n    function getDispute(uint256 _disputeId) external view disputeExists(_disputeId)\n        returns (IArbitrable subject, uint8 possibleRulings, DisputeState state, uint8 finalRuling, uint256 lastRoundId, uint64 createTermId)\n    {\n        Dispute storage dispute = disputes[_disputeId];\n\n        subject = dispute.subject;\n        possibleRulings = dispute.possibleRulings;\n        state = dispute.state;\n        finalRuling = dispute.finalRuling;\n        createTermId = dispute.createTermId;\n        // If a dispute exists, it has at least one round\n        lastRoundId = dispute.rounds.length - 1;\n    }\n\n    /**\n    * @dev Tell information of a certain adjudication round\n    * @param _disputeId Identification number of the dispute being queried\n    * @param _roundId Identification number of the round being queried\n    * @return draftTerm Term from which the requested round can be drafted\n    * @return delayedTerms Number of terms the given round was delayed based on its requested draft term id\n    * @return jurorsNumber Number of jurors requested for the round\n    * @return selectedJurors Number of jurors already selected for the requested round\n    * @return settledPenalties Whether or not penalties have been settled for the requested round\n    * @return collectedTokens Amount of juror tokens that were collected from slashed jurors for the requested round\n    * @return coherentJurors Number of jurors that voted in favor of the final ruling in the requested round\n    * @return state Adjudication state of the requested round\n    */\n    function getRound(uint256 _disputeId, uint256 _roundId) external view roundExists(_disputeId, _roundId)\n        returns (\n            uint64 draftTerm,\n            uint64 delayedTerms,\n            uint64 jurorsNumber,\n            uint64 selectedJurors,\n            uint256 jurorFees,\n            bool settledPenalties,\n            uint256 collectedTokens,\n            uint64 coherentJurors,\n            AdjudicationState state\n        )\n    {\n        Dispute storage dispute = disputes[_disputeId];\n        state = _adjudicationStateAt(dispute, _roundId, _getCurrentTermId(), _getDisputeConfig(dispute).disputes);\n\n        AdjudicationRound storage round = dispute.rounds[_roundId];\n        draftTerm = round.draftTermId;\n        delayedTerms = round.delayedTerms;\n        jurorsNumber = round.jurorsNumber;\n        selectedJurors = round.selectedJurors;\n        jurorFees = round.jurorFees;\n        settledPenalties = round.settledPenalties;\n        coherentJurors = round.coherentJurors;\n        collectedTokens = round.collectedTokens;\n    }\n\n    /**\n    * @dev Tell appeal-related information of a certain adjudication round\n    * @param _disputeId Identification number of the dispute being queried\n    * @param _roundId Identification number of the round being queried\n    * @return maker Address of the account appealing the given round\n    * @return appealedRuling Ruling confirmed by the appealer of the given round\n    * @return taker Address of the account confirming the appeal of the given round\n    * @return opposedRuling Ruling confirmed by the appeal taker of the given round\n    */\n    function getAppeal(uint256 _disputeId, uint256 _roundId) external view roundExists(_disputeId, _roundId)\n        returns (address maker, uint64 appealedRuling, address taker, uint64 opposedRuling)\n    {\n        Appeal storage appeal = disputes[_disputeId].rounds[_roundId].appeal;\n\n        maker = appeal.maker;\n        appealedRuling = appeal.appealedRuling;\n        taker = appeal.taker;\n        opposedRuling = appeal.opposedRuling;\n    }\n\n    /**\n    * @dev Tell information related to the next round due to an appeal of a certain round given.\n    * @param _disputeId Identification number of the dispute being queried\n    * @param _roundId Identification number of the round requesting the appeal details of\n    * @return nextRoundStartTerm Term ID from which the next round will start\n    * @return nextRoundJurorsNumber Jurors number for the next round\n    * @return newDisputeState New state for the dispute associated to the given round after the appeal\n    * @return feeToken ERC20 token used for the next round fees\n    * @return jurorFees Total amount of fees to be distributed between the winning jurors of the next round\n    * @return totalFees Total amount of fees for a regular round at the given term\n    * @return appealDeposit Amount to be deposit of fees for a regular round at the given term\n    * @return confirmAppealDeposit Total amount of fees for a regular round at the given term\n    */\n    function getNextRoundDetails(uint256 _disputeId, uint256 _roundId) external view\n        returns (\n            uint64 nextRoundStartTerm,\n            uint64 nextRoundJurorsNumber,\n            DisputeState newDisputeState,\n            ERC20 feeToken,\n            uint256 totalFees,\n            uint256 jurorFees,\n            uint256 appealDeposit,\n            uint256 confirmAppealDeposit\n        )\n    {\n        _checkRoundExists(_disputeId, _roundId);\n\n        Dispute storage dispute = disputes[_disputeId];\n        Config memory config = _getDisputeConfig(dispute);\n        require(_isRegularRound(_roundId, config), ERROR_ROUND_IS_FINAL);\n\n        AdjudicationRound storage round = dispute.rounds[_roundId];\n        NextRoundDetails memory nextRound = _getNextRoundDetails(round, _roundId, config);\n        return (\n            nextRound.startTerm,\n            nextRound.jurorsNumber,\n            nextRound.newDisputeState,\n            nextRound.feeToken,\n            nextRound.totalFees,\n            nextRound.jurorFees,\n            nextRound.appealDeposit,\n            nextRound.confirmAppealDeposit\n        );\n    }\n\n    /**\n    * @dev Tell juror-related information of a certain adjudication round\n    * @param _disputeId Identification number of the dispute being queried\n    * @param _roundId Identification number of the round being queried\n    * @param _juror Address of the juror being queried\n    * @return weight Juror weight drafted for the requested round\n    * @return rewarded Whether or not the given juror was rewarded based on the requested round\n    */\n    function getJuror(uint256 _disputeId, uint256 _roundId, address _juror) external view roundExists(_disputeId, _roundId)\n        returns (uint64 weight, bool rewarded)\n    {\n        Dispute storage dispute = disputes[_disputeId];\n        AdjudicationRound storage round = dispute.rounds[_roundId];\n        Config memory config = _getDisputeConfig(dispute);\n\n        if (_isRegularRound(_roundId, config)) {\n            weight = _getJurorWeight(round, _juror);\n        } else {\n            IJurorsRegistry jurorsRegistry = _jurorsRegistry();\n            uint256 activeBalance = jurorsRegistry.activeBalanceOfAt(_juror, round.draftTermId);\n            weight = _getMinActiveBalanceMultiple(activeBalance, config.minActiveBalance);\n        }\n\n        rewarded = round.jurorsStates[_juror].rewarded;\n    }\n\n    /**\n    * @dev Internal function to create a new round for a given dispute\n    * @param _disputeId Identification number of the dispute to create a new round for\n    * @param _disputeState New state for the dispute to be changed\n    * @param _draftTermId Term ID when the jurors for the new round will be drafted\n    * @param _jurorsNumber Number of jurors to be drafted for the new round\n    * @param _jurorFees Total amount of fees to be shared between the winning jurors of the new round\n    * @return Identification number of the new dispute round\n    */\n    function _createRound(uint256 _disputeId, DisputeState _disputeState, uint64 _draftTermId, uint64 _jurorsNumber, uint256 _jurorFees) internal\n        returns (uint256)\n    {\n        // Update dispute state\n        Dispute storage dispute = disputes[_disputeId];\n        dispute.state = _disputeState;\n\n        // Create new requested round\n        uint256 roundId = dispute.rounds.length++;\n        AdjudicationRound storage round = dispute.rounds[roundId];\n        round.draftTermId = _draftTermId;\n        round.jurorsNumber = _jurorsNumber;\n        round.jurorFees = _jurorFees;\n\n        // Create new vote for the new round\n        ICRVoting voting = _voting();\n        uint256 voteId = _getVoteId(_disputeId, roundId);\n        voting.create(voteId, dispute.possibleRulings);\n        return roundId;\n    }\n\n    /**\n    * @dev Internal function to ensure the adjudication state of a certain dispute round. This function will make sure the court term is updated.\n    *      This function assumes the given round exists.\n    * @param _dispute Dispute to be checked\n    * @param _roundId Identification number of the dispute round to be checked\n    * @param _state Expected adjudication state for the given dispute round\n    * @param _config Config at the draft term ID of the given dispute\n    */\n    function _ensureAdjudicationState(Dispute storage _dispute, uint256 _roundId, AdjudicationState _state, DisputesConfig memory _config)\n        internal\n    {\n        uint64 termId = _ensureCurrentTerm();\n        AdjudicationState roundState = _adjudicationStateAt(_dispute, _roundId, termId, _config);\n        require(roundState == _state, ERROR_INVALID_ADJUDICATION_STATE);\n    }\n\n    /**\n    * @dev Internal function to ensure the final ruling of a dispute. It will compute it only if missing.\n    * @param _dispute Dispute to ensure its final ruling\n    * @param _disputeId Identification number of the dispute to ensure its final ruling\n    * @param _config Config at the draft term ID of the given dispute\n    * @return Number of the final ruling ensured for the given dispute\n    */\n    function _ensureFinalRuling(Dispute storage _dispute, uint256 _disputeId, Config memory _config) internal returns (uint8) {\n        // Check if there was a final ruling already cached\n        if (uint256(_dispute.finalRuling) > 0) {\n            return _dispute.finalRuling;\n        }\n\n        // Ensure current term and check that the last adjudication round has ended.\n        // Note that there will always be at least one round.\n        uint256 lastRoundId = _dispute.rounds.length - 1;\n        _ensureAdjudicationState(_dispute, lastRoundId, AdjudicationState.Ended, _config.disputes);\n\n        // If the last adjudication round was appealed but no-one confirmed it, the final ruling is the outcome the\n        // appealer vouched for. Otherwise, fetch the winning outcome from the voting app of the last round.\n        AdjudicationRound storage lastRound = _dispute.rounds[lastRoundId];\n        Appeal storage lastAppeal = lastRound.appeal;\n        bool isRoundAppealedAndNotConfirmed = _existsAppeal(lastAppeal) && !_isAppealConfirmed(lastAppeal);\n        uint8 finalRuling = isRoundAppealedAndNotConfirmed\n            ? lastAppeal.appealedRuling\n            : _voting().getWinningOutcome(_getVoteId(_disputeId, lastRoundId));\n\n        // Store the winning ruling as the final decision for the given dispute\n        _dispute.finalRuling = finalRuling;\n        return finalRuling;\n    }\n\n    /**\n    * @dev Internal function to slash all the jurors drafted for a round that didn't vote in favor of the final ruling of a dispute. Note that\n    *      the slashing can be batched handling the maximum number of jurors to be slashed on each call.\n    * @param _round Round to slash the non-winning jurors of\n    * @param _voteId Identification number of the voting associated to the given round\n    * @param _finalRuling Winning ruling of the dispute corresponding to the given round\n    * @param _penaltyPct Per ten thousand of the minimum active balance of a juror to be slashed\n    * @param _jurorsToSettle Maximum number of jurors to be slashed in this call. It can be set to zero to slash all the losing jurors of the round.\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\n    * @return Number of jurors slashed for the given round\n    */\n    function _settleRegularRoundPenalties(\n        AdjudicationRound storage _round,\n        uint256 _voteId,\n        uint8 _finalRuling,\n        uint16 _penaltyPct,\n        uint256 _jurorsToSettle,\n        uint256 _minActiveBalance\n    )\n        internal\n        returns (uint256)\n    {\n        uint64 termId = _ensureCurrentTerm();\n        // The batch starts where the previous one ended, stored in _round.settledJurors\n        uint256 roundSettledJurors = _round.settledJurors;\n        // Compute the amount of jurors that are going to be settled in this batch, which is returned by the function for fees calculation\n        // Initially we try to reach the end of the jurors array\n        uint256 batchSettledJurors = _round.jurors.length.sub(roundSettledJurors);\n\n        // If the requested amount of jurors is not zero and it is lower that the remaining number of jurors to be settled for the given round,\n        // we cap the number of jurors that are going to be settled in this batch to the requested amount. If not, we know we have reached the\n        // last batch and we are safe to mark round penalties as settled.\n        if (_jurorsToSettle > 0 && batchSettledJurors > _jurorsToSettle) {\n            batchSettledJurors = _jurorsToSettle;\n        } else {\n            _round.settledPenalties = true;\n        }\n\n        // Update the number of round settled jurors.\n        _round.settledJurors = uint64(roundSettledJurors.add(batchSettledJurors));\n\n        // Prepare the list of jurors and penalties to either be slashed or returned based on their votes for the given round\n        IJurorsRegistry jurorsRegistry = _jurorsRegistry();\n        address[] memory jurors = new address[](batchSettledJurors);\n        uint256[] memory penalties = new uint256[](batchSettledJurors);\n        for (uint256 i = 0; i < batchSettledJurors; i++) {\n            address juror = _round.jurors[roundSettledJurors + i];\n            jurors[i] = juror;\n            penalties[i] = _minActiveBalance.pct(_penaltyPct).mul(_round.jurorsStates[juror].weight);\n        }\n\n        // Check which of the jurors voted in favor of the final ruling of the dispute in this round. Ask the registry to slash or unlocked the\n        // locked active tokens of each juror depending on their vote, and finally store the total amount of slashed tokens.\n        bool[] memory jurorsInFavor = _voting().getVotersInFavorOf(_voteId, _finalRuling, jurors);\n        _round.collectedTokens = _round.collectedTokens.add(jurorsRegistry.slashOrUnlock(termId, jurors, penalties, jurorsInFavor));\n        return batchSettledJurors;\n    }\n\n    /**\n    * @dev Internal function to compute the juror weight for a dispute's round\n    * @param _dispute Dispute to calculate the juror's weight of\n    * @param _roundId ID of the dispute's round to calculate the juror's weight of\n    * @param _juror Address of the juror to calculate the weight of\n    * @param _config Config at the draft term ID of the given dispute\n    * @return Computed weight of the requested juror for the final round of the given dispute\n    */\n    function _computeJurorWeight(Dispute storage _dispute, uint256 _roundId, address _juror, Config memory _config) internal returns (uint64) {\n        AdjudicationRound storage round = _dispute.rounds[_roundId];\n\n        return _isRegularRound(_roundId, _config)\n            ? _getJurorWeight(round, _juror)\n            : _computeJurorWeightForFinalRound(_config, round, _juror);\n    }\n\n    /**\n    * @dev Internal function to compute the juror weight for the final round. Note that for a final round the weight of\n    *      each juror is equal to the number of times the min active balance the juror has. This function will try to\n    *      collect said amount from the active balance of a juror, acting as a lock to allow them to vote.\n    * @param _config Court config to calculate the juror's weight\n    * @param _round Dispute round to calculate the juror's weight for\n    * @param _juror Address of the juror to calculate the weight of\n    * @return Weight of the requested juror for the final round of the given dispute\n    */\n    function _computeJurorWeightForFinalRound(Config memory _config, AdjudicationRound storage _round, address _juror) internal\n        returns (uint64)\n    {\n        // Fetch active balance and multiples of the min active balance from the registry\n        IJurorsRegistry jurorsRegistry = _jurorsRegistry();\n        uint256 activeBalance = jurorsRegistry.activeBalanceOfAt(_juror, _round.draftTermId);\n        uint64 weight = _getMinActiveBalanceMultiple(activeBalance, _config.minActiveBalance);\n\n        // If the juror weight for the last round is zero, return zero\n        if (weight == 0) {\n            return uint64(0);\n        }\n\n        // To guarantee scalability of the final round, since all jurors may vote, we try to collect the amount of\n        // active tokens that needs to be locked for each juror when they try to commit their vote.\n        uint256 weightedPenalty = activeBalance.pct(_config.disputes.penaltyPct);\n\n        // If it was not possible to collect the amount to be locked, return 0 to prevent juror from voting\n        if (!jurorsRegistry.collectTokens(_juror, weightedPenalty, _getLastEnsuredTermId())) {\n            return uint64(0);\n        }\n\n        // If it was possible to collect the amount of active tokens to be locked, update the final round state\n        _round.jurorsStates[_juror].weight = weight;\n        _round.collectedTokens = _round.collectedTokens.add(weightedPenalty);\n\n        return weight;\n    }\n\n    /**\n    * @dev Sets the global configuration for the max number of jurors to be drafted per batch\n    * @param _maxJurorsPerDraftBatch Max number of jurors to be drafted per batch\n    */\n    function _setMaxJurorsPerDraftBatch(uint64 _maxJurorsPerDraftBatch) internal {\n        require(_maxJurorsPerDraftBatch > 0, ERROR_BAD_MAX_DRAFT_BATCH_SIZE);\n        emit MaxJurorsPerDraftBatchChanged(maxJurorsPerDraftBatch, _maxJurorsPerDraftBatch);\n        maxJurorsPerDraftBatch = _maxJurorsPerDraftBatch;\n    }\n\n    /**\n    * @dev Internal function to execute a deposit of tokens from an account to the Court treasury contract\n    * @param _from Address transferring the amount of tokens\n    * @param _token ERC20 token to execute a transfer from\n    * @param _amount Amount of tokens to be transferred from the address transferring the funds to the Court treasury\n    */\n    function _depositAmount(address _from, ERC20 _token, uint256 _amount) internal {\n        if (_amount > 0) {\n            ITreasury treasury = _treasury();\n            require(_token.safeTransferFrom(_from, address(treasury), _amount), ERROR_DEPOSIT_FAILED);\n        }\n    }\n\n    /**\n    * @dev Internal function to get the stored juror weight for a round. Note that the weight of a juror is:\n    *      - For a regular round: the number of times a juror was picked for the round round.\n    *      - For a final round: the relative active stake of a juror's state over the total active tokens, only set after the juror has voted.\n    * @param _round Dispute round to calculate the juror's weight of\n    * @param _juror Address of the juror to calculate the weight of\n    * @return Weight of the requested juror for the given round\n    */\n    function _getJurorWeight(AdjudicationRound storage _round, address _juror) internal view returns (uint64) {\n        return _round.jurorsStates[_juror].weight;\n    }\n\n    /**\n    * @dev Internal function to tell information related to the next round due to an appeal of a certain round given. This function assumes\n    *      given round can be appealed and that the given round ID corresponds to the given round pointer.\n    * @param _round Round requesting the appeal details of\n    * @param _roundId Identification number of the round requesting the appeal details of\n    * @param _config Config at the draft term of the given dispute\n    * @return Next round details\n    */\n    function _getNextRoundDetails(AdjudicationRound storage _round, uint256 _roundId, Config memory _config) internal view\n        returns (NextRoundDetails memory)\n    {\n        NextRoundDetails memory nextRound;\n        DisputesConfig memory disputesConfig = _config.disputes;\n\n        // Next round start term is current round end term\n        uint64 delayedDraftTerm = _round.draftTermId.add(_round.delayedTerms);\n        uint64 currentRoundAppealStartTerm = delayedDraftTerm.add(disputesConfig.commitTerms).add(disputesConfig.revealTerms);\n        nextRound.startTerm = currentRoundAppealStartTerm.add(disputesConfig.appealTerms).add(disputesConfig.appealConfirmTerms);\n\n        // Compute next round settings depending on if it will be the final round or not\n        if (_roundId >= disputesConfig.maxRegularAppealRounds.sub(1)) {\n            // If the next round is the final round, no draft is needed.\n            nextRound.newDisputeState = DisputeState.Adjudicating;\n            // The number of jurors will be the number of times the minimum stake is held in the registry,\n            // multiplied by a precision factor to help with division rounding.\n            // Total active balance is guaranteed to never be greater than `2^64 * minActiveBalance / FINAL_ROUND_WEIGHT_PRECISION`.\n            // Thus, the jurors number for a final round will always fit in uint64.\n            IJurorsRegistry jurorsRegistry = _jurorsRegistry();\n            uint256 totalActiveBalance = jurorsRegistry.totalActiveBalanceAt(nextRound.startTerm);\n            uint64 jurorsNumber = _getMinActiveBalanceMultiple(totalActiveBalance, _config.minActiveBalance);\n            nextRound.jurorsNumber = jurorsNumber;\n            // Calculate fees for the final round using the appeal start term of the current round\n            (nextRound.feeToken, nextRound.jurorFees, nextRound.totalFees) = _getFinalRoundFees(_config.fees, jurorsNumber);\n        } else {\n            // For a new regular rounds we need to draft jurors\n            nextRound.newDisputeState = DisputeState.PreDraft;\n            // The number of jurors will be the number of jurors of the current round multiplied by an appeal factor\n            nextRound.jurorsNumber = _getNextRegularRoundJurorsNumber(_round, disputesConfig);\n            // Calculate fees for the next regular round using the appeal start term of the current round\n            (nextRound.feeToken, nextRound.jurorFees, nextRound.totalFees) = _getRegularRoundFees(_config.fees, nextRound.jurorsNumber);\n        }\n\n        // Calculate appeal collateral\n        nextRound.appealDeposit = nextRound.totalFees.pct256(disputesConfig.appealCollateralFactor);\n        nextRound.confirmAppealDeposit = nextRound.totalFees.pct256(disputesConfig.appealConfirmCollateralFactor);\n        return nextRound;\n    }\n\n    /**\n    * @dev Internal function to calculate the jurors number for the next regular round of a given round. This function assumes Court term is\n    *      up-to-date, that the next round of the one given is regular, and the given config corresponds to the draft term of the given round.\n    * @param _round Round querying the jurors number of its next round\n    * @param _config Disputes config at the draft term of the first round of the dispute\n    * @return Jurors number for the next regular round of the given round\n    */\n    function _getNextRegularRoundJurorsNumber(AdjudicationRound storage _round, DisputesConfig memory _config) internal view returns (uint64) {\n        // Jurors number are increased by a step factor on each appeal\n        uint64 jurorsNumber = _round.jurorsNumber.mul(_config.appealStepFactor);\n        // Make sure it's odd to enforce avoiding a tie. Note that it can happen if any of the jurors don't vote anyway.\n        if (uint256(jurorsNumber) % 2 == 0) {\n            jurorsNumber++;\n        }\n        return jurorsNumber;\n    }\n\n    /**\n    * @dev Internal function to tell adjudication state of a round at a certain term. This function assumes the given round exists.\n    * @param _dispute Dispute querying the adjudication round of\n    * @param _roundId Identification number of the dispute round querying the adjudication round of\n    * @param _termId Identification number of the term to be used for the different round phases durations\n    * @param _config Disputes config at the draft term ID of the given dispute\n    * @return Adjudication state of the requested dispute round for the given term\n    */\n    function _adjudicationStateAt(Dispute storage _dispute, uint256 _roundId, uint64 _termId, DisputesConfig memory _config) internal view\n        returns (AdjudicationState)\n    {\n        AdjudicationRound storage round = _dispute.rounds[_roundId];\n\n        // If the dispute is ruled or the given round is not the last one, we consider it ended\n        uint256 numberOfRounds = _dispute.rounds.length;\n        if (_dispute.state == DisputeState.Ruled || _roundId < numberOfRounds.sub(1)) {\n            return AdjudicationState.Ended;\n        }\n\n        // If given term is before the actual term when the last round was finally drafted, then the last round adjudication state is invalid\n        uint64 draftFinishedTermId = round.draftTermId.add(round.delayedTerms);\n        if (_dispute.state == DisputeState.PreDraft || _termId < draftFinishedTermId) {\n            return AdjudicationState.Invalid;\n        }\n\n        // If given term is before the reveal start term of the last round, then jurors are still allowed to commit votes for the last round\n        uint64 revealStartTerm = draftFinishedTermId.add(_config.commitTerms);\n        if (_termId < revealStartTerm) {\n            return AdjudicationState.Committing;\n        }\n\n        // If given term is before the appeal start term of the last round, then jurors are still allowed to reveal votes for the last round\n        uint64 appealStartTerm = revealStartTerm.add(_config.revealTerms);\n        if (_termId < appealStartTerm) {\n            return AdjudicationState.Revealing;\n        }\n\n        // If the max number of appeals has been reached, then the last round is the final round and can be considered ended\n        bool maxAppealReached = numberOfRounds > _config.maxRegularAppealRounds;\n        if (maxAppealReached) {\n            return AdjudicationState.Ended;\n        }\n\n        // If the last round was not appealed yet, check if the confirmation period has started or not\n        bool isLastRoundAppealed = _existsAppeal(round.appeal);\n        uint64 appealConfirmationStartTerm = appealStartTerm.add(_config.appealTerms);\n        if (!isLastRoundAppealed) {\n            // If given term is before the appeal confirmation start term, then the last round can still be appealed. Otherwise, it is ended.\n            if (_termId < appealConfirmationStartTerm) {\n                return AdjudicationState.Appealing;\n            } else {\n                return AdjudicationState.Ended;\n            }\n        }\n\n        // If the last round was appealed and the given term is before the appeal confirmation end term, then the last round appeal can still be\n        // confirmed. Note that if the round being checked was already appealed and confirmed, it won't be the last round, thus it will be caught\n        // above by the first check and considered 'Ended'.\n        uint64 appealConfirmationEndTerm = appealConfirmationStartTerm.add(_config.appealConfirmTerms);\n        if (_termId < appealConfirmationEndTerm) {\n            return AdjudicationState.ConfirmingAppeal;\n        }\n\n        // If non of the above conditions have been met, the last round is considered ended\n        return AdjudicationState.Ended;\n    }\n\n    /**\n    * @dev Internal function to get the Court config used for a dispute\n    * @param _dispute Dispute querying the Court config of\n    * @return Court config used for the given dispute\n    */\n    function _getDisputeConfig(Dispute storage _dispute) internal view returns (Config memory) {\n        // Note that it is safe to access a Court config directly for a past term\n        return _getConfigAt(_dispute.createTermId);\n    }\n\n    /**\n    * @dev Internal function to check if a certain appeal exists\n    * @param _appeal Appeal to be checked\n    * @return True if the given appeal has a maker address associated to it, false otherwise\n    */\n    function _existsAppeal(Appeal storage _appeal) internal view returns (bool) {\n        return _appeal.maker != address(0);\n    }\n\n    /**\n    * @dev Internal function to check if a certain appeal has been confirmed\n    * @param _appeal Appeal to be checked\n    * @return True if the given appeal was confirmed, false otherwise\n    */\n    function _isAppealConfirmed(Appeal storage _appeal) internal view returns (bool) {\n        return _appeal.taker != address(0);\n    }\n\n    /**\n    * @dev Internal function to check if a certain dispute exists, it reverts if it doesn't\n    * @param _disputeId Identification number of the dispute to be checked\n    */\n    function _checkDisputeExists(uint256 _disputeId) internal view {\n        require(_disputeId < disputes.length, ERROR_DISPUTE_DOES_NOT_EXIST);\n    }\n\n    /**\n    * @dev Internal function to check if a certain dispute round exists, it reverts if it doesn't\n    * @param _disputeId Identification number of the dispute to be checked\n    * @param _roundId Identification number of the dispute round to be checked\n    */\n    function _checkRoundExists(uint256 _disputeId, uint256 _roundId) internal view {\n        _checkDisputeExists(_disputeId);\n        require(_roundId < disputes[_disputeId].rounds.length, ERROR_ROUND_DOES_NOT_EXIST);\n    }\n\n    /**\n    * @dev Internal function to get the dispute round of a certain vote identification number\n    * @param _voteId Identification number of the vote querying the dispute round of\n    * @return dispute Dispute for the given vote\n    * @return roundId Identification number of the dispute round for the given vote\n    */\n    function _decodeVoteId(uint256 _voteId) internal view returns (Dispute storage dispute, uint256 roundId) {\n        uint256 disputeId = _voteId >> 128;\n        roundId = _voteId & VOTE_ID_MASK;\n        _checkRoundExists(disputeId, roundId);\n        dispute = disputes[disputeId];\n    }\n\n    /**\n    * @dev Internal function to get the identification number of the vote of a certain dispute round\n    * @param _disputeId Identification number of the dispute querying the vote ID of\n    * @param _roundId Identification number of the dispute round querying the vote ID of\n    * @return Identification number of the vote of the requested dispute round\n    */\n    function _getVoteId(uint256 _disputeId, uint256 _roundId) internal pure returns (uint256) {\n        return (_disputeId << 128) + _roundId;\n    }\n\n    /**\n    * @dev Assumes round.coherentJurors is greater than zero\n    * @param _round Round which the weighted amount is computed for\n    * @param _jurorState Juror with state which the weighted amount is computed for\n    * @param _amount Amount to be weighted\n    * @return Weighted amount for a juror in a round in relation to total amount of coherent jurors\n    */\n    function _getRoundWeightedAmount(\n        AdjudicationRound storage _round,\n        JurorState storage _jurorState,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return _amount.mul(_jurorState.weight) / _round.coherentJurors;\n    }\n\n    /**\n    * @dev Internal function to get fees information for regular rounds for a certain term. This function assumes Court term is up-to-date.\n    * @param _config Court config to use in order to get fees\n    * @param _jurorsNumber Number of jurors participating in the round being queried\n    * @return feeToken ERC20 token used for the fees\n    * @return jurorFees Total amount of fees to be distributed between the winning jurors of a round\n    * @return totalFees Total amount of fees for a regular round at the given term\n    */\n    function _getRegularRoundFees(FeesConfig memory _config, uint64 _jurorsNumber) internal pure\n        returns (ERC20 feeToken, uint256 jurorFees, uint256 totalFees)\n    {\n        feeToken = _config.token;\n        // For regular rounds the fees for each juror is constant and given by the config of the round\n        jurorFees = uint256(_jurorsNumber).mul(_config.jurorFee);\n        // The total fees for regular rounds also considers the number of drafts and settles\n        uint256 draftAndSettleFees = (_config.draftFee.add(_config.settleFee)).mul(uint256(_jurorsNumber));\n        totalFees = jurorFees.add(draftAndSettleFees);\n    }\n\n    /**\n    * @dev Internal function to get fees information for final rounds for a certain term. This function assumes Court term is up-to-date.\n    * @param _config Court config to use in order to get fees\n    * @param _jurorsNumber Number of jurors participating in the round being queried\n    * @return feeToken ERC20 token used for the fees\n    * @return jurorFees Total amount of fees corresponding to the jurors at the given term\n    * @return totalFees Total amount of fees for a final round at the given term\n    */\n    function _getFinalRoundFees(FeesConfig memory _config, uint64 _jurorsNumber) internal pure\n        returns (ERC20 feeToken, uint256 jurorFees, uint256 totalFees)\n    {\n        feeToken = _config.token;\n        // For final rounds, the jurors number is computed as the number of times the registry's minimum active balance is held in the registry\n        // itself, multiplied by a precision factor. To avoid requesting a huge amount of fees, a final round discount is applied for each juror.\n        jurorFees = (uint256(_jurorsNumber).mul(_config.jurorFee) / FINAL_ROUND_WEIGHT_PRECISION).pct(_config.finalRoundReduction);\n        // There is no draft and no extra settle fees considered for final rounds\n        totalFees = jurorFees;\n    }\n\n    /**\n    * @dev Internal function to tell whether a round is regular or final. This function assumes the given round exists.\n    * @param _roundId Identification number of the round to be checked\n    * @param _config Court config to use in order to check if the given round is regular or final\n    * @return True if the given round is regular, false in case its a final round\n    */\n    function _isRegularRound(uint256 _roundId, Config memory _config) internal pure returns (bool) {\n        return _roundId < _config.disputes.maxRegularAppealRounds;\n    }\n\n    /**\n    * @dev Calculate the number of times that an amount contains the min active balance (multiplied by precision).\n    *      Used to get the juror weight for the final round. Note that for the final round the weight of\n    *      each juror is equal to the number of times the min active balance the juror has, multiplied by a precision\n    *      factor to deal with division rounding.\n    * @param _activeBalance Juror's or total active balance\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\n    * @return Number of times that the active balance contains the min active balance (multiplied by precision)\n    */\n    function _getMinActiveBalanceMultiple(uint256 _activeBalance, uint256 _minActiveBalance) internal pure returns (uint64) {\n        // Note that jurors may not reach the minimum active balance since some might have been slashed. If that occurs,\n        // these jurors cannot vote in the final round.\n        if (_activeBalance < _minActiveBalance) {\n            return 0;\n        }\n\n        // Otherwise, return the times the active balance of the juror fits in the min active balance, multiplying\n        // it by a round factor to ensure a better precision rounding.\n        return (FINAL_ROUND_WEIGHT_PRECISION.mul(_activeBalance) / _minActiveBalance).toUint64();\n    }\n\n    /**\n    * @dev Private function to build params to call for a draft. It assumes the given data is correct.\n    * @param _disputeId Identification number of the dispute to be drafted\n    * @param _roundId Identification number of the round to be drafted\n    * @param _termId Identification number of the current term of the Court\n    * @param _draftTermRandomness Randomness of the term in which the dispute was requested to be drafted\n    * @param _config Draft config of the Court at the draft term\n    * @return Draft params object\n    */\n    function _buildDraftParams(uint256 _disputeId, uint256 _roundId, uint64 _termId, bytes32 _draftTermRandomness, DraftConfig memory _config)\n        private\n        pure\n        returns (DraftParams memory)\n    {\n        return DraftParams({\n            disputeId: _disputeId,\n            roundId: _roundId,\n            termId: _termId,\n            draftTermRandomness: _draftTermRandomness,\n            config: _config\n        });\n    }\n\n    /**\n    * @dev Private function to draft jurors for a given dispute and round. It assumes the given data is correct.\n    * @param _round Round of the dispute to be drafted\n    * @param _draftParams Draft params to be used for the draft\n    * @return True if all the requested jurors for the given round were drafted, false otherwise\n    */\n    function _draft(AdjudicationRound storage _round, DraftParams memory _draftParams) private returns (bool) {\n        uint64 jurorsNumber = _round.jurorsNumber;\n        uint64 selectedJurors = _round.selectedJurors;\n        uint64 maxJurorsPerBatch = maxJurorsPerDraftBatch;\n        uint64 jurorsToBeDrafted = jurorsNumber.sub(selectedJurors);\n        // Draft the min number of jurors between the one requested by the sender and the one requested by the sender\n        uint64 requestedJurors = jurorsToBeDrafted < maxJurorsPerBatch ? jurorsToBeDrafted : maxJurorsPerBatch;\n\n        // Pack draft params\n        uint256[7] memory params = [\n            uint256(_draftParams.draftTermRandomness),\n            _draftParams.disputeId,\n            uint256(_draftParams.termId),\n            uint256(selectedJurors),\n            uint256(requestedJurors),\n            uint256(jurorsNumber),\n            uint256(_draftParams.config.penaltyPct)\n        ];\n\n        // Draft jurors for the requested round\n        IJurorsRegistry jurorsRegistry = _jurorsRegistry();\n        (address[] memory jurors, uint256 draftedJurors) = jurorsRegistry.draft(params);\n\n        // Update round with drafted jurors information\n        uint64 newSelectedJurors = selectedJurors.add(uint64(draftedJurors));\n        _round.selectedJurors = newSelectedJurors;\n        _updateRoundDraftedJurors(_draftParams.disputeId, _draftParams.roundId, _round, jurors, draftedJurors);\n        bool draftEnded = newSelectedJurors == jurorsNumber;\n\n        // Transfer fees corresponding to the actual number of drafted jurors\n        uint256 draftFees = _draftParams.config.draftFee.mul(draftedJurors);\n        _treasury().assign(_draftParams.config.feeToken, msg.sender, draftFees);\n        return draftEnded;\n    }\n\n    /**\n    * @dev Private function to update the drafted jurors' weight for the given round\n    * @param _disputeId Identification number of the dispute being drafted\n    * @param _roundId Identification number of the round being drafted\n    * @param _round Adjudication round that was drafted\n    * @param _jurors List of jurors addresses that were drafted for the given round\n    * @param _draftedJurors Number of jurors that were drafted for the given round. Note that this number may not necessarily be equal to the\n    *        given list of jurors since the draft could potentially return less jurors than the requested amount.\n    */\n    function _updateRoundDraftedJurors(\n        uint256 _disputeId,\n        uint256 _roundId,\n        AdjudicationRound storage _round,\n        address[] memory _jurors,\n        uint256 _draftedJurors\n    )\n        private\n    {\n        for (uint256 i = 0; i < _draftedJurors; i++) {\n            address juror = _jurors[i];\n            JurorState storage jurorState = _round.jurorsStates[juror];\n\n            // If the juror was already registered in the list, then don't add it twice\n            if (uint256(jurorState.weight) == 0) {\n                _round.jurors.push(juror);\n            }\n\n            jurorState.weight = jurorState.weight.add(1);\n            emit JurorDrafted(_disputeId, _roundId, juror);\n        }\n    }\n\n    /**\n    * @dev Private function to burn the collected for a certain round in case there were no coherent jurors\n    * @param _dispute Dispute to settle penalties for\n    * @param _round Dispute round to settle penalties for\n    * @param _roundId Identification number of the dispute round to settle penalties for\n    * @param _courtTreasury Treasury module to refund the corresponding juror fees\n    * @param _feeToken ERC20 token to be used for the fees corresponding to the draft term of the given dispute round\n    * @param _collectedTokens Amount of tokens collected during the given dispute round\n    */\n    function _burnCollectedTokensIfNecessary(\n        Dispute storage _dispute,\n        AdjudicationRound storage _round,\n        uint256 _roundId,\n        ITreasury _courtTreasury,\n        ERC20 _feeToken,\n        uint256 _collectedTokens\n    )\n        private\n    {\n        // If there was at least one juror voting in favor of the winning ruling, return\n        if (_round.coherentJurors > 0) {\n            return;\n        }\n\n        // Burn all the collected tokens of the jurors to be slashed. Note that this will happen only when there were no jurors voting\n        // in favor of the final winning outcome. Otherwise, these will be re-distributed between the winning jurors in `settleReward`\n        // instead of being burned.\n        if (_collectedTokens > 0) {\n            IJurorsRegistry jurorsRegistry = _jurorsRegistry();\n            jurorsRegistry.burnTokens(_collectedTokens);\n        }\n\n        // Reimburse juror fees to the Arbtirable subject for round 0 or to the previous appeal parties for other rounds.\n        // Note that if the given round is not the first round, we can ensure there was an appeal in the previous round.\n        if (_roundId == 0) {\n            _courtTreasury.assign(_feeToken, address(_dispute.subject), _round.jurorFees);\n        } else {\n            uint256 refundFees = _round.jurorFees / 2;\n            Appeal storage triggeringAppeal = _dispute.rounds[_roundId - 1].appeal;\n            _courtTreasury.assign(_feeToken, triggeringAppeal.maker, refundFees);\n            _courtTreasury.assign(_feeToken, triggeringAppeal.taker, refundFees);\n        }\n    }\n\n    /**\n    * @dev Private function only used in the constructor to skip a given number of disputes\n    * @param _skippedDisputes Number of disputes to be skipped\n    */\n    function _skipDisputes(uint256 _skippedDisputes) private {\n        assert(disputes.length == 0);\n        disputes.length = _skippedDisputes;\n    }\n}\n"
    },
    "contracts/lib/BytesHelpers.sol": {
      "content": "pragma solidity ^0.5.8;\n\n\nlibrary BytesHelpers {\n    function toBytes4(bytes memory _self) internal pure returns (bytes4 result) {\n        if (_self.length < 4) {\n            return bytes4(0);\n        }\n\n        assembly { result := mload(add(_self, 0x20)) }\n    }\n}\n"
    },
    "contracts/lib/Checkpointing.sol": {
      "content": "pragma solidity ^0.5.8;\n\n\n/**\n* @title Checkpointing - Library to handle a historic set of numeric values\n*/\nlibrary Checkpointing {\n    uint256 private constant MAX_UINT192 = uint256(uint192(-1));\n\n    string private constant ERROR_VALUE_TOO_BIG = \"CHECKPOINT_VALUE_TOO_BIG\";\n    string private constant ERROR_CANNOT_ADD_PAST_VALUE = \"CHECKPOINT_CANNOT_ADD_PAST_VALUE\";\n\n    /**\n    * @dev To specify a value at a given point in time, we need to store two values:\n    *      - `time`: unit-time value to denote the first time when a value was registered\n    *      - `value`: a positive numeric value to registered at a given point in time\n    *\n    *      Note that `time` does not need to refer necessarily to a timestamp value, any time unit could be used\n    *      for it like block numbers, terms, etc.\n    */\n    struct Checkpoint {\n        uint64 time;\n        uint192 value;\n    }\n\n    /**\n    * @dev A history simply denotes a list of checkpoints\n    */\n    struct History {\n        Checkpoint[] history;\n    }\n\n    /**\n    * @dev Add a new value to a history for a given point in time. This function does not allow to add values previous\n    *      to the latest registered value, if the value willing to add corresponds to the latest registered value, it\n    *      will be updated.\n    * @param self Checkpoints history to be altered\n    * @param _time Point in time to register the given value\n    * @param _value Numeric value to be registered at the given point in time\n    */\n    function add(History storage self, uint64 _time, uint256 _value) internal {\n        require(_value <= MAX_UINT192, ERROR_VALUE_TOO_BIG);\n        _add192(self, _time, uint192(_value));\n    }\n\n    /**\n    * @dev Fetch the latest registered value of history, it will return zero if there was no value registered\n    * @param self Checkpoints history to be queried\n    */\n    function getLast(History storage self) internal view returns (uint256) {\n        uint256 length = self.history.length;\n        if (length > 0) {\n            return uint256(self.history[length - 1].value);\n        }\n\n        return 0;\n    }\n\n    /**\n    * @dev Fetch the most recent registered past value of a history based on a given point in time that is not known\n    *      how recent it is beforehand. It will return zero if there is no registered value or if given time is\n    *      previous to the first registered value.\n    *      It uses a binary search.\n    * @param self Checkpoints history to be queried\n    * @param _time Point in time to query the most recent registered past value of\n    */\n    function get(History storage self, uint64 _time) internal view returns (uint256) {\n        return _binarySearch(self, _time);\n    }\n\n    /**\n    * @dev Fetch the most recent registered past value of a history based on a given point in time. It will return zero\n    *      if there is no registered value or if given time is previous to the first registered value.\n    *      It uses a linear search starting from the end.\n    * @param self Checkpoints history to be queried\n    * @param _time Point in time to query the most recent registered past value of\n    */\n    function getRecent(History storage self, uint64 _time) internal view returns (uint256) {\n        return _backwardsLinearSearch(self, _time);\n    }\n\n    /**\n    * @dev Private function to add a new value to a history for a given point in time. This function does not allow to\n    *      add values previous to the latest registered value, if the value willing to add corresponds to the latest\n    *      registered value, it will be updated.\n    * @param self Checkpoints history to be altered\n    * @param _time Point in time to register the given value\n    * @param _value Numeric value to be registered at the given point in time\n    */\n    function _add192(History storage self, uint64 _time, uint192 _value) private {\n        uint256 length = self.history.length;\n        if (length == 0 || self.history[self.history.length - 1].time < _time) {\n            // If there was no value registered or the given point in time is after the latest registered value,\n            // we can insert it to the history directly.\n            self.history.push(Checkpoint(_time, _value));\n        } else {\n            // If the point in time given for the new value is not after the latest registered value, we must ensure\n            // we are only trying to update the latest value, otherwise we would be changing past data.\n            Checkpoint storage currentCheckpoint = self.history[length - 1];\n            require(_time == currentCheckpoint.time, ERROR_CANNOT_ADD_PAST_VALUE);\n            currentCheckpoint.value = _value;\n        }\n    }\n\n    /**\n    * @dev Private function to execute a backwards linear search to find the most recent registered past value of a\n    *      history based on a given point in time. It will return zero if there is no registered value or if given time\n    *      is previous to the first registered value. Note that this function will be more suitable when we already know\n    *      that the time used to index the search is recent in the given history.\n    * @param self Checkpoints history to be queried\n    * @param _time Point in time to query the most recent registered past value of\n    */\n    function _backwardsLinearSearch(History storage self, uint64 _time) private view returns (uint256) {\n        // If there was no value registered for the given history return simply zero\n        uint256 length = self.history.length;\n        if (length == 0) {\n            return 0;\n        }\n\n        uint256 index = length - 1;\n        Checkpoint storage checkpoint = self.history[index];\n        while (index > 0 && checkpoint.time > _time) {\n            index--;\n            checkpoint = self.history[index];\n        }\n\n        return checkpoint.time > _time ? 0 : uint256(checkpoint.value);\n    }\n\n    /**\n    * @dev Private function execute a binary search to find the most recent registered past value of a history based on\n    *      a given point in time. It will return zero if there is no registered value or if given time is previous to\n    *      the first registered value. Note that this function will be more suitable when don't know how recent the\n    *      time used to index may be.\n    * @param self Checkpoints history to be queried\n    * @param _time Point in time to query the most recent registered past value of\n    */\n    function _binarySearch(History storage self, uint64 _time) private view returns (uint256) {\n        // If there was no value registered for the given history return simply zero\n        uint256 length = self.history.length;\n        if (length == 0) {\n            return 0;\n        }\n\n        // If the requested time is equal to or after the time of the latest registered value, return latest value\n        uint256 lastIndex = length - 1;\n        if (_time >= self.history[lastIndex].time) {\n            return uint256(self.history[lastIndex].value);\n        }\n\n        // If the requested time is previous to the first registered value, return zero to denote missing checkpoint\n        if (_time < self.history[0].time) {\n            return 0;\n        }\n\n        // Execute a binary search between the checkpointed times of the history\n        uint256 low = 0;\n        uint256 high = lastIndex;\n\n        while (high > low) {\n            // No need for SafeMath: for this to overflow array size should be ~2^255\n            uint256 mid = (high + low + 1) / 2;\n            Checkpoint storage checkpoint = self.history[mid];\n            uint64 midTime = checkpoint.time;\n\n            if (_time > midTime) {\n                low = mid;\n            } else if (_time < midTime) {\n                // No need for SafeMath: high > low >= 0 => high >= 1 => mid >= 1\n                high = mid - 1;\n            } else {\n                return uint256(checkpoint.value);\n            }\n        }\n\n        return uint256(self.history[low].value);\n    }\n}\n"
    },
    "contracts/lib/HexSumTree.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../lib/os/SafeMath.sol\";\n\nimport \"./Checkpointing.sol\";\n\n\n/**\n* @title HexSumTree - Library to operate checkpointed 16-ary (hex) sum trees.\n* @dev A sum tree is a particular case of a tree where the value of a node is equal to the sum of the values of its\n*      children. This library provides a set of functions to operate 16-ary sum trees, i.e. trees where every non-leaf\n*      node has 16 children and its value is equivalent to the sum of the values of all of them. Additionally, a\n*      checkpointed tree means that each time a value on a node is updated, its previous value will be saved to allow\n*      accessing historic information.\n*\n*      Example of a checkpointed binary sum tree:\n*\n*                                          CURRENT                                      PREVIOUS\n*\n*             Level 2                        100  ---------------------------------------- 70\n*                                       ______|_______                               ______|_______\n*                                      /              \\                             /              \\\n*             Level 1                 34              66 ------------------------- 23              47\n*                                _____|_____      _____|_____                 _____|_____      _____|_____\n*                               /           \\    /           \\               /           \\    /           \\\n*             Level 0          22           12  53           13 ----------- 22            1  17           30\n*\n*/\nlibrary HexSumTree {\n    using SafeMath for uint256;\n    using Checkpointing for Checkpointing.History;\n\n    string private constant ERROR_UPDATE_OVERFLOW = \"SUM_TREE_UPDATE_OVERFLOW\";\n    string private constant ERROR_KEY_DOES_NOT_EXIST = \"SUM_TREE_KEY_DOES_NOT_EXIST\";\n    string private constant ERROR_SEARCH_OUT_OF_BOUNDS = \"SUM_TREE_SEARCH_OUT_OF_BOUNDS\";\n    string private constant ERROR_MISSING_SEARCH_VALUES = \"SUM_TREE_MISSING_SEARCH_VALUES\";\n\n    // Constants used to perform tree computations\n    // To change any the following constants, the following relationship must be kept: 2^BITS_IN_NIBBLE = CHILDREN\n    // The max depth of the tree will be given by: BITS_IN_NIBBLE * MAX_DEPTH = 256 (so in this case it's 64)\n    uint256 private constant CHILDREN = 16;\n    uint256 private constant BITS_IN_NIBBLE = 4;\n\n    // All items are leaves, inserted at height or level zero. The root height will be increasing as new levels are inserted in the tree.\n    uint256 private constant ITEMS_LEVEL = 0;\n\n    // Tree nodes are identified with a 32-bytes length key. Leaves are identified with consecutive incremental keys\n    // starting with 0x0000000000000000000000000000000000000000000000000000000000000000, while non-leaf nodes' keys\n    // are computed based on their level and their children keys.\n    uint256 private constant BASE_KEY = 0;\n\n    // Timestamp used to checkpoint the first value of the tree height during initialization\n    uint64 private constant INITIALIZATION_INITIAL_TIME = uint64(0);\n\n    /**\n    * @dev The tree is stored using the following structure:\n    *      - nodes: A mapping indexed by a pair (level, key) with a history of the values for each node (level -> key -> value).\n    *      - height: A history of the heights of the tree. Minimum height is 1, a root with 16 children.\n    *      - nextKey: The next key to be used to identify the next new value that will be inserted into the tree.\n    */\n    struct Tree {\n        uint256 nextKey;\n        Checkpointing.History height;\n        mapping (uint256 => mapping (uint256 => Checkpointing.History)) nodes;\n    }\n\n    /**\n    * @dev Search params to traverse the tree caching previous results:\n    *      - time: Point in time to query the values being searched, this value shouldn't change during a search\n    *      - level: Level being analyzed for the search, it starts at the level under the root and decrements till the leaves\n    *      - parentKey: Key of the parent of the nodes being analyzed at the given level for the search\n    *      - foundValues: Number of values in the list being searched that were already found, it will go from 0 until the size of the list\n    *      - visitedTotal: Total sum of values that were already visited during the search, it will go from 0 until the tree total\n    */\n    struct SearchParams {\n        uint64 time;\n        uint256 level;\n        uint256 parentKey;\n        uint256 foundValues;\n        uint256 visitedTotal;\n    }\n\n    /**\n    * @dev Initialize tree setting the next key and first height checkpoint\n    */\n    function init(Tree storage self) internal {\n        self.height.add(INITIALIZATION_INITIAL_TIME, ITEMS_LEVEL + 1);\n        self.nextKey = BASE_KEY;\n    }\n\n    /**\n    * @dev Insert a new item to the tree at given point in time\n    * @param _time Point in time to register the given value\n    * @param _value New numeric value to be added to the tree\n    * @return Unique key identifying the new value inserted\n    */\n    function insert(Tree storage self, uint64 _time, uint256 _value) internal returns (uint256) {\n        // As the values are always stored in the leaves of the tree (level 0), the key to index each of them will be\n        // always incrementing, starting from zero. Add a new level if necessary.\n        uint256 key = self.nextKey++;\n        _addLevelIfNecessary(self, key, _time);\n\n        // If the new value is not zero, first set the value of the new leaf node, then add a new level at the top of\n        // the tree if necessary, and finally update sums cached in all the non-leaf nodes.\n        if (_value > 0) {\n            _add(self, ITEMS_LEVEL, key, _time, _value);\n            _updateSums(self, key, _time, _value, true);\n        }\n        return key;\n    }\n\n    /**\n    * @dev Set the value of a leaf node indexed by its key at given point in time\n    * @param _time Point in time to set the given value\n    * @param _key Key of the leaf node to be set in the tree\n    * @param _value New numeric value to be set for the given key\n    */\n    function set(Tree storage self, uint256 _key, uint64 _time, uint256 _value) internal {\n        require(_key < self.nextKey, ERROR_KEY_DOES_NOT_EXIST);\n\n        // Set the new value for the requested leaf node\n        uint256 lastValue = getItem(self, _key);\n        _add(self, ITEMS_LEVEL, _key, _time, _value);\n\n        // Update sums cached in the non-leaf nodes. Note that overflows are being checked at the end of the whole update.\n        if (_value > lastValue) {\n            _updateSums(self, _key, _time, _value - lastValue, true);\n        } else if (_value < lastValue) {\n            _updateSums(self, _key, _time, lastValue - _value, false);\n        }\n    }\n\n    /**\n    * @dev Update the value of a non-leaf node indexed by its key at given point in time based on a delta\n    * @param _key Key of the leaf node to be updated in the tree\n    * @param _time Point in time to update the given value\n    * @param _delta Numeric delta to update the value of the given key\n    * @param _positive Boolean to tell whether the given delta should be added to or subtracted from the current value\n    */\n    function update(Tree storage self, uint256 _key, uint64 _time, uint256 _delta, bool _positive) internal {\n        require(_key < self.nextKey, ERROR_KEY_DOES_NOT_EXIST);\n\n        // Update the value of the requested leaf node based on the given delta\n        uint256 lastValue = getItem(self, _key);\n        uint256 newValue = _positive ? lastValue.add(_delta) : lastValue.sub(_delta);\n        _add(self, ITEMS_LEVEL, _key, _time, newValue);\n\n        // Update sums cached in the non-leaf nodes. Note that overflows is being checked at the end of the whole update.\n        _updateSums(self, _key, _time, _delta, _positive);\n    }\n\n    /**\n    * @dev Search a list of values in the tree at a given point in time. It will return a list with the nearest\n    *      high value in case a value cannot be found. This function assumes the given list of given values to be\n    *      searched is in ascending order. In case of searching a value out of bounds, it will return zeroed results.\n    * @param _values Ordered list of values to be searched in the tree\n    * @param _time Point in time to query the values being searched\n    * @return keys List of keys found for each requested value in the same order\n    * @return values List of node values found for each requested value in the same order\n    */\n    function search(Tree storage self, uint256[] memory _values, uint64 _time) internal view\n        returns (uint256[] memory keys, uint256[] memory values)\n    {\n        require(_values.length > 0, ERROR_MISSING_SEARCH_VALUES);\n\n        // Throw out-of-bounds error if there are no items in the tree or the highest value being searched is greater than the total\n        uint256 total = getRecentTotalAt(self, _time);\n        // No need for SafeMath: positive length of array already checked\n        require(total > 0 && total > _values[_values.length - 1], ERROR_SEARCH_OUT_OF_BOUNDS);\n\n        // Build search params for the first iteration\n        uint256 rootLevel = getRecentHeightAt(self, _time);\n        SearchParams memory searchParams = SearchParams(_time, rootLevel.sub(1), BASE_KEY, 0, 0);\n\n        // These arrays will be used to fill in the results. We are passing them as parameters to avoid extra copies\n        uint256 length = _values.length;\n        keys = new uint256[](length);\n        values = new uint256[](length);\n        _search(self, _values, searchParams, keys, values);\n    }\n\n    /**\n    * @dev Tell the sum of the all the items (leaves) stored in the tree, i.e. value of the root of the tree\n    */\n    function getTotal(Tree storage self) internal view returns (uint256) {\n        uint256 rootLevel = getHeight(self);\n        return getNode(self, rootLevel, BASE_KEY);\n    }\n\n    /**\n    * @dev Tell the sum of the all the items (leaves) stored in the tree, i.e. value of the root of the tree, at a given point in time\n    *      It uses a binary search for the root node, a linear one for the height.\n    * @param _time Point in time to query the sum of all the items (leaves) stored in the tree\n    */\n    function getTotalAt(Tree storage self, uint64 _time) internal view returns (uint256) {\n        uint256 rootLevel = getRecentHeightAt(self, _time);\n        return getNodeAt(self, rootLevel, BASE_KEY, _time);\n    }\n\n    /**\n    * @dev Tell the sum of the all the items (leaves) stored in the tree, i.e. value of the root of the tree, at a given point in time\n    *      It uses a linear search starting from the end.\n    * @param _time Point in time to query the sum of all the items (leaves) stored in the tree\n    */\n    function getRecentTotalAt(Tree storage self, uint64 _time) internal view returns (uint256) {\n        uint256 rootLevel = getRecentHeightAt(self, _time);\n        return getRecentNodeAt(self, rootLevel, BASE_KEY, _time);\n    }\n\n    /**\n    * @dev Tell the value of a certain leaf indexed by a given key\n    * @param _key Key of the leaf node querying the value of\n    */\n    function getItem(Tree storage self, uint256 _key) internal view returns (uint256) {\n        return getNode(self, ITEMS_LEVEL, _key);\n    }\n\n    /**\n    * @dev Tell the value of a certain leaf indexed by a given key at a given point in time\n    *      It uses a binary search.\n    * @param _key Key of the leaf node querying the value of\n    * @param _time Point in time to query the value of the requested leaf\n    */\n    function getItemAt(Tree storage self, uint256 _key, uint64 _time) internal view returns (uint256) {\n        return getNodeAt(self, ITEMS_LEVEL, _key, _time);\n    }\n\n    /**\n    * @dev Tell the value of a certain node indexed by a given (level,key) pair\n    * @param _level Level of the node querying the value of\n    * @param _key Key of the node querying the value of\n    */\n    function getNode(Tree storage self, uint256 _level, uint256 _key) internal view returns (uint256) {\n        return self.nodes[_level][_key].getLast();\n    }\n\n    /**\n    * @dev Tell the value of a certain node indexed by a given (level,key) pair at a given point in time\n    *      It uses a binary search.\n    * @param _level Level of the node querying the value of\n    * @param _key Key of the node querying the value of\n    * @param _time Point in time to query the value of the requested node\n    */\n    function getNodeAt(Tree storage self, uint256 _level, uint256 _key, uint64 _time) internal view returns (uint256) {\n        return self.nodes[_level][_key].get(_time);\n    }\n\n    /**\n    * @dev Tell the value of a certain node indexed by a given (level,key) pair at a given point in time\n    *      It uses a linear search starting from the end.\n    * @param _level Level of the node querying the value of\n    * @param _key Key of the node querying the value of\n    * @param _time Point in time to query the value of the requested node\n    */\n    function getRecentNodeAt(Tree storage self, uint256 _level, uint256 _key, uint64 _time) internal view returns (uint256) {\n        return self.nodes[_level][_key].getRecent(_time);\n    }\n\n    /**\n    * @dev Tell the height of the tree\n    */\n    function getHeight(Tree storage self) internal view returns (uint256) {\n        return self.height.getLast();\n    }\n\n    /**\n    * @dev Tell the height of the tree at a given point in time\n    *      It uses a linear search starting from the end.\n    * @param _time Point in time to query the height of the tree\n    */\n    function getRecentHeightAt(Tree storage self, uint64 _time) internal view returns (uint256) {\n        return self.height.getRecent(_time);\n    }\n\n    /**\n    * @dev Private function to update the values of all the ancestors of the given leaf node based on the delta updated\n    * @param _key Key of the leaf node to update the ancestors of\n    * @param _time Point in time to update the ancestors' values of the given leaf node\n    * @param _delta Numeric delta to update the ancestors' values of the given leaf node\n    * @param _positive Boolean to tell whether the given delta should be added to or subtracted from ancestors' values\n    */\n    function _updateSums(Tree storage self, uint256 _key, uint64 _time, uint256 _delta, bool _positive) private {\n        uint256 mask = uint256(-1);\n        uint256 ancestorKey = _key;\n        uint256 currentHeight = getHeight(self);\n        for (uint256 level = ITEMS_LEVEL + 1; level <= currentHeight; level++) {\n            // Build a mask to get the key of the ancestor at a certain level. For example:\n            // Level  0: leaves don't have children\n            // Level  1: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0 (up to 16 leaves)\n            // Level  2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00 (up to 32 leaves)\n            // ...\n            // Level 63: 0x0000000000000000000000000000000000000000000000000000000000000000 (up to 16^64 leaves - tree max height)\n            mask = mask << BITS_IN_NIBBLE;\n\n            // The key of the ancestor at that level \"i\" is equivalent to the \"(64 - i)-th\" most significant nibbles\n            // of the ancestor's key of the previous level \"i - 1\". Thus, we can compute the key of an ancestor at a\n            // certain level applying the mask to the ancestor's key of the previous level. Note that for the first\n            // iteration, the key of the ancestor of the previous level is simply the key of the leaf being updated.\n            ancestorKey = ancestorKey & mask;\n\n            // Update value\n            uint256 lastValue = getNode(self, level, ancestorKey);\n            uint256 newValue = _positive ? lastValue.add(_delta) : lastValue.sub(_delta);\n            _add(self, level, ancestorKey, _time, newValue);\n        }\n\n        // Check if there was an overflow. Note that we only need to check the value stored in the root since the\n        // sum only increases going up through the tree.\n        require(!_positive || getNode(self, currentHeight, ancestorKey) >= _delta, ERROR_UPDATE_OVERFLOW);\n    }\n\n    /**\n    * @dev Private function to add a new level to the tree based on a new key that will be inserted\n    * @param _newKey New key willing to be inserted in the tree\n    * @param _time Point in time when the new key will be inserted\n    */\n    function _addLevelIfNecessary(Tree storage self, uint256 _newKey, uint64 _time) private {\n        uint256 currentHeight = getHeight(self);\n        if (_shouldAddLevel(currentHeight, _newKey)) {\n            // Max height allowed for the tree is 64 since we are using node keys of 32 bytes. However, note that we\n            // are not checking if said limit has been hit when inserting new leaves to the tree, for the purpose of\n            // this system having 2^256 items inserted is unrealistic.\n            uint256 newHeight = currentHeight + 1;\n            uint256 rootValue = getNode(self, currentHeight, BASE_KEY);\n            _add(self, newHeight, BASE_KEY, _time, rootValue);\n            self.height.add(_time, newHeight);\n        }\n    }\n\n    /**\n    * @dev Private function to register a new value in the history of a node at a given point in time\n    * @param _level Level of the node to add a new value at a given point in time to\n    * @param _key Key of the node to add a new value at a given point in time to\n    * @param _time Point in time to register a value for the given node\n    * @param _value Numeric value to be registered for the given node at a given point in time\n    */\n    function _add(Tree storage self, uint256 _level, uint256 _key, uint64 _time, uint256 _value) private {\n        self.nodes[_level][_key].add(_time, _value);\n    }\n\n    /**\n    * @dev Recursive pre-order traversal function\n    *      Every time it checks a node, it traverses the input array to find the initial subset of elements that are\n    *      below its accumulated value and passes that sub-array to the next iteration. Actually, the array is always\n    *      the same, to avoid making extra copies, it just passes the number of values already found , to avoid\n    *      checking values that went through a different branch. The same happens with the result lists of keys and\n    *      values, these are the same on every recursion step. The visited total is carried over each iteration to\n    *      avoid having to subtract all elements in the array.\n    * @param _values Ordered list of values to be searched in the tree\n    * @param _params Search parameters for the current recursive step\n    * @param _resultKeys List of keys found for each requested value in the same order\n    * @param _resultValues List of node values found for each requested value in the same order\n    */\n    function _search(\n        Tree storage self,\n        uint256[] memory _values,\n        SearchParams memory _params,\n        uint256[] memory _resultKeys,\n        uint256[] memory _resultValues\n    )\n        private\n        view\n    {\n        uint256 levelKeyLessSignificantNibble = _params.level.mul(BITS_IN_NIBBLE);\n\n        for (uint256 childNumber = 0; childNumber < CHILDREN; childNumber++) {\n            // Return if we already found enough values\n            if (_params.foundValues >= _values.length) {\n                break;\n            }\n\n            // Build child node key shifting the child number to the position of the less significant nibble of\n            // the keys for the level being analyzed, and adding it to the key of the parent node. For example,\n            // for a tree with height 5, if we are checking the children of the second node of the level 3, whose\n            // key is    0x0000000000000000000000000000000000000000000000000000000000001000, its children keys are:\n            // Child  0: 0x0000000000000000000000000000000000000000000000000000000000001000\n            // Child  1: 0x0000000000000000000000000000000000000000000000000000000000001100\n            // Child  2: 0x0000000000000000000000000000000000000000000000000000000000001200\n            // ...\n            // Child 15: 0x0000000000000000000000000000000000000000000000000000000000001f00\n            uint256 childNodeKey = _params.parentKey.add(childNumber << levelKeyLessSignificantNibble);\n            uint256 childNodeValue = getRecentNodeAt(self, _params.level, childNodeKey, _params.time);\n\n            // Check how many values belong to the subtree of this node. As they are ordered, it will be a contiguous\n            // subset starting from the beginning, so we only need to know the length of that subset.\n            uint256 newVisitedTotal = _params.visitedTotal.add(childNodeValue);\n            uint256 subtreeIncludedValues = _getValuesIncludedInSubtree(_values, _params.foundValues, newVisitedTotal);\n\n            // If there are some values included in the subtree of the child node, visit them\n            if (subtreeIncludedValues > 0) {\n                // If the child node being analyzed is a leaf, add it to the list of results a number of times equals\n                // to the number of values that were included in it. Otherwise, descend one level.\n                if (_params.level == ITEMS_LEVEL) {\n                    _copyFoundNode(_params.foundValues, subtreeIncludedValues, childNodeKey, _resultKeys, childNodeValue, _resultValues);\n                } else {\n                    SearchParams memory nextLevelParams = SearchParams(\n                        _params.time,\n                        _params.level - 1, // No need for SafeMath: we already checked above that the level being checked is greater than zero\n                        childNodeKey,\n                        _params.foundValues,\n                        _params.visitedTotal\n                    );\n                    _search(self, _values, nextLevelParams, _resultKeys, _resultValues);\n                }\n                // Update the number of values that were already found\n                _params.foundValues = _params.foundValues.add(subtreeIncludedValues);\n            }\n            // Update the visited total for the next node in this level\n            _params.visitedTotal = newVisitedTotal;\n        }\n    }\n\n    /**\n    * @dev Private function to check if a new key can be added to the tree based on the current height of the tree\n    * @param _currentHeight Current height of the tree to check if it supports adding the given key\n    * @param _newKey Key willing to be added to the tree with the given current height\n    * @return True if the current height of the tree should be increased to add the new key, false otherwise.\n    */\n    function _shouldAddLevel(uint256 _currentHeight, uint256 _newKey) private pure returns (bool) {\n        // Build a mask that will match all the possible keys for the given height. For example:\n        // Height  1: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0 (up to 16 keys)\n        // Height  2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00 (up to 32 keys)\n        // ...\n        // Height 64: 0x0000000000000000000000000000000000000000000000000000000000000000 (up to 16^64 keys - tree max height)\n        uint256 shift = _currentHeight.mul(BITS_IN_NIBBLE);\n        uint256 mask = uint256(-1) << shift;\n\n        // Check if the given key can be represented in the tree with the current given height using the mask.\n        return (_newKey & mask) != 0;\n    }\n\n    /**\n    * @dev Private function to tell how many values of a list can be found in a subtree\n    * @param _values List of values being searched in ascending order\n    * @param _foundValues Number of values that were already found and should be ignore\n    * @param _subtreeTotal Total sum of the given subtree to check the numbers that are included in it\n    * @return Number of values in the list that are included in the given subtree\n    */\n    function _getValuesIncludedInSubtree(uint256[] memory _values, uint256 _foundValues, uint256 _subtreeTotal) private pure returns (uint256) {\n        // Look for all the values that can be found in the given subtree\n        uint256 i = _foundValues;\n        while (i < _values.length && _values[i] < _subtreeTotal) {\n            i++;\n        }\n        return i - _foundValues;\n    }\n\n    /**\n    * @dev Private function to copy a node a given number of times to a results list. This function assumes the given\n    *      results list have enough size to support the requested copy.\n    * @param _from Index of the results list to start copying the given node\n    * @param _times Number of times the given node will be copied\n    * @param _key Key of the node to be copied\n    * @param _resultKeys Lists of key results to copy the given node key to\n    * @param _value Value of the node to be copied\n    * @param _resultValues Lists of value results to copy the given node value to\n    */\n    function _copyFoundNode(\n        uint256 _from,\n        uint256 _times,\n        uint256 _key,\n        uint256[] memory _resultKeys,\n        uint256 _value,\n        uint256[] memory _resultValues\n    )\n        private\n        pure\n    {\n        for (uint256 i = 0; i < _times; i++) {\n            _resultKeys[_from + i] = _key;\n            _resultValues[_from + i] = _value;\n        }\n    }\n}\n"
    },
    "contracts/lib/JurorsTreeSortition.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../lib/os/SafeMath.sol\";\n\nimport \"./HexSumTree.sol\";\n\n\n/**\n* @title JurorsTreeSortition - Library to perform jurors sortition over a `HexSumTree`\n*/\nlibrary JurorsTreeSortition {\n    using SafeMath for uint256;\n    using HexSumTree for HexSumTree.Tree;\n\n    string private constant ERROR_INVALID_INTERVAL_SEARCH = \"TREE_INVALID_INTERVAL_SEARCH\";\n    string private constant ERROR_SORTITION_LENGTHS_MISMATCH = \"TREE_SORTITION_LENGTHS_MISMATCH\";\n\n    /**\n    * @dev Search random items in the tree based on certain restrictions\n    * @param _termRandomness Randomness to compute the seed for the draft\n    * @param _disputeId Identification number of the dispute to draft jurors for\n    * @param _termId Current term when the draft is being computed\n    * @param _selectedJurors Number of jurors already selected for the draft\n    * @param _batchRequestedJurors Number of jurors to be selected in the given batch of the draft\n    * @param _roundRequestedJurors Total number of jurors requested to be drafted\n    * @param _sortitionIteration Number of sortitions already performed for the given draft\n    * @return jurorsIds List of juror ids obtained based on the requested search\n    * @return jurorsBalances List of active balances for each juror obtained based on the requested search\n    */\n    function batchedRandomSearch(\n        HexSumTree.Tree storage tree,\n        bytes32 _termRandomness,\n        uint256 _disputeId,\n        uint64 _termId,\n        uint256 _selectedJurors,\n        uint256 _batchRequestedJurors,\n        uint256 _roundRequestedJurors,\n        uint256 _sortitionIteration\n    )\n        internal\n        view\n        returns (uint256[] memory jurorsIds, uint256[] memory jurorsBalances)\n    {\n        (uint256 low, uint256 high) = getSearchBatchBounds(tree, _termId, _selectedJurors, _batchRequestedJurors, _roundRequestedJurors);\n        uint256[] memory balances = _computeSearchRandomBalances(\n            _termRandomness,\n            _disputeId,\n            _sortitionIteration,\n            _batchRequestedJurors,\n            low,\n            high\n        );\n\n        (jurorsIds, jurorsBalances) = tree.search(balances, _termId);\n\n        require(jurorsIds.length == jurorsBalances.length, ERROR_SORTITION_LENGTHS_MISMATCH);\n        require(jurorsIds.length == _batchRequestedJurors, ERROR_SORTITION_LENGTHS_MISMATCH);\n    }\n\n    /**\n    * @dev Get the bounds for a draft batch based on the active balances of the jurors\n    * @param _termId Term ID of the active balances that will be used to compute the boundaries\n    * @param _selectedJurors Number of jurors already selected for the draft\n    * @param _batchRequestedJurors Number of jurors to be selected in the given batch of the draft\n    * @param _roundRequestedJurors Total number of jurors requested to be drafted\n    * @return low Low bound to be used for the sortition to draft the requested number of jurors for the given batch\n    * @return high High bound to be used for the sortition to draft the requested number of jurors for the given batch\n    */\n    function getSearchBatchBounds(\n        HexSumTree.Tree storage tree,\n        uint64 _termId,\n        uint256 _selectedJurors,\n        uint256 _batchRequestedJurors,\n        uint256 _roundRequestedJurors\n    )\n        internal\n        view\n        returns (uint256 low, uint256 high)\n    {\n        uint256 totalActiveBalance = tree.getRecentTotalAt(_termId);\n        low = _selectedJurors.mul(totalActiveBalance).div(_roundRequestedJurors);\n\n        uint256 newSelectedJurors = _selectedJurors.add(_batchRequestedJurors);\n        high = newSelectedJurors.mul(totalActiveBalance).div(_roundRequestedJurors);\n    }\n\n    /**\n    * @dev Get a random list of active balances to be searched in the jurors tree for a given draft batch\n    * @param _termRandomness Randomness to compute the seed for the draft\n    * @param _disputeId Identification number of the dispute to draft jurors for (for randomness)\n    * @param _sortitionIteration Number of sortitions already performed for the given draft (for randomness)\n    * @param _batchRequestedJurors Number of jurors to be selected in the given batch of the draft\n    * @param _lowBatchBound Low bound to be used for the sortition batch to draft the requested number of jurors\n    * @param _highBatchBound High bound to be used for the sortition batch to draft the requested number of jurors\n    * @return Random list of active balances to be searched in the jurors tree for the given draft batch\n    */\n    function _computeSearchRandomBalances(\n        bytes32 _termRandomness,\n        uint256 _disputeId,\n        uint256 _sortitionIteration,\n        uint256 _batchRequestedJurors,\n        uint256 _lowBatchBound,\n        uint256 _highBatchBound\n    )\n        internal\n        pure\n        returns (uint256[] memory)\n    {\n        // Calculate the interval to be used to search the balances in the tree. Since we are using a modulo function to compute the\n        // random balances to be searched, intervals will be closed on the left and open on the right, for example [0,10).\n        require(_highBatchBound > _lowBatchBound, ERROR_INVALID_INTERVAL_SEARCH);\n        uint256 interval = _highBatchBound - _lowBatchBound;\n\n        // Compute an ordered list of random active balance to be searched in the jurors tree\n        uint256[] memory balances = new uint256[](_batchRequestedJurors);\n        for (uint256 batchJurorNumber = 0; batchJurorNumber < _batchRequestedJurors; batchJurorNumber++) {\n            // Compute a random seed using:\n            // - The inherent randomness associated to the term from blockhash\n            // - The disputeId, so 2 disputes in the same term will have different outcomes\n            // - The sortition iteration, to avoid getting stuck if resulting jurors are dismissed due to locked balance\n            // - The juror number in this batch\n            bytes32 seed = keccak256(abi.encodePacked(_termRandomness, _disputeId, _sortitionIteration, batchJurorNumber));\n\n            // Compute a random active balance to be searched in the jurors tree using the generated seed within the\n            // boundaries computed for the current batch.\n            balances[batchJurorNumber] = _lowBatchBound.add(uint256(seed) % interval);\n\n            // Make sure it's ordered, flip values if necessary\n            for (uint256 i = batchJurorNumber; i > 0 && balances[i] < balances[i - 1]; i--) {\n                uint256 tmp = balances[i - 1];\n                balances[i - 1] = balances[i];\n                balances[i] = tmp;\n            }\n        }\n        return balances;\n    }\n}\n"
    },
    "contracts/lib/os/Migrations.sol": {
      "content": "// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/misc/Migrations.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\n\ncontract Migrations {\n    address public owner;\n    uint256 public lastCompletedMigration;\n\n    modifier restricted() {\n        if (msg.sender == owner) {\n            _;\n        }\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setCompleted(uint256 completed) public restricted {\n        lastCompletedMigration = completed;\n    }\n\n    function upgrade(address newAddress) public restricted {\n        Migrations upgraded = Migrations(newAddress);\n        upgraded.setCompleted(lastCompletedMigration);\n    }\n}\n"
    },
    "contracts/registry/JurorsRegistry.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../lib/os/SafeERC20.sol\";\nimport \"../lib/os/ERC20.sol\";\nimport \"../lib/os/SafeMath.sol\";\n\nimport \"./IJurorsRegistry.sol\";\nimport \"../lib/BytesHelpers.sol\";\nimport \"../lib/HexSumTree.sol\";\nimport \"../lib/PctHelpers.sol\";\nimport \"../lib/JurorsTreeSortition.sol\";\nimport \"../standards/ERC900.sol\";\nimport \"../standards/ApproveAndCall.sol\";\nimport \"../court/controller/Controller.sol\";\nimport \"../court/controller/ControlledRecoverable.sol\";\n\n\ncontract JurorsRegistry is ControlledRecoverable, IJurorsRegistry, ERC900, ApproveAndCallFallBack {\n    using SafeERC20 for ERC20;\n    using SafeMath for uint256;\n    using PctHelpers for uint256;\n    using BytesHelpers for bytes;\n    using HexSumTree for HexSumTree.Tree;\n    using JurorsTreeSortition for HexSumTree.Tree;\n\n    string private constant ERROR_NOT_CONTRACT = \"JR_NOT_CONTRACT\";\n    string private constant ERROR_INVALID_ZERO_AMOUNT = \"JR_INVALID_ZERO_AMOUNT\";\n    string private constant ERROR_INVALID_ACTIVATION_AMOUNT = \"JR_INVALID_ACTIVATION_AMOUNT\";\n    string private constant ERROR_INVALID_DEACTIVATION_AMOUNT = \"JR_INVALID_DEACTIVATION_AMOUNT\";\n    string private constant ERROR_INVALID_LOCKED_AMOUNTS_LENGTH = \"JR_INVALID_LOCKED_AMOUNTS_LEN\";\n    string private constant ERROR_INVALID_REWARDED_JURORS_LENGTH = \"JR_INVALID_REWARDED_JURORS_LEN\";\n    string private constant ERROR_ACTIVE_BALANCE_BELOW_MIN = \"JR_ACTIVE_BALANCE_BELOW_MIN\";\n    string private constant ERROR_NOT_ENOUGH_AVAILABLE_BALANCE = \"JR_NOT_ENOUGH_AVAILABLE_BALANCE\";\n    string private constant ERROR_CANNOT_REDUCE_DEACTIVATION_REQUEST = \"JR_CANT_REDUCE_DEACTIVATION_REQ\";\n    string private constant ERROR_TOKEN_TRANSFER_FAILED = \"JR_TOKEN_TRANSFER_FAILED\";\n    string private constant ERROR_TOKEN_APPROVE_NOT_ALLOWED = \"JR_TOKEN_APPROVE_NOT_ALLOWED\";\n    string private constant ERROR_BAD_TOTAL_ACTIVE_BALANCE_LIMIT = \"JR_BAD_TOTAL_ACTIVE_BAL_LIMIT\";\n    string private constant ERROR_TOTAL_ACTIVE_BALANCE_EXCEEDED = \"JR_TOTAL_ACTIVE_BALANCE_EXCEEDED\";\n    string private constant ERROR_WITHDRAWALS_LOCK = \"JR_WITHDRAWALS_LOCK\";\n\n    // Address that will be used to burn juror tokens\n    address internal constant BURN_ACCOUNT = address(0x000000000000000000000000000000000000dEaD);\n\n    // Maximum number of sortition iterations allowed per draft call\n    uint256 internal constant MAX_DRAFT_ITERATIONS = 10;\n\n    /**\n    * @dev Jurors have three kind of balances, these are:\n    *      - active: tokens activated for the Court that can be locked in case the juror is drafted\n    *      - locked: amount of active tokens that are locked for a draft\n    *      - available: tokens that are not activated for the Court and can be withdrawn by the juror at any time\n    *\n    *      Due to a gas optimization for drafting, the \"active\" tokens are stored in a `HexSumTree`, while the others\n    *      are stored in this contract as `lockedBalance` and `availableBalance` respectively. Given that the jurors'\n    *      active balances cannot be affected during the current Court term, if jurors want to deactivate some of their\n    *      active tokens, their balance will be updated for the following term, and they won't be allowed to\n    *      withdraw them until the current term has ended.\n    *\n    *      Note that even though jurors balances are stored separately, all the balances are held by this contract.\n    */\n    struct Juror {\n        uint256 id;                                 // Key in the jurors tree used for drafting\n        uint256 lockedBalance;                      // Maximum amount of tokens that can be slashed based on the juror's drafts\n        uint256 availableBalance;                   // Available tokens that can be withdrawn at any time\n        uint64 withdrawalsLockTermId;               // Term ID until which the juror's withdrawals will be locked\n        DeactivationRequest deactivationRequest;    // Juror's pending deactivation request\n    }\n\n    /**\n    * @dev Given that the jurors balances cannot be affected during a Court term, if jurors want to deactivate some\n    *      of their tokens, the tree will always be updated for the following term, and they won't be able to\n    *      withdraw the requested amount until the current term has finished. Thus, we need to keep track the term\n    *      when a token deactivation was requested and its corresponding amount.\n    */\n    struct DeactivationRequest {\n        uint256 amount;                             // Amount requested for deactivation\n        uint64 availableTermId;                     // Term ID when jurors can withdraw their requested deactivation tokens\n    }\n\n    /**\n    * @dev Internal struct to wrap all the params required to perform jurors drafting\n    */\n    struct DraftParams {\n        bytes32 termRandomness;                     // Randomness seed to be used for the draft\n        uint256 disputeId;                          // ID of the dispute being drafted\n        uint64 termId;                              // Term ID of the dispute's draft term\n        uint256 selectedJurors;                     // Number of jurors already selected for the draft\n        uint256 batchRequestedJurors;               // Number of jurors to be selected in the given batch of the draft\n        uint256 roundRequestedJurors;               // Total number of jurors requested to be drafted\n        uint256 draftLockAmount;                    // Amount of tokens to be locked to each drafted juror\n        uint256 iteration;                          // Sortition iteration number\n    }\n\n    // Maximum amount of total active balance that can be held in the registry\n    uint256 internal totalActiveBalanceLimit;\n\n    // Juror ERC20 token\n    ERC20 internal jurorsToken;\n\n    // Mapping of juror data indexed by address\n    mapping (address => Juror) internal jurorsByAddress;\n\n    // Mapping of juror addresses indexed by id\n    mapping (uint256 => address) internal jurorsAddressById;\n\n    // Tree to store jurors active balance by term for the drafting process\n    HexSumTree.Tree internal tree;\n\n    event JurorActivated(address indexed juror, uint64 fromTermId, uint256 amount, address sender);\n    event JurorDeactivationRequested(address indexed juror, uint64 availableTermId, uint256 amount);\n    event JurorDeactivationProcessed(address indexed juror, uint64 availableTermId, uint256 amount, uint64 processedTermId);\n    event JurorDeactivationUpdated(address indexed juror, uint64 availableTermId, uint256 amount, uint64 updateTermId);\n    event JurorBalanceLocked(address indexed juror, uint256 amount);\n    event JurorBalanceUnlocked(address indexed juror, uint256 amount);\n    event JurorSlashed(address indexed juror, uint256 amount, uint64 effectiveTermId);\n    event JurorTokensAssigned(address indexed juror, uint256 amount);\n    event JurorTokensBurned(uint256 amount);\n    event JurorTokensCollected(address indexed juror, uint256 amount, uint64 effectiveTermId);\n    event TotalActiveBalanceLimitChanged(uint256 previousTotalActiveBalanceLimit, uint256 currentTotalActiveBalanceLimit);\n\n    /**\n    * @dev Constructor function\n    * @param _controller Address of the controller\n    * @param _jurorToken Address of the ERC20 token to be used as juror token for the registry\n    * @param _totalActiveBalanceLimit Maximum amount of total active balance that can be held in the registry\n    */\n    constructor(Controller _controller, ERC20 _jurorToken, uint256 _totalActiveBalanceLimit)\n        ControlledRecoverable(_controller)\n        public\n    {\n        // No need to explicitly call `Controlled` constructor since `ControlledRecoverable` is already doing it\n        require(isContract(address(_jurorToken)), ERROR_NOT_CONTRACT);\n\n        jurorsToken = _jurorToken;\n        _setTotalActiveBalanceLimit(_totalActiveBalanceLimit);\n\n        tree.init();\n        // First tree item is an empty juror\n        assert(tree.insert(0, 0) == 0);\n    }\n\n    /**\n    * @notice Activate `_amount == 0 ? 'all available tokens' : @tokenAmount(self.token(), _amount)` for the next term\n    * @param _amount Amount of juror tokens to be activated for the next term\n    */\n    function activate(uint256 _amount) external {\n        _activateTokens(msg.sender, _amount, msg.sender);\n    }\n\n    /**\n    * @notice Deactivate `_amount == 0 ? 'all unlocked tokens' : @tokenAmount(self.token(), _amount)` for the next term\n    * @param _amount Amount of juror tokens to be deactivated for the next term\n    */\n    function deactivate(uint256 _amount) external {\n        uint64 termId = _ensureCurrentTerm();\n        Juror storage juror = jurorsByAddress[msg.sender];\n        uint256 unlockedActiveBalance = _lastUnlockedActiveBalanceOf(juror);\n        uint256 amountToDeactivate = _amount == 0 ? unlockedActiveBalance : _amount;\n        require(amountToDeactivate > 0, ERROR_INVALID_ZERO_AMOUNT);\n        require(amountToDeactivate <= unlockedActiveBalance, ERROR_INVALID_DEACTIVATION_AMOUNT);\n\n        // No need for SafeMath: we already checked values above\n        uint256 futureActiveBalance = unlockedActiveBalance - amountToDeactivate;\n        uint256 minActiveBalance = _getMinActiveBalance(termId);\n        require(futureActiveBalance == 0 || futureActiveBalance >= minActiveBalance, ERROR_INVALID_DEACTIVATION_AMOUNT);\n\n        _createDeactivationRequest(msg.sender, amountToDeactivate);\n    }\n\n    /**\n    * @notice Stake `@tokenAmount(self.token(), _amount)` for the sender to the Court\n    * @param _amount Amount of tokens to be staked\n    * @param _data Optional data that can be used to request the activation of the transferred tokens\n    */\n    function stake(uint256 _amount, bytes calldata _data) external {\n        _stake(msg.sender, msg.sender, _amount, _data);\n    }\n\n    /**\n    * @notice Stake `@tokenAmount(self.token(), _amount)` for `_to` to the Court\n    * @param _to Address to stake an amount of tokens to\n    * @param _amount Amount of tokens to be staked\n    * @param _data Optional data that can be used to request the activation of the transferred tokens\n    */\n    function stakeFor(address _to, uint256 _amount, bytes calldata _data) external {\n        _stake(msg.sender, _to, _amount, _data);\n    }\n\n    /**\n    * @notice Unstake `@tokenAmount(self.token(), _amount)` for `_to` from the Court\n    * @param _amount Amount of tokens to be unstaked\n    * @param _data Optional data is never used by this function, only logged\n    */\n    function unstake(uint256 _amount, bytes calldata _data) external {\n        _unstake(msg.sender, _amount, _data);\n    }\n\n    /**\n    * @dev Callback of approveAndCall, allows staking directly with a transaction to the token contract.\n    * @param _from Address making the transfer\n    * @param _amount Amount of tokens to transfer\n    * @param _token Address of the token\n    * @param _data Optional data that can be used to request the activation of the transferred tokens\n    */\n    function receiveApproval(address _from, uint256 _amount, address _token, bytes calldata _data) external {\n        require(msg.sender == _token && _token == address(jurorsToken), ERROR_TOKEN_APPROVE_NOT_ALLOWED);\n        _stake(_from, _from, _amount, _data);\n    }\n\n    /**\n    * @notice Process a token deactivation requested for `_juror` if there is any\n    * @param _juror Address of the juror to process the deactivation request of\n    */\n    function processDeactivationRequest(address _juror) external {\n        uint64 termId = _ensureCurrentTerm();\n        _processDeactivationRequest(_juror, termId);\n    }\n\n    /**\n    * @notice Assign `@tokenAmount(self.token(), _amount)` to the available balance of `_juror`\n    * @param _juror Juror to add an amount of tokens to\n    * @param _amount Amount of tokens to be added to the available balance of a juror\n    */\n    function assignTokens(address _juror, uint256 _amount) external onlyDisputeManager {\n        if (_amount > 0) {\n            _updateAvailableBalanceOf(_juror, _amount, true);\n            emit JurorTokensAssigned(_juror, _amount);\n        }\n    }\n\n    /**\n    * @notice Burn `@tokenAmount(self.token(), _amount)`\n    * @param _amount Amount of tokens to be burned\n    */\n    function burnTokens(uint256 _amount) external onlyDisputeManager {\n        if (_amount > 0) {\n            _updateAvailableBalanceOf(BURN_ACCOUNT, _amount, true);\n            emit JurorTokensBurned(_amount);\n        }\n    }\n\n    /**\n    * @notice Draft a set of jurors based on given requirements for a term id\n    * @param _params Array containing draft requirements:\n    *        0. bytes32 Term randomness\n    *        1. uint256 Dispute id\n    *        2. uint64  Current term id\n    *        3. uint256 Number of seats already filled\n    *        4. uint256 Number of seats left to be filled\n    *        5. uint64  Number of jurors required for the draft\n    *        6. uint16  Permyriad of the minimum active balance to be locked for the draft\n    *\n    * @return jurors List of jurors selected for the draft\n    * @return length Size of the list of the draft result\n    */\n    function draft(uint256[7] calldata _params) external onlyDisputeManager returns (address[] memory jurors, uint256 length) {\n        DraftParams memory draftParams = _buildDraftParams(_params);\n        jurors = new address[](draftParams.batchRequestedJurors);\n\n        // Jurors returned by the tree multi-sortition may not have enough unlocked active balance to be drafted. Thus,\n        // we compute several sortitions until all the requested jurors are selected. To guarantee a different set of\n        // jurors on each sortition, the iteration number will be part of the random seed to be used in the sortition.\n        // Note that we are capping the number of iterations to avoid an OOG error, which means that this function could\n        // return less jurors than the requested number.\n\n        for (draftParams.iteration = 0;\n             length < draftParams.batchRequestedJurors && draftParams.iteration < MAX_DRAFT_ITERATIONS;\n             draftParams.iteration++\n        ) {\n            (uint256[] memory jurorIds, uint256[] memory activeBalances) = _treeSearch(draftParams);\n\n            for (uint256 i = 0; i < jurorIds.length && length < draftParams.batchRequestedJurors; i++) {\n                // We assume the selected jurors are registered in the registry, we are not checking their addresses exist\n                address jurorAddress = jurorsAddressById[jurorIds[i]];\n                Juror storage juror = jurorsByAddress[jurorAddress];\n\n                // Compute new locked balance for a juror based on the penalty applied when being drafted\n                uint256 newLockedBalance = juror.lockedBalance.add(draftParams.draftLockAmount);\n\n                // Check if there is any deactivation requests for the next term. Drafts are always computed for the current term\n                // but we have to make sure we are locking an amount that will exist in the next term.\n                uint256 nextTermDeactivationRequestAmount = _deactivationRequestedAmountForTerm(juror, draftParams.termId + 1);\n\n                // Check if juror has enough active tokens to lock the requested amount for the draft, skip it otherwise.\n                uint256 currentActiveBalance = activeBalances[i];\n                if (currentActiveBalance >= newLockedBalance) {\n\n                    // Check if the amount of active tokens for the next term is enough to lock the required amount for\n                    // the draft. Otherwise, reduce the requested deactivation amount of the next term.\n                    // Next term deactivation amount should always be less than current active balance, but we make sure using SafeMath\n                    uint256 nextTermActiveBalance = currentActiveBalance.sub(nextTermDeactivationRequestAmount);\n                    if (nextTermActiveBalance < newLockedBalance) {\n                        // No need for SafeMath: we already checked values above\n                        _reduceDeactivationRequest(jurorAddress, newLockedBalance - nextTermActiveBalance, draftParams.termId);\n                    }\n\n                    // Update the current active locked balance of the juror\n                    juror.lockedBalance = newLockedBalance;\n                    jurors[length++] = jurorAddress;\n                    emit JurorBalanceLocked(jurorAddress, draftParams.draftLockAmount);\n                }\n            }\n        }\n    }\n\n    /**\n    * @notice Slash a set of jurors based on their votes compared to the winning ruling. This function will unlock the\n    *         corresponding locked balances of those jurors that are set to be slashed.\n    * @param _termId Current term id\n    * @param _jurors List of juror addresses to be slashed\n    * @param _lockedAmounts List of amounts locked for each corresponding juror that will be either slashed or returned\n    * @param _rewardedJurors List of booleans to tell whether a juror's active balance has to be slashed or not\n    * @return Total amount of slashed tokens\n    */\n    function slashOrUnlock(uint64 _termId, address[] calldata _jurors, uint256[] calldata _lockedAmounts, bool[] calldata _rewardedJurors)\n        external\n        onlyDisputeManager\n        returns (uint256)\n    {\n        require(_jurors.length == _lockedAmounts.length, ERROR_INVALID_LOCKED_AMOUNTS_LENGTH);\n        require(_jurors.length == _rewardedJurors.length, ERROR_INVALID_REWARDED_JURORS_LENGTH);\n\n        uint64 nextTermId = _termId + 1;\n        uint256 collectedTokens;\n\n        for (uint256 i = 0; i < _jurors.length; i++) {\n            uint256 lockedAmount = _lockedAmounts[i];\n            address jurorAddress = _jurors[i];\n            Juror storage juror = jurorsByAddress[jurorAddress];\n            juror.lockedBalance = juror.lockedBalance.sub(lockedAmount);\n\n            // Slash juror if requested. Note that there's no need to check if there was a deactivation\n            // request since we're working with already locked balances.\n            if (_rewardedJurors[i]) {\n                emit JurorBalanceUnlocked(jurorAddress, lockedAmount);\n            } else {\n                collectedTokens = collectedTokens.add(lockedAmount);\n                tree.update(juror.id, nextTermId, lockedAmount, false);\n                emit JurorSlashed(jurorAddress, lockedAmount, nextTermId);\n            }\n        }\n\n        return collectedTokens;\n    }\n\n    /**\n    * @notice Try to collect `@tokenAmount(self.token(), _amount)` from `_juror` for the term #`_termId + 1`.\n    * @dev This function tries to decrease the active balance of a juror for the next term based on the requested\n    *      amount. It can be seen as a way to early-slash a juror's active balance.\n    * @param _juror Juror to collect the tokens from\n    * @param _amount Amount of tokens to be collected from the given juror and for the requested term id\n    * @param _termId Current term id\n    * @return True if the juror has enough unlocked tokens to be collected for the requested term, false otherwise\n    */\n    function collectTokens(address _juror, uint256 _amount, uint64 _termId) external onlyDisputeManager returns (bool) {\n        if (_amount == 0) {\n            return true;\n        }\n\n        uint64 nextTermId = _termId + 1;\n        Juror storage juror = jurorsByAddress[_juror];\n        uint256 unlockedActiveBalance = _lastUnlockedActiveBalanceOf(juror);\n        uint256 nextTermDeactivationRequestAmount = _deactivationRequestedAmountForTerm(juror, nextTermId);\n\n        // Check if the juror has enough unlocked tokens to collect the requested amount\n        // Note that we're also considering the deactivation request if there is any\n        uint256 totalUnlockedActiveBalance = unlockedActiveBalance.add(nextTermDeactivationRequestAmount);\n        if (_amount > totalUnlockedActiveBalance) {\n            return false;\n        }\n\n        // Check if the amount of active tokens is enough to collect the requested amount, otherwise reduce the requested deactivation amount of\n        // the next term. Note that this behaviour is different to the one when drafting jurors since this function is called as a side effect\n        // of a juror deliberately voting in a final round, while drafts occur randomly.\n        if (_amount > unlockedActiveBalance) {\n            // No need for SafeMath: amounts were already checked above\n            uint256 amountToReduce = _amount - unlockedActiveBalance;\n            _reduceDeactivationRequest(_juror, amountToReduce, _termId);\n        }\n        tree.update(juror.id, nextTermId, _amount, false);\n\n        emit JurorTokensCollected(_juror, _amount, nextTermId);\n        return true;\n    }\n\n    /**\n    * @notice Lock `_juror`'s withdrawals until term #`_termId`\n    * @dev This is intended for jurors who voted in a final round and were coherent with the final ruling to prevent 51% attacks\n    * @param _juror Address of the juror to be locked\n    * @param _termId Term ID until which the juror's withdrawals will be locked\n    */\n    function lockWithdrawals(address _juror, uint64 _termId) external onlyDisputeManager {\n        Juror storage juror = jurorsByAddress[_juror];\n        juror.withdrawalsLockTermId = _termId;\n    }\n\n    /**\n    * @notice Set new limit of total active balance of juror tokens\n    * @param _totalActiveBalanceLimit New limit of total active balance of juror tokens\n    */\n    function setTotalActiveBalanceLimit(uint256 _totalActiveBalanceLimit) external onlyConfigGovernor {\n        _setTotalActiveBalanceLimit(_totalActiveBalanceLimit);\n    }\n\n    /**\n    * @dev ERC900 - Tell the address of the token used for staking\n    * @return Address of the token used for staking\n    */\n    function token() external view returns (address) {\n        return address(jurorsToken);\n    }\n\n    /**\n    * @dev ERC900 - Tell the total amount of juror tokens held by the registry contract\n    * @return Amount of juror tokens held by the registry contract\n    */\n    function totalStaked() external view returns (uint256) {\n        return jurorsToken.balanceOf(address(this));\n    }\n\n    /**\n    * @dev Tell the total amount of active juror tokens\n    * @return Total amount of active juror tokens\n    */\n    function totalActiveBalance() external view returns (uint256) {\n        return tree.getTotal();\n    }\n\n    /**\n    * @dev Tell the total amount of active juror tokens at the given term id\n    * @param _termId Term ID querying the total active balance for\n    * @return Total amount of active juror tokens at the given term id\n    */\n    function totalActiveBalanceAt(uint64 _termId) external view returns (uint256) {\n        return _totalActiveBalanceAt(_termId);\n    }\n\n    /**\n    * @dev ERC900 - Tell the total amount of tokens of juror. This includes the active balance, the available\n    *      balances, and the pending balance for deactivation. Note that we don't have to include the locked\n    *      balances since these represent the amount of active tokens that are locked for drafts, i.e. these\n    *      are included in the active balance of the juror.\n    * @param _juror Address of the juror querying the total amount of tokens staked of\n    * @return Total amount of tokens of a juror\n    */\n    function totalStakedFor(address _juror) external view returns (uint256) {\n        return _totalStakedFor(_juror);\n    }\n\n    /**\n    * @dev Tell the balance information of a juror\n    * @param _juror Address of the juror querying the balance information of\n    * @return active Amount of active tokens of a juror\n    * @return available Amount of available tokens of a juror\n    * @return locked Amount of active tokens that are locked due to ongoing disputes\n    * @return pendingDeactivation Amount of active tokens that were requested for deactivation\n    */\n    function balanceOf(address _juror) external view returns (uint256 active, uint256 available, uint256 locked, uint256 pendingDeactivation) {\n        return _balanceOf(_juror);\n    }\n\n    /**\n    * @dev Tell the balance information of a juror, fecthing tree one at a given term\n    * @param _juror Address of the juror querying the balance information of\n    * @param _termId Term ID querying the active balance for\n    * @return active Amount of active tokens of a juror\n    * @return available Amount of available tokens of a juror\n    * @return locked Amount of active tokens that are locked due to ongoing disputes\n    * @return pendingDeactivation Amount of active tokens that were requested for deactivation\n    */\n    function balanceOfAt(address _juror, uint64 _termId) external view\n        returns (uint256 active, uint256 available, uint256 locked, uint256 pendingDeactivation)\n    {\n        Juror storage juror = jurorsByAddress[_juror];\n\n        active = _existsJuror(juror) ? tree.getItemAt(juror.id, _termId) : 0;\n        (available, locked, pendingDeactivation) = _getBalances(juror);\n    }\n\n    /**\n    * @dev Tell the active balance of a juror for a given term id\n    * @param _juror Address of the juror querying the active balance of\n    * @param _termId Term ID querying the active balance for\n    * @return Amount of active tokens for juror in the requested past term id\n    */\n    function activeBalanceOfAt(address _juror, uint64 _termId) external view returns (uint256) {\n        return _activeBalanceOfAt(_juror, _termId);\n    }\n\n    /**\n    * @dev Tell the amount of active tokens of a juror at the last ensured term that are not locked due to ongoing disputes\n    * @param _juror Address of the juror querying the unlocked balance of\n    * @return Amount of active tokens of a juror that are not locked due to ongoing disputes\n    */\n    function unlockedActiveBalanceOf(address _juror) external view returns (uint256) {\n        Juror storage juror = jurorsByAddress[_juror];\n        return _currentUnlockedActiveBalanceOf(juror);\n    }\n\n    /**\n    * @dev Tell the pending deactivation details for a juror\n    * @param _juror Address of the juror whose info is requested\n    * @return amount Amount to be deactivated\n    * @return availableTermId Term in which the deactivated amount will be available\n    */\n    function getDeactivationRequest(address _juror) external view returns (uint256 amount, uint64 availableTermId) {\n        DeactivationRequest storage request = jurorsByAddress[_juror].deactivationRequest;\n        return (request.amount, request.availableTermId);\n    }\n\n    /**\n    * @dev Tell the withdrawals lock term ID for a juror\n    * @param _juror Address of the juror whose info is requested\n    * @return Term ID until which the juror's withdrawals will be locked\n    */\n    function getWithdrawalsLockTermId(address _juror) external view returns (uint64) {\n        return jurorsByAddress[_juror].withdrawalsLockTermId;\n    }\n\n    /**\n    * @dev Tell the identification number associated to a juror address\n    * @param _juror Address of the juror querying the identification number of\n    * @return Identification number associated to a juror address, zero in case it wasn't registered yet\n    */\n    function getJurorId(address _juror) external view returns (uint256) {\n        return jurorsByAddress[_juror].id;\n    }\n\n    /**\n    * @dev Tell the maximum amount of total active balance that can be held in the registry\n    * @return Maximum amount of total active balance that can be held in the registry\n    */\n    function totalJurorsActiveBalanceLimit() external view returns (uint256) {\n        return totalActiveBalanceLimit;\n    }\n\n    /**\n    * @dev ERC900 - Tell if the current registry supports historic information or not\n    * @return Always false\n    */\n    function supportsHistory() external pure returns (bool) {\n        return false;\n    }\n\n    /**\n    * @dev Internal function to activate a given amount of tokens for a juror.\n    *      This function assumes that the given term is the current term and has already been ensured.\n    * @param _juror Address of the juror to activate tokens\n    * @param _amount Amount of juror tokens to be activated\n    * @param _sender Address of the account requesting the activation\n    */\n    function _activateTokens(address _juror, uint256 _amount, address _sender) internal {\n        uint64 termId = _ensureCurrentTerm();\n\n        // Try to clean a previous deactivation request if any\n        _processDeactivationRequest(_juror, termId);\n\n        uint256 availableBalance = jurorsByAddress[_juror].availableBalance;\n        uint256 amountToActivate = _amount == 0 ? availableBalance : _amount;\n        require(amountToActivate > 0, ERROR_INVALID_ZERO_AMOUNT);\n        require(amountToActivate <= availableBalance, ERROR_INVALID_ACTIVATION_AMOUNT);\n\n        uint64 nextTermId = termId + 1;\n        _checkTotalActiveBalance(nextTermId, amountToActivate);\n        Juror storage juror = jurorsByAddress[_juror];\n        uint256 minActiveBalance = _getMinActiveBalance(nextTermId);\n\n        if (_existsJuror(juror)) {\n            // Even though we are adding amounts, let's check the new active balance is greater than or equal to the\n            // minimum active amount. Note that the juror might have been slashed.\n            uint256 activeBalance = tree.getItem(juror.id);\n            require(activeBalance.add(amountToActivate) >= minActiveBalance, ERROR_ACTIVE_BALANCE_BELOW_MIN);\n            tree.update(juror.id, nextTermId, amountToActivate, true);\n        } else {\n            require(amountToActivate >= minActiveBalance, ERROR_ACTIVE_BALANCE_BELOW_MIN);\n            juror.id = tree.insert(nextTermId, amountToActivate);\n            jurorsAddressById[juror.id] = _juror;\n        }\n\n        _updateAvailableBalanceOf(_juror, amountToActivate, false);\n        emit JurorActivated(_juror, nextTermId, amountToActivate, _sender);\n    }\n\n    /**\n    * @dev Internal function to create a token deactivation request for a juror. Jurors will be allowed\n    *      to process a deactivation request from the next term.\n    * @param _juror Address of the juror to create a token deactivation request for\n    * @param _amount Amount of juror tokens requested for deactivation\n    */\n    function _createDeactivationRequest(address _juror, uint256 _amount) internal {\n        uint64 termId = _ensureCurrentTerm();\n\n        // Try to clean a previous deactivation request if possible\n        _processDeactivationRequest(_juror, termId);\n\n        uint64 nextTermId = termId + 1;\n        Juror storage juror = jurorsByAddress[_juror];\n        DeactivationRequest storage request = juror.deactivationRequest;\n        request.amount = request.amount.add(_amount);\n        request.availableTermId = nextTermId;\n        tree.update(juror.id, nextTermId, _amount, false);\n\n        emit JurorDeactivationRequested(_juror, nextTermId, _amount);\n    }\n\n    /**\n    * @dev Internal function to process a token deactivation requested by a juror. It will move the requested amount\n    *      to the available balance of the juror if the term when the deactivation was requested has already finished.\n    * @param _juror Address of the juror to process the deactivation request of\n    * @param _termId Current term id\n    */\n    function _processDeactivationRequest(address _juror, uint64 _termId) internal {\n        Juror storage juror = jurorsByAddress[_juror];\n        DeactivationRequest storage request = juror.deactivationRequest;\n        uint64 deactivationAvailableTermId = request.availableTermId;\n\n        // If there is a deactivation request, ensure that the deactivation term has been reached\n        if (deactivationAvailableTermId == uint64(0) || _termId < deactivationAvailableTermId) {\n            return;\n        }\n\n        uint256 deactivationAmount = request.amount;\n        // Note that we can use a zeroed term ID to denote void here since we are storing\n        // the minimum allowed term to deactivate tokens which will always be at least 1.\n        request.availableTermId = uint64(0);\n        request.amount = 0;\n        _updateAvailableBalanceOf(_juror, deactivationAmount, true);\n\n        emit JurorDeactivationProcessed(_juror, deactivationAvailableTermId, deactivationAmount, _termId);\n    }\n\n    /**\n    * @dev Internal function to reduce a token deactivation requested by a juror. It assumes the deactivation request\n    *      cannot be processed for the given term yet.\n    * @param _juror Address of the juror to reduce the deactivation request of\n    * @param _amount Amount to be reduced from the current deactivation request\n    * @param _termId Term ID in which the deactivation request is being reduced\n    */\n    function _reduceDeactivationRequest(address _juror, uint256 _amount, uint64 _termId) internal {\n        Juror storage juror = jurorsByAddress[_juror];\n        DeactivationRequest storage request = juror.deactivationRequest;\n        uint256 currentRequestAmount = request.amount;\n        require(currentRequestAmount >= _amount, ERROR_CANNOT_REDUCE_DEACTIVATION_REQUEST);\n\n        // No need for SafeMath: we already checked values above\n        uint256 newRequestAmount = currentRequestAmount - _amount;\n        request.amount = newRequestAmount;\n\n        // Move amount back to the tree\n        tree.update(juror.id, _termId + 1, _amount, true);\n\n        emit JurorDeactivationUpdated(_juror, request.availableTermId, newRequestAmount, _termId);\n    }\n\n    /**\n    * @dev Internal function to stake an amount of tokens for a juror\n    * @param _from Address sending the amount of tokens to be deposited\n    * @param _juror Address of the juror to deposit the tokens to\n    * @param _amount Amount of tokens to be deposited\n    * @param _data Optional data that can be used to request the activation of the deposited tokens\n    */\n    function _stake(address _from, address _juror, uint256 _amount, bytes memory _data) internal {\n        require(_amount > 0, ERROR_INVALID_ZERO_AMOUNT);\n        _updateAvailableBalanceOf(_juror, _amount, true);\n\n        // Activate tokens if it was requested by the sender. Note that there's no need to check\n        // the activation amount since we have just added it to the available balance of the juror.\n        if (_data.toBytes4() == JurorsRegistry(this).activate.selector) {\n            _activateTokens(_juror, _amount, _from);\n        }\n\n        emit Staked(_juror, _amount, _totalStakedFor(_juror), _data);\n        require(jurorsToken.safeTransferFrom(_from, address(this), _amount), ERROR_TOKEN_TRANSFER_FAILED);\n    }\n\n    /**\n    * @dev Internal function to unstake an amount of tokens of a juror\n    * @param _juror Address of the juror to to unstake the tokens of\n    * @param _amount Amount of tokens to be unstaked\n    * @param _data Optional data is never used by this function, only logged\n    */\n    function _unstake(address _juror, uint256 _amount, bytes memory _data) internal {\n        require(_amount > 0, ERROR_INVALID_ZERO_AMOUNT);\n\n        // Try to process a deactivation request for the current term if there is one. Note that we don't need to ensure\n        // the current term this time since deactivation requests always work with future terms, which means that if\n        // the current term is outdated, it will never match the deactivation term id. We avoid ensuring the term here\n        // to avoid forcing jurors to do that in order to withdraw their available balance. Same applies to final round locks.\n        uint64 lastEnsuredTermId = _getLastEnsuredTermId();\n\n        // Check that juror's withdrawals are not locked\n        uint64 withdrawalsLockTermId = jurorsByAddress[_juror].withdrawalsLockTermId;\n        require(withdrawalsLockTermId == 0 || withdrawalsLockTermId < lastEnsuredTermId, ERROR_WITHDRAWALS_LOCK);\n\n        _processDeactivationRequest(_juror, lastEnsuredTermId);\n\n        _updateAvailableBalanceOf(_juror, _amount, false);\n        emit Unstaked(_juror, _amount, _totalStakedFor(_juror), _data);\n        require(jurorsToken.safeTransfer(_juror, _amount), ERROR_TOKEN_TRANSFER_FAILED);\n    }\n\n    /**\n    * @dev Internal function to update the available balance of a juror\n    * @param _juror Juror to update the available balance of\n    * @param _amount Amount of tokens to be added to or removed from the available balance of a juror\n    * @param _positive True if the given amount should be added, or false to remove it from the available balance\n    */\n    function _updateAvailableBalanceOf(address _juror, uint256 _amount, bool _positive) internal {\n        // We are not using a require here to avoid reverting in case any of the treasury maths reaches this point\n        // with a zeroed amount value. Instead, we are doing this validation in the external entry points such as\n        // stake, unstake, activate, deactivate, among others.\n        if (_amount == 0) {\n            return;\n        }\n\n        Juror storage juror = jurorsByAddress[_juror];\n        if (_positive) {\n            juror.availableBalance = juror.availableBalance.add(_amount);\n        } else {\n            require(_amount <= juror.availableBalance, ERROR_NOT_ENOUGH_AVAILABLE_BALANCE);\n            // No need for SafeMath: we already checked values right above\n            juror.availableBalance -= _amount;\n        }\n    }\n\n    /**\n    * @dev Internal function to set new limit of total active balance of juror tokens\n    * @param _totalActiveBalanceLimit New limit of total active balance of juror tokens\n    */\n    function _setTotalActiveBalanceLimit(uint256 _totalActiveBalanceLimit) internal {\n        require(_totalActiveBalanceLimit > 0, ERROR_BAD_TOTAL_ACTIVE_BALANCE_LIMIT);\n        emit TotalActiveBalanceLimitChanged(totalActiveBalanceLimit, _totalActiveBalanceLimit);\n        totalActiveBalanceLimit = _totalActiveBalanceLimit;\n    }\n\n    /**\n    * @dev Internal function to tell the total amount of tokens of juror\n    * @param _juror Address of the juror querying the total amount of tokens staked of\n    * @return Total amount of tokens of a juror\n    */\n    function _totalStakedFor(address _juror) internal view returns (uint256) {\n        (uint256 active, uint256 available, , uint256 pendingDeactivation) = _balanceOf(_juror);\n        return available.add(active).add(pendingDeactivation);\n    }\n\n    /**\n    * @dev Internal function to tell the balance information of a juror\n    * @param _juror Address of the juror querying the balance information of\n    * @return active Amount of active tokens of a juror\n    * @return available Amount of available tokens of a juror\n    * @return locked Amount of active tokens that are locked due to ongoing disputes\n    * @return pendingDeactivation Amount of active tokens that were requested for deactivation\n    */\n    function _balanceOf(address _juror) internal view returns (uint256 active, uint256 available, uint256 locked, uint256 pendingDeactivation) {\n        Juror storage juror = jurorsByAddress[_juror];\n\n        active = _existsJuror(juror) ? tree.getItem(juror.id) : 0;\n        (available, locked, pendingDeactivation) = _getBalances(juror);\n    }\n\n    /**\n    * @dev Tell the active balance of a juror for a given term id\n    * @param _juror Address of the juror querying the active balance of\n    * @param _termId Term ID querying the active balance for\n    * @return Amount of active tokens for juror in the requested past term id\n    */\n    function _activeBalanceOfAt(address _juror, uint64 _termId) internal view returns (uint256) {\n        Juror storage juror = jurorsByAddress[_juror];\n        return _existsJuror(juror) ? tree.getItemAt(juror.id, _termId) : 0;\n    }\n\n    /**\n    * @dev Internal function to get the amount of active tokens of a juror that are not locked due to ongoing disputes\n    *      It will use the last value, that might be in a future term\n    * @param _juror Juror querying the unlocked active balance of\n    * @return Amount of active tokens of a juror that are not locked due to ongoing disputes\n    */\n    function _lastUnlockedActiveBalanceOf(Juror storage _juror) internal view returns (uint256) {\n        return _existsJuror(_juror) ? tree.getItem(_juror.id).sub(_juror.lockedBalance) : 0;\n    }\n\n    /**\n    * @dev Internal function to get the amount of active tokens at the last ensured term of a juror that are not locked due to ongoing disputes\n    * @param _juror Juror querying the unlocked active balance of\n    * @return Amount of active tokens of a juror that are not locked due to ongoing disputes\n    */\n    function _currentUnlockedActiveBalanceOf(Juror storage _juror) internal view returns (uint256) {\n        uint64 lastEnsuredTermId = _getLastEnsuredTermId();\n        return _existsJuror(_juror) ? tree.getItemAt(_juror.id, lastEnsuredTermId).sub(_juror.lockedBalance) : 0;\n    }\n\n    /**\n    * @dev Internal function to check if a juror was already registered\n    * @param _juror Juror to be checked\n    * @return True if the given juror was already registered, false otherwise\n    */\n    function _existsJuror(Juror storage _juror) internal view returns (bool) {\n        return _juror.id != 0;\n    }\n\n    /**\n    * @dev Internal function to get the amount of a deactivation request for a given term id\n    * @param _juror Juror to query the deactivation request amount of\n    * @param _termId Term ID of the deactivation request to be queried\n    * @return Amount of the deactivation request for the given term, 0 otherwise\n    */\n    function _deactivationRequestedAmountForTerm(Juror storage _juror, uint64 _termId) internal view returns (uint256) {\n        DeactivationRequest storage request = _juror.deactivationRequest;\n        return request.availableTermId == _termId ? request.amount : 0;\n    }\n\n    /**\n    * @dev Internal function to tell the total amount of active juror tokens at the given term id\n    * @param _termId Term ID querying the total active balance for\n    * @return Total amount of active juror tokens at the given term id\n    */\n    function _totalActiveBalanceAt(uint64 _termId) internal view returns (uint256) {\n        // This function will return always the same values, the only difference remains on gas costs. In case we look for a\n        // recent term, in this case current or future ones, we perform a backwards linear search from the last checkpoint.\n        // Otherwise, a binary search is computed.\n        bool recent = _termId >= _getLastEnsuredTermId();\n        return recent ? tree.getRecentTotalAt(_termId) : tree.getTotalAt(_termId);\n    }\n\n    /**\n    * @dev Internal function to check if its possible to add a given new amount to the registry or not\n    * @param _termId Term ID when the new amount will be added\n    * @param _amount Amount of tokens willing to be added to the registry\n    */\n    function _checkTotalActiveBalance(uint64 _termId, uint256 _amount) internal view {\n        uint256 currentTotalActiveBalance = _totalActiveBalanceAt(_termId);\n        uint256 newTotalActiveBalance = currentTotalActiveBalance.add(_amount);\n        require(newTotalActiveBalance <= totalActiveBalanceLimit, ERROR_TOTAL_ACTIVE_BALANCE_EXCEEDED);\n    }\n\n    /**\n    * @dev Tell the local balance information of a juror (that is not on the tree)\n    * @param _juror Address of the juror querying the balance information of\n    * @return available Amount of available tokens of a juror\n    * @return locked Amount of active tokens that are locked due to ongoing disputes\n    * @return pendingDeactivation Amount of active tokens that were requested for deactivation\n    */\n    function _getBalances(Juror storage _juror) internal view returns (uint256 available, uint256 locked, uint256 pendingDeactivation) {\n        available = _juror.availableBalance;\n        locked = _juror.lockedBalance;\n        pendingDeactivation = _juror.deactivationRequest.amount;\n    }\n\n    /**\n    * @dev Internal function to search jurors in the tree based on certain search restrictions\n    * @param _params Draft params to be used for the jurors search\n    * @return ids List of juror ids obtained based on the requested search\n    * @return activeBalances List of active balances for each juror obtained based on the requested search\n    */\n    function _treeSearch(DraftParams memory _params) internal view returns (uint256[] memory ids, uint256[] memory activeBalances) {\n        (ids, activeBalances) = tree.batchedRandomSearch(\n            _params.termRandomness,\n            _params.disputeId,\n            _params.termId,\n            _params.selectedJurors,\n            _params.batchRequestedJurors,\n            _params.roundRequestedJurors,\n            _params.iteration\n        );\n    }\n\n    /**\n    * @dev Private function to parse a certain set given of draft params\n    * @param _params Array containing draft requirements:\n    *        0. bytes32 Term randomness\n    *        1. uint256 Dispute id\n    *        2. uint64  Current term id\n    *        3. uint256 Number of seats already filled\n    *        4. uint256 Number of seats left to be filled\n    *        5. uint64  Number of jurors required for the draft\n    *        6. uint16  Permyriad of the minimum active balance to be locked for the draft\n    *\n    * @return Draft params object parsed\n    */\n    function _buildDraftParams(uint256[7] memory _params) private view returns (DraftParams memory) {\n        uint64 termId = uint64(_params[2]);\n        uint256 minActiveBalance = _getMinActiveBalance(termId);\n\n        return DraftParams({\n            termRandomness: bytes32(_params[0]),\n            disputeId: _params[1],\n            termId: termId,\n            selectedJurors: _params[3],\n            batchRequestedJurors: _params[4],\n            roundRequestedJurors: _params[5],\n            draftLockAmount: minActiveBalance.pct(uint16(_params[6])),\n            iteration: 0\n        });\n    }\n}\n"
    },
    "contracts/standards/ERC900.sol": {
      "content": "pragma solidity ^0.5.8;\n\n\n// Interface for ERC900: https://eips.ethereum.org/EIPS/eip-900\ninterface ERC900 {\n    event Staked(address indexed user, uint256 amount, uint256 total, bytes data);\n    event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);\n\n    /**\n    * @dev Stake a certain amount of tokens\n    * @param _amount Amount of tokens to be staked\n    * @param _data Optional data that can be used to add signalling information in more complex staking applications\n    */\n    function stake(uint256 _amount, bytes calldata _data) external;\n\n    /**\n    * @dev Stake a certain amount of tokens in favor of someone\n    * @param _user Address to stake an amount of tokens to\n    * @param _amount Amount of tokens to be staked\n    * @param _data Optional data that can be used to add signalling information in more complex staking applications\n    */\n    function stakeFor(address _user, uint256 _amount, bytes calldata _data) external;\n\n    /**\n    * @dev Unstake a certain amount of tokens\n    * @param _amount Amount of tokens to be unstaked\n    * @param _data Optional data that can be used to add signalling information in more complex staking applications\n    */\n    function unstake(uint256 _amount, bytes calldata _data) external;\n\n    /**\n    * @dev Tell the total amount of tokens staked for an address\n    * @param _addr Address querying the total amount of tokens staked for\n    * @return Total amount of tokens staked for an address\n    */\n    function totalStakedFor(address _addr) external view returns (uint256);\n\n    /**\n    * @dev Tell the total amount of tokens staked\n    * @return Total amount of tokens staked\n    */\n    function totalStaked() external view returns (uint256);\n\n    /**\n    * @dev Tell the address of the token used for staking\n    * @return Address of the token used for staking\n    */\n    function token() external view returns (address);\n\n    /*\n    * @dev Tell if the current registry supports historic information or not\n    * @return True if the optional history functions are implemented, false otherwise\n    */\n    function supportsHistory() external pure returns (bool);\n}\n"
    },
    "contracts/standards/ApproveAndCall.sol": {
      "content": "pragma solidity ^0.5.8;\n\n\ninterface ApproveAndCallFallBack {\n    /**\n    * @dev This allows users to use their tokens to interact with contracts in one function call instead of two\n    * @param _from Address of the account transferring the tokens\n    * @param _amount The amount of tokens approved for in the transfer\n    * @param _token Address of the token contract calling this function\n    * @param _data Optional data that can be used to add signalling information in more complex staking applications\n    */\n    function receiveApproval(address _from, uint256 _amount, address _token, bytes calldata _data) external;\n}\n"
    },
    "contracts/subscriptions/CourtSubscriptions.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../lib/os/ERC20.sol\";\nimport \"../lib/os/SafeMath.sol\";\nimport \"../lib/os/SafeMath64.sol\";\nimport \"../lib/os/SafeERC20.sol\";\nimport \"../lib/os/TimeHelpers.sol\";\n\nimport \"./ISubscriptions.sol\";\nimport \"./IAragonAppFeesCashier.sol\";\nimport \"../lib/PctHelpers.sol\";\nimport \"../registry/IJurorsRegistry.sol\";\nimport \"../court/controller/Controller.sol\";\nimport \"../court/controller/ControlledRecoverable.sol\";\n\n\ncontract CourtSubscriptions is ControlledRecoverable, TimeHelpers, ISubscriptions, IAragonAppFeesCashier {\n    using SafeERC20 for ERC20;\n    using SafeMath for uint256;\n    using SafeMath64 for uint64;\n    using PctHelpers for uint256;\n\n    string private constant ERROR_GOVERNOR_SHARE_FEES_ZERO = \"CS_GOVERNOR_SHARE_FEES_ZERO\";\n    string private constant ERROR_TOKEN_DEPOSIT_FAILED = \"CS_TOKEN_DEPOSIT_FAILED\";\n    string private constant ERROR_TOKEN_TRANSFER_FAILED = \"CS_TOKEN_TRANSFER_FAILED\";\n    string private constant ERROR_PERIOD_DURATION_ZERO = \"CS_PERIOD_DURATION_ZERO\";\n    string private constant ERROR_FEE_TOKEN_NOT_CONTRACT = \"CS_FEE_TOKEN_NOT_CONTRACT\";\n    string private constant ERROR_OVERRATED_GOVERNOR_SHARE_PCT = \"CS_OVERRATED_GOVERNOR_SHARE_PCT\";\n    string private constant ERROR_NON_PAST_PERIOD = \"CS_NON_PAST_PERIOD\";\n    string private constant ERROR_JUROR_FEES_ALREADY_CLAIMED = \"CS_JUROR_FEES_ALREADY_CLAIMED\";\n    string private constant ERROR_JUROR_NOTHING_TO_CLAIM = \"CS_JUROR_NOTHING_TO_CLAIM\";\n    string private constant ERROR_DONATION_AMOUNT_ZERO = \"CS_DONATION_AMOUNT_ZERO\";\n    string private constant ERROR_COURT_HAS_NOT_STARTED = \"CS_COURT_HAS_NOT_STARTED\";\n    string private constant ERROR_APP_FEE_NOT_SET = \"CS_APP_FEE_NOT_SET\";\n    string private constant ERROR_ETH_APP_FEES_NOT_SUPPORTED = \"CS_ETH_APP_FEES_NOT_SUPPORTED\";\n    string private constant ERROR_WRONG_TOKEN = \"CS_WRONG_TOKEN\";\n    string private constant ERROR_WRONG_TOKENS_LENGTH = \"CS_WRONG_TOKENS_LENGTH\";\n    string private constant ERROR_WRONG_AMOUNTS_LENGTH = \"CS_WRONG_AMOUNTS_LENGTH\";\n\n    // Term 0 is for jurors on-boarding\n    uint64 internal constant START_TERM_ID = 1;\n\n    struct Period {\n        uint64 balanceCheckpoint;               // Court term ID of a period used to fetch the total active balance of the jurors registry\n        ERC20 feeToken;                         // Fee token used for the subscription fees corresponding to a certain period\n        uint256 totalActiveBalance;             // Total amount of juror tokens active in the Court at the corresponding period checkpoint\n        uint256 collectedFees;                  // Total amount of subscription fees collected during a period\n        uint256 accumulatedGovernorFees;        // Total amount of fees accumulated for the governor of the Court during a period\n        mapping (address => bool) claimedFees;  // List of jurors that have claimed fees during a period, indexed by juror address\n    }\n\n    // Duration of a subscription period in Court terms\n    uint64 public periodDuration;\n\n    // Permyriad of subscription fees that will be allocated to the governor of the Court (‱ - 1/10,000)\n    uint16 public governorSharePct;\n\n    // ERC20 token used for the subscription fees\n    ERC20 public currentFeeToken;\n\n    // List of periods indexed by ID\n    mapping (uint256 => Period) internal periods;\n\n    // List of app fees indexed by app ID\n    mapping (bytes32 => uint256) internal appFees;\n\n    event FeesDonated(address indexed payer, uint256 indexed periodId, ERC20 feeToken, uint256 feeAmount);\n    event FeesClaimed(address indexed juror, uint256 indexed periodId, ERC20 feeToken, uint256 jurorShare);\n    event GovernorFeesTransferred(ERC20 indexed feeToken, uint256 amount);\n    event FeeTokenChanged(ERC20 previousFeeToken, ERC20 currentFeeToken);\n    event GovernorSharePctChanged(uint16 previousGovernorSharePct, uint16 currentGovernorSharePct);\n\n    /**\n    * @dev Initialize court subscriptions\n    * @param _controller Address of the controller\n    * @param _periodDuration Duration of a subscription period in Court terms\n    * @param _feeToken Initial ERC20 token used for the subscription fees\n    * @param _governorSharePct Initial permyriad of subscription fees that will be allocated to the governor of the Court (‱ - 1/10,000)\n    */\n    constructor(Controller _controller, uint64 _periodDuration, ERC20 _feeToken, uint16 _governorSharePct)\n        ControlledRecoverable(_controller)\n        public\n    {\n        // No need to explicitly call `Controlled` constructor since `ControlledRecoverable` is already doing it\n        require(_periodDuration > 0, ERROR_PERIOD_DURATION_ZERO);\n\n        periodDuration = _periodDuration;\n        _setFeeToken(_feeToken);\n        _setGovernorSharePct(_governorSharePct);\n    }\n\n    /**\n    * @notice Donate fees to the Court\n    * @param _amount Amount of fee tokens to be donated\n    */\n    function donate(uint256 _amount) external payable {\n        require(_amount > 0, ERROR_DONATION_AMOUNT_ZERO);\n\n        // Ensure fee token data for the current period\n        (uint256 currentPeriodId, Period storage period, ERC20 feeToken) = _ensureCurrentPeriodFeeToken();\n\n        // Update collected fees for the jurors\n        period.collectedFees = period.collectedFees.add(_amount);\n\n        // Deposit fee tokens from sender to this contract\n        _deposit(msg.sender, feeToken, _amount);\n        emit FeesDonated(msg.sender, currentPeriodId, feeToken, _amount);\n    }\n\n    /**\n    * @notice Claim proportional share fees for period `_periodId` owed to `msg.sender`\n    * @param _periodId Identification number of the period which fees are claimed for\n    */\n    function claimFees(uint256 _periodId) external {\n        require(_periodId < _getCurrentPeriodId(), ERROR_NON_PAST_PERIOD);\n        Period storage period = periods[_periodId];\n\n        require(!period.claimedFees[msg.sender], ERROR_JUROR_FEES_ALREADY_CLAIMED);\n\n        // Check claiming juror has share fees to be transferred\n        (uint64 periodBalanceCheckpoint, uint256 totalActiveBalance) = _ensurePeriodBalanceDetails(_periodId, period);\n        uint256 jurorShare = _getJurorShare(msg.sender, period, periodBalanceCheckpoint, totalActiveBalance);\n        require(jurorShare > 0, ERROR_JUROR_NOTHING_TO_CLAIM);\n\n        // Update juror state and transfer share fees\n        period.claimedFees[msg.sender] = true;\n        ERC20 feeToken = _ensurePeriodFeeToken(period);\n        _transfer(msg.sender, feeToken, jurorShare);\n        emit FeesClaimed(msg.sender, _periodId, feeToken, jurorShare);\n    }\n\n    /**\n    * @notice Transfer owed fees to the governor for the current period\n    */\n    function transferCurrentPeriodFeesToGovernor() external {\n        (, Period storage period) = _getCurrentPeriod();\n        _transferFeesToGovernor(period);\n    }\n\n    /**\n    * @notice Transfer owed fees to the governor\n    * @param _periodId Identification number of the period for accumulated fees\n    */\n    function transferFeesToGovernor(uint256 _periodId) external {\n        require(_periodId <= _getCurrentPeriodId(), ERROR_NON_PAST_PERIOD);\n        Period storage period = periods[_periodId];\n        _transferFeesToGovernor(period);\n    }\n\n    /**\n    * @notice Make sure that the balance details of a certain period have been computed\n    * @param _periodId Identification number of the period being ensured\n    * @return periodBalanceCheckpoint Court term ID used to fetch the total active balance of the jurors registry\n    * @return totalActiveBalance Total amount of juror tokens active in the Court at the corresponding used checkpoint\n    */\n    function ensurePeriodBalanceDetails(uint256 _periodId) external returns (uint64 periodBalanceCheckpoint, uint256 totalActiveBalance) {\n        require(_periodId < _getCurrentPeriodId(), ERROR_NON_PAST_PERIOD);\n        Period storage period = periods[_periodId];\n        return _ensurePeriodBalanceDetails(_periodId, period);\n    }\n\n    /**\n    * @notice Set subscriptions fee token to `_feeToken`\n    * @param _feeToken New ERC20 token to be used for the subscription fees\n    */\n    function setFeeToken(ERC20 _feeToken) external onlyConfigGovernor {\n        // If the court has started, ensure the fee token is set for the current period before changing it\n        if (_getCurrentTermId() > 0) {\n            (, Period storage period) = _getCurrentPeriod();\n            _ensurePeriodFeeToken(period);\n        }\n\n        _setFeeToken(_feeToken);\n    }\n\n    /**\n    * @notice Set new governor share to `_governorSharePct`‱ (1/10,000)\n    * @param _governorSharePct New permyriad of subscription fees that will be allocated to the governor of the Court (‱ - 1/10,000)\n    */\n    function setGovernorSharePct(uint16 _governorSharePct) external onlyConfigGovernor {\n        _setGovernorSharePct(_governorSharePct);\n    }\n\n    // IAragonAppFeesCashier interface\n\n    /**\n    * @notice Set fees for app with id `_appId` to @tokenAmount(`_token`, `_amount`)\n    * @param _appId Id of the app\n    * @param _token Token for the fee, must be the same as the current period one\n    * @param _amount Amount of fee tokens. The change applies immediately.\n    */\n    function setAppFee(bytes32 _appId, ERC20 _token, uint256 _amount) external onlyConfigGovernor {\n        // Ensure fee token data for the current period\n        (,, ERC20 feeToken) = _ensureCurrentPeriodFeeToken();\n        require(_token == feeToken, ERROR_WRONG_TOKEN);\n\n        _setAppFee(_appId, feeToken, _amount);\n    }\n\n    /**\n    * @notice Set fees for apps with ids `_appIds`\n    * @param _appIds Id of the apps\n    * @param _tokens Token for the fees for each app (must be an empty array, as we are using the global token)\n    * @param _amounts Amount of fee tokens for each app. The change applies immediately.\n    */\n    function setAppFees(bytes32[] calldata _appIds, ERC20[] calldata _tokens, uint256[] calldata _amounts) external onlyConfigGovernor {\n        require(_tokens.length == 0, ERROR_WRONG_TOKENS_LENGTH);\n        require(_appIds.length == _amounts.length, ERROR_WRONG_AMOUNTS_LENGTH);\n\n        // Ensure fee token data for the current period\n        (,, ERC20 feeToken) = _ensureCurrentPeriodFeeToken();\n\n        for (uint256 i = 0; i < _appIds.length; i++) {\n            _setAppFee(_appIds[i], feeToken, _amounts[i]);\n        }\n    }\n\n    /**\n    * @notice Unset fees for app with id `_appId`\n    * @param _appId Id of the app\n    */\n    function unsetAppFee(bytes32 _appId) external onlyConfigGovernor {\n        _unsetAppFee(_appId);\n    }\n\n    /**\n    * @notice Unset fees for apps with ids `_appIds`\n    * @param _appIds Ids of the apps\n    */\n    function unsetAppFees(bytes32[] calldata _appIds) external onlyConfigGovernor {\n        for (uint256 i = 0; i < _appIds.length; i++) {\n            _unsetAppFee(_appIds[i]);\n        }\n    }\n\n    /**\n    * @notice Pay fees corresponding to a new action in app with id `appId`\n    * @dev To be called by the eventual dispute creator (usually an IArbitrable). If a fee is defined, it requires the sender to have pre-approved tokens.\n           We expect the caller to submit the correct appId here, and leave it to jurors to verify that the correct fees were paid ahead of disputes.\n    * @param _appId Id of the app paying fees for\n    * @param _data Extra data for context of the payment\n    */\n    function payAppFees(bytes32 _appId, bytes calldata _data) external payable {\n        // Ensure fee token data for the current period\n        (,Period storage period, ERC20 feeToken) = _ensureCurrentPeriodFeeToken();\n        require(msg.value == 0, ERROR_ETH_APP_FEES_NOT_SUPPORTED);\n\n        // Fetch current fee amount for the given app ID\n        uint256 feeAmount = appFees[_appId];\n        if (feeAmount > 0) {\n            // Compute the portion of the total amount to pay that will be allocated to the governor\n            uint256 governorFee = feeAmount.pct(governorSharePct);\n            period.accumulatedGovernorFees = period.accumulatedGovernorFees.add(governorFee);\n\n            // Update collected fees for the jurors\n            uint256 collectedFees = feeAmount.sub(governorFee);\n            period.collectedFees = period.collectedFees.add(collectedFees);\n\n            // Deposit fee tokens from sender to this contract\n            _deposit(msg.sender, feeToken, feeAmount);\n        }\n\n        emit AppFeePaid(msg.sender, _appId, _data);\n    }\n\n    /**\n    * @dev Tell whether a certain subscriber has paid all the fees up to current period or not\n    * @return Always true. Previously we were using monthly subscriptions but this \"off-chain verified\" fee model removes the concept of a monthly fee.\n    */\n    function isUpToDate(address /*_subscriber*/) external view returns (bool) {\n        return true;\n    }\n\n    /**\n    * @dev Tell the identification number of the current period\n    * @return Identification number of the current period\n    */\n    function getCurrentPeriodId() external view returns (uint256) {\n        return _getCurrentPeriodId();\n    }\n\n    /**\n    * @dev Get details of the current period\n    * @return feeToken Fee token corresponding to a certain period\n    * @return balanceCheckpoint Court term ID of a period used to fetch the total active balance of the jurors registry\n    * @return totalActiveBalance Total amount of juror tokens active in the Court at the corresponding period checkpoint\n    * @return collectedFees Total amount of subscription fees collected during a period\n    * @return accumulatedGovernorFees Total amount of fees accumulated for the governor of the Court during a period\n    */\n    function getPeriod(uint256 _periodId)\n        external\n        view\n        returns (\n            ERC20 feeToken,\n            uint64 balanceCheckpoint,\n            uint256 totalActiveBalance,\n            uint256 collectedFees,\n            uint256 accumulatedGovernorFees\n        )\n    {\n        Period storage period = periods[_periodId];\n\n        feeToken = period.feeToken;\n        balanceCheckpoint = period.balanceCheckpoint;\n        totalActiveBalance = period.totalActiveBalance;\n        collectedFees = period.collectedFees;\n        accumulatedGovernorFees = period.accumulatedGovernorFees;\n    }\n\n    /**\n    * @dev Tell the minimum amount of fees to pay and resulting last paid period for a given subscriber in order to be up-to-date\n    * @return feeToken ERC20 token used for the subscription fees\n    * @return amountToPay Amount of subscription fee tokens to be paid for all the owed periods\n    * @return newLastPeriodId Identification number of the resulting last paid period\n    */\n    function getOwedFeesDetails(address /*_subscriber*/) external view returns (ERC20 feeToken, uint256 amountToPay, uint256 newLastPeriodId) {\n        (uint256 periodId, Period storage period) = _getCurrentPeriod();\n\n        // Subscription fees were deprecated, this module now only implements app action fees.\n        // However, we still need to support this view function to be compliant with the AragonCourt's IArbitrator implementation.\n        // Therefore, we simply say that all subscribers do not owe subscription payments.\n\n        feeToken = _getEnsuredPeriodFeeToken(period);\n        amountToPay = 0;\n        newLastPeriodId = periodId;\n    }\n\n    /**\n    * @dev Tell the share fees corresponding to a juror for a certain period\n    * @param _juror Address of the juror querying the owed shared fees of\n    * @param _periodId Identification number of the period being queried\n    * @return feeToken Address of the token used for the subscription fees\n    * @return jurorShare Amount of share fees owed to the given juror for the requested period\n    */\n    function getJurorShare(address _juror, uint256 _periodId) external view returns (ERC20 feeToken, uint256 jurorShare) {\n        require(_periodId < _getCurrentPeriodId(), ERROR_NON_PAST_PERIOD);\n        Period storage period = periods[_periodId];\n\n        uint64 periodBalanceCheckpoint;\n        uint256 totalActiveBalance = period.totalActiveBalance;\n\n        // Compute period balance details if they were not ensured yet\n        if (totalActiveBalance == 0) {\n            (periodBalanceCheckpoint, totalActiveBalance) = _getPeriodBalanceDetails(_periodId);\n        } else {\n            periodBalanceCheckpoint = period.balanceCheckpoint;\n        }\n\n        // Compute juror share fees using the period balance details\n        jurorShare = _getJurorShare(_juror, period, periodBalanceCheckpoint, totalActiveBalance);\n        feeToken = _getEnsuredPeriodFeeToken(period);\n    }\n\n    /**\n    * @dev Check if a given juror has already claimed the owed share fees for a certain period\n    * @param _juror Address of the juror being queried\n    * @param _periodId Identification number of the period being queried\n    * @return True if the owed share fees have already been claimed, false otherwise\n    */\n    function hasJurorClaimed(address _juror, uint256 _periodId) external view returns (bool) {\n        return periods[_periodId].claimedFees[_juror];\n    }\n\n    /**\n    * @notice Get fees for app with id `_appId`\n    * @param _appId Id of the app\n    * @return ERC20 token for the fees\n    * @return Amount of fee tokens\n    */\n    function getAppFee(bytes32 _appId) external view returns (ERC20 feeToken, uint256 feeAmount) {\n        (, Period storage period) = _getCurrentPeriod();\n        feeToken = _getEnsuredPeriodFeeToken(period);\n        feeAmount = appFees[_appId];\n    }\n\n    /**\n    * @dev Internal function to transfer owed fees to the governor\n    * @param _period Period instance for the accumulated fees\n    */\n    function _transferFeesToGovernor(Period storage _period) internal {\n        uint256 amount = _period.accumulatedGovernorFees;\n        require(amount > 0, ERROR_GOVERNOR_SHARE_FEES_ZERO);\n\n        _period.accumulatedGovernorFees = 0;\n        address payable governor = address(uint160(_configGovernor()));\n        ERC20 feeToken = _ensurePeriodFeeToken(_period);\n        _transfer(governor, feeToken, amount);\n        emit GovernorFeesTransferred(feeToken, amount);\n    }\n\n    /**\n    * @dev Internal function to pull tokens into this contract\n    * @param _from Owner of the deposited funds\n    * @param _token Token to deposit\n    * @param _amount Amount to be deposited\n    */\n    function _deposit(address _from, ERC20 _token, uint256 _amount) internal {\n        if (_amount == 0) {\n            return;\n        }\n\n        require(_token.safeTransferFrom(_from, address(this), _amount), ERROR_TOKEN_DEPOSIT_FAILED);\n    }\n\n    /**\n    * @dev Internal function to transfer tokens\n    * @param _to Recipient of the transfer\n    * @param _token Token to transfer\n    * @param _amount Amount to be transferred\n    */\n    function _transfer(address payable _to, ERC20 _token, uint256 _amount) internal {\n        if (_amount == 0) {\n            return;\n        }\n\n        require(_token.safeTransfer(_to, _amount), ERROR_TOKEN_TRANSFER_FAILED);\n    }\n\n    /**\n    * @dev Internal function to make sure the fee token address and amount are set for the current period\n    * @return periodId Identification number of the current period\n    * @return period Current period instance\n    * @return feeToken ERC20 token to be used for the subscription fees during the given period\n    */\n    function _ensureCurrentPeriodFeeToken() internal returns (uint256 periodId, Period storage period, ERC20 feeToken) {\n        (periodId, period) = _getCurrentPeriod();\n        feeToken = _ensurePeriodFeeToken(period);\n    }\n\n    /**\n    * @dev Internal function to make sure the fee token address and amount are set for a certain period\n    * @param _period Period instance to ensure\n    * @return ERC20 token to be used for the subscription fees during the given period\n    */\n    function _ensurePeriodFeeToken(Period storage _period) internal returns (ERC20) {\n        // Use current fee token address for the given period if these haven't been set yet\n        ERC20 feeToken = _period.feeToken;\n        if (feeToken == ERC20(0)) {\n            feeToken = currentFeeToken;\n            _period.feeToken = feeToken;\n        }\n\n        return feeToken;\n    }\n\n    /**\n    * @dev Internal function to make sure that the balance details of a certain period have been computed. This function assumes given ID and\n    *      period correspond to each other.\n    * @param _periodId Identification number of the period being ensured\n    * @param _period Period being ensured\n    * @return periodBalanceCheckpoint Court term ID used to fetch the total active balance of the jurors registry\n    * @return totalActiveBalance Total amount of juror tokens active in the Court at the corresponding used checkpoint\n    */\n    function _ensurePeriodBalanceDetails(uint256 _periodId, Period storage _period) internal\n        returns (uint64 periodBalanceCheckpoint, uint256 totalActiveBalance)\n    {\n        totalActiveBalance = _period.totalActiveBalance;\n\n        // Set balance details for the given period if these haven't been set yet\n        if (totalActiveBalance == 0) {\n            (periodBalanceCheckpoint, totalActiveBalance) = _getPeriodBalanceDetails(_periodId);\n            _period.balanceCheckpoint = periodBalanceCheckpoint;\n            _period.totalActiveBalance = totalActiveBalance;\n        } else {\n            periodBalanceCheckpoint = _period.balanceCheckpoint;\n        }\n    }\n\n    /**\n    * @dev Internal function to set a new ERC20 token for the subscription fees\n    * @param _feeToken New ERC20 token to be used for the subscription fees\n    */\n    function _setFeeToken(ERC20 _feeToken) internal {\n        require(isContract(address(_feeToken)), ERROR_FEE_TOKEN_NOT_CONTRACT);\n\n        emit FeeTokenChanged(currentFeeToken, _feeToken);\n        currentFeeToken = _feeToken;\n    }\n\n    /**\n    * @dev Internal function to set a new governor share value\n    * @param _governorSharePct New permyriad of subscription fees that will be allocated to the governor of the Court (‱ - 1/10,000)\n    */\n    function _setGovernorSharePct(uint16 _governorSharePct) internal {\n        // Check governor share is not greater than 10,000‱\n        require(PctHelpers.isValid(_governorSharePct), ERROR_OVERRATED_GOVERNOR_SHARE_PCT);\n\n        emit GovernorSharePctChanged(governorSharePct, _governorSharePct);\n        governorSharePct = _governorSharePct;\n    }\n\n    /**\n    * @notice Set fees for app with id `_appId` to `_amount`\n    * @param _appId Id of the app\n    * @param _token Token for the fee, must be the same as the current period one\n    * @param _amount Amount of fee tokens\n    */\n    function _setAppFee(bytes32 _appId, ERC20 _token, uint256 _amount) internal {\n        appFees[_appId] = _amount;\n        emit AppFeeSet(_appId, _token, _amount);\n    }\n\n    /**\n    * @notice Unset fees for app with id `_appId`\n    * @param _appId Id of the app\n    */\n    function _unsetAppFee(bytes32 _appId) internal {\n        require(appFees[_appId] != 0, ERROR_APP_FEE_NOT_SET);\n\n        appFees[_appId] = 0;\n        emit AppFeeUnset(_appId);\n    }\n\n    /**\n    * @dev Internal function to tell the identification number of the current period\n    * @return Identification number of the current period\n    */\n    function _getCurrentPeriodId() internal view returns (uint256) {\n        // Since the Court starts at term #1, and the first subscription period is #0, then subtract one unit to the current term of the Court\n        uint64 termId = _getCurrentTermId();\n        require(termId > 0, ERROR_COURT_HAS_NOT_STARTED);\n\n        // No need for SafeMath: we already checked that the term ID is at least 1\n        uint64 periodId = (termId - START_TERM_ID) / periodDuration;\n        return uint256(periodId);\n    }\n\n    /**\n    * @dev Internal function to get the current period\n    * @return periodId Identification number of the current period\n    * @return period Current period instance\n    */\n    function _getCurrentPeriod() internal view returns (uint256 periodId, Period storage period) {\n        periodId = _getCurrentPeriodId();\n        period = periods[periodId];\n    }\n\n    /**\n    * @dev Internal function to get the Court term in which a certain period starts\n    * @param _periodId Identification number of the period querying the start term of\n    * @return Court term where the given period starts\n    */\n    function _getPeriodStartTermId(uint256 _periodId) internal view returns (uint64) {\n        // Periods are measured in Court terms. Since Court terms are represented in uint64, we are safe to use uint64 for period ids too.\n        // We are using SafeMath here because if any user calls `getPeriodBalanceDetails` for a huge period ID,\n        // it would overflow and therefore return wrong information.\n        return START_TERM_ID.add(uint64(_periodId).mul(periodDuration));\n    }\n\n    /**\n    * @dev Internal function to get the fee token address and amount to be used for a certain period\n    * @param _period Period querying the token address and amount of\n    * @return ERC20 token to be used for the subscription fees during the given period\n    */\n    function _getEnsuredPeriodFeeToken(Period storage _period) internal view returns (ERC20) {\n        // Return current fee token address and amount if these haven't been set for the given period yet\n        ERC20 feeToken = _period.feeToken;\n        return feeToken == ERC20(0) ? currentFeeToken : feeToken;\n    }\n\n    /**\n    * @dev Internal function to get the total active balance of the jurors registry at a random term during a period\n    * @param _periodId Identification number of the period being queried\n    * @return periodBalanceCheckpoint Court term ID used to fetch the total active balance of the jurors registry\n    * @return totalActiveBalance Total amount of juror tokens active in the Court at the corresponding used checkpoint\n    */\n    function _getPeriodBalanceDetails(uint256 _periodId) internal view returns (uint64 periodBalanceCheckpoint, uint256 totalActiveBalance) {\n        uint64 periodStartTermId = _getPeriodStartTermId(_periodId);\n        uint64 nextPeriodStartTermId = _getPeriodStartTermId(_periodId.add(1));\n\n        // Pick a random Court term during the next period of the requested one to get the total amount of juror tokens active in the Court\n        IClock clock = _clock();\n        bytes32 randomness = clock.getTermRandomness(nextPeriodStartTermId);\n\n        // The randomness factor for each Court term is computed using the the hash of a block number set during the initialization of the\n        // term, to ensure it cannot be known beforehand. Note that the hash function being used only works for the 256 most recent block\n        // numbers. Therefore, if that occurs we use the hash of the previous block number. This could be slightly beneficial for the first\n        // juror calling this function, but it's still impossible to predict during the requested period.\n        if (randomness == bytes32(0)) {\n            randomness = blockhash(getBlockNumber() - 1);\n        }\n\n        // Use randomness to choose a Court term of the requested period and query the total amount of juror tokens active at that term\n        IJurorsRegistry jurorsRegistry = _jurorsRegistry();\n        periodBalanceCheckpoint = periodStartTermId.add(uint64(uint256(randomness) % periodDuration));\n        totalActiveBalance = jurorsRegistry.totalActiveBalanceAt(periodBalanceCheckpoint);\n    }\n\n    /**\n    * @dev Internal function to tell the share fees corresponding to a juror for a certain period\n    * @param _juror Address of the juror querying the owed shared fees of\n    * @param _period Period being queried\n    * @param _periodBalanceCheckpoint Court term ID used to fetch the active balance of the juror for the requested period\n    * @param _totalActiveBalance Total amount of juror tokens active in the Court at the corresponding used checkpoint\n    * @return Amount of share fees owed to the given juror for the requested period\n    */\n    function _getJurorShare(address _juror, Period storage _period, uint64 _periodBalanceCheckpoint, uint256 _totalActiveBalance)\n        internal\n        view\n        returns (uint256)\n    {\n        // Fetch juror active balance at the checkpoint used for the requested period\n        IJurorsRegistry jurorsRegistry = _jurorsRegistry();\n        uint256 jurorActiveBalance = jurorsRegistry.activeBalanceOfAt(_juror, _periodBalanceCheckpoint);\n        if (jurorActiveBalance == 0) {\n            return 0;\n        }\n\n        // Note that we already checked the juror active balance is greater than zero, then, the total active balance must be greater than zero.\n        return _period.collectedFees.mul(jurorActiveBalance) / _totalActiveBalance;\n    }\n}\n"
    },
    "contracts/subscriptions/IAragonAppFeesCashier.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../lib/os/ERC20.sol\";\n\n\ninterface IAragonAppFeesCashier {\n    /**\n    * @dev Emitted when an IAragonAppFeesCashier instance sets a new fee for an app\n    * @param appId App identifier\n    * @param token Token address to be used for the fees\n    * @param amount Fee amount to be charged for the given app\n    */\n    event AppFeeSet(bytes32 indexed appId, ERC20 token, uint256 amount);\n\n    /**\n    * @dev Emitted when an IAragonAppFeesCashier instance unsets an app fee\n    * @param appId App identifier\n    */\n    event AppFeeUnset(bytes32 indexed appId);\n\n    /**\n    * @dev Emitted when an IAragonAppFeesCashier instance receives a payment for an app\n    * @param by Address paying the fees\n    * @param appId App identifier\n    * @param data Optional data\n    */\n    event AppFeePaid(address indexed by, bytes32 appId, bytes data);\n\n    /**\n    * @dev Set the fee amount and token to be used for an app\n    * @param _appId App identifier\n    * @param _token Token address to be used for the fees\n    * @param _amount Fee amount to be charged for the given app\n    */\n    function setAppFee(bytes32 _appId, ERC20 _token, uint256 _amount) external;\n\n    /**\n    * @dev Set the fee amount and token to be used for a list of apps\n    * @param _appIds List of app identifiers\n    * @param _tokens List of token addresses to be used for the fees for each app\n    * @param _amounts List of fee amounts to be charged for each app\n    */\n    function setAppFees(bytes32[] calldata _appIds, ERC20[] calldata _tokens, uint256[] calldata _amounts) external;\n\n    /**\n    * @dev Remove the fee set for an app\n    * @param _appId App identifier\n    */\n    function unsetAppFee(bytes32 _appId) external;\n\n    /**\n    * @dev Remove the fee set for a list of apps\n    * @param _appIds List of app identifiers\n    */\n    function unsetAppFees(bytes32[] calldata _appIds) external;\n\n    /**\n    * @dev Pay the fees corresponding to an app\n    * @param _appId App identifier\n    * @param _data Optional data input\n    */\n    function payAppFees(bytes32 _appId, bytes calldata _data) external payable;\n\n    /**\n    * @dev Tell the fee token and amount set for a given app\n    * @param _appId Identifier of the app being queried\n    * @return token Fee token address set for the requested app\n    * @return amount Fee token amount set for the requested app\n    */\n    function getAppFee(bytes32 _appId) external view returns (ERC20 token, uint256 amount);\n}\n"
    },
    "contracts/test/arbitration/ArbitrableMock.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../arbitration/IArbitrable.sol\";\nimport \"../../arbitration/IArbitrator.sol\";\n\n\ncontract ArbitrableMock is IArbitrable {\n    bytes4 public constant ERC165_INTERFACE = ERC165_INTERFACE_ID;\n    bytes4 public constant ARBITRABLE_INTERFACE = ARBITRABLE_INTERFACE_ID;\n\n    IArbitrator internal arbitrator;\n\n    constructor (IArbitrator _arbitrator) public {\n        arbitrator = _arbitrator;\n    }\n\n    function interfaceId() external pure returns (bytes4) {\n        IArbitrable iArbitrable;\n        return iArbitrable.submitEvidence.selector ^ iArbitrable.rule.selector;\n    }\n\n    function createDispute(uint8 _possibleRulings, bytes calldata _metadata) external {\n        (address recipient, ERC20 feeToken, uint256 disputeFees) = arbitrator.getDisputeFees();\n        feeToken.approve(recipient, disputeFees);\n        arbitrator.createDispute(_possibleRulings, _metadata);\n    }\n\n    function submitEvidence(uint256 _disputeId, bytes calldata _evidence, bool _finished) external {\n        emit EvidenceSubmitted(arbitrator, _disputeId, msg.sender, _evidence, _finished);\n        if (_finished) arbitrator.closeEvidencePeriod(_disputeId);\n    }\n\n    function rule(uint256 _disputeId, uint256 _ruling) external {\n        emit Ruled(IArbitrator(msg.sender), _disputeId, _ruling);\n    }\n\n    function interfaceID() external pure returns (bytes4) {\n        IArbitrable arbitrable;\n        return arbitrable.submitEvidence.selector ^ arbitrable.rule.selector;\n    }\n}\n"
    },
    "contracts/test/arbitration/FakeArbitrableMock.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"./ArbitrableMock.sol\";\n\n\ncontract FakeArbitrableMock is ArbitrableMock {\n    constructor (IArbitrator _court) ArbitrableMock(_court) public {}\n\n    function supportsInterface(bytes4 /* _interfaceId */) external pure returns (bool) {\n        return false;\n    }\n}\n"
    },
    "contracts/test/court/AragonCourtMock.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../court/AragonCourt.sol\";\nimport \"../lib/TimeHelpersMock.sol\";\n\n\ncontract AragonCourtMock is AragonCourt, TimeHelpersMock {\n    uint64 internal mockedTermId;\n    bytes32 internal mockedTermRandomness;\n\n    constructor(\n        uint64[2] memory _termParams,\n        address[3] memory _governors,\n        ERC20 _feeToken,\n        uint256[3] memory _fees,\n        uint64[5] memory _roundStateDurations,\n        uint16[2] memory _pcts,\n        uint64[4] memory _roundParams,\n        uint256[2] memory _appealCollateralParams,\n        uint256 _minActiveBalance\n    )\n        AragonCourt(\n            _termParams,\n            _governors,\n            _feeToken,\n            _fees,\n            _roundStateDurations,\n            _pcts,\n            _roundParams,\n            _appealCollateralParams,\n            _minActiveBalance\n        )\n        public\n    {}\n\n    function setDisputeManager(address _addr) external {\n        _setModule(DISPUTE_MANAGER, _addr);\n    }\n\n    function setDisputeManagerMock(address _addr) external {\n        // This function allows setting any address as the DisputeManager module\n        modules[DISPUTE_MANAGER] = _addr;\n        emit ModuleSet(DISPUTE_MANAGER, _addr);\n    }\n\n    function setTreasury(address _addr) external {\n        _setModule(TREASURY, _addr);\n    }\n\n    function setVoting(address _addr) external {\n        _setModule(VOTING, _addr);\n    }\n\n    function setJurorsRegistry(address _addr) external {\n        _setModule(JURORS_REGISTRY, _addr);\n    }\n\n    function setSubscriptions(address _addr) external {\n        _setModule(SUBSCRIPTIONS, _addr);\n    }\n\n    function mockIncreaseTerm() external {\n        if (mockedTermId != 0) mockedTermId = mockedTermId + 1;\n        else mockedTermId = _lastEnsuredTermId() + 1;\n    }\n\n    function mockIncreaseTerms(uint64 _terms) external {\n        if (mockedTermId != 0) mockedTermId = mockedTermId + _terms;\n        else mockedTermId = _lastEnsuredTermId() + _terms;\n    }\n\n    function mockSetTerm(uint64 _termId) external {\n        mockedTermId = _termId;\n    }\n\n    function mockSetTermRandomness(bytes32 _termRandomness) external {\n        mockedTermRandomness = _termRandomness;\n    }\n\n    function ensureCurrentTerm() external returns (uint64) {\n        if (mockedTermId != 0) return mockedTermId;\n        return super._ensureCurrentTerm();\n    }\n\n    function getCurrentTermId() external view returns (uint64) {\n        if (mockedTermId != 0) return mockedTermId;\n        return super._currentTermId();\n    }\n\n    function getLastEnsuredTermId() external view returns (uint64) {\n        if (mockedTermId != 0) return mockedTermId;\n        return super._lastEnsuredTermId();\n    }\n\n    function getTermRandomness(uint64 _termId) external view returns (bytes32) {\n        if (mockedTermRandomness != bytes32(0)) return mockedTermRandomness;\n        return super._computeTermRandomness(_termId);\n    }\n\n    function _computeTermRandomness(uint64 _termId) internal view returns (bytes32) {\n        if (mockedTermRandomness != bytes32(0)) return mockedTermRandomness;\n        return super._computeTermRandomness(_termId);\n    }\n}\n"
    },
    "contracts/test/lib/TimeHelpersMock.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../lib/os/SafeMath.sol\";\nimport \"../../lib/os/SafeMath64.sol\";\nimport \"../../lib/os/TimeHelpers.sol\";\n\n\ncontract TimeHelpersMock is TimeHelpers {\n    using SafeMath for uint256;\n    using SafeMath64 for uint64;\n\n    uint256 private mockedTimestamp;\n    uint256 private mockedSetBlockNumber;\n    uint256 private mockedAdvancedBlockNumber;\n\n    /**\n    * @dev Tells the mocked block number in uint256, or the real block number if it wasn't mocked\n    */\n    function getBlockNumberExt() external view returns (uint256) {\n        return getBlockNumber();\n    }\n\n    /**\n    * @dev Tells the mocked timestamp value in uint256, or the real timestamp if it wasn't mocked\n    */\n    function getTimestampExt() external view returns (uint256) {\n        return getTimestamp();\n    }\n\n    /**\n    * @dev Sets a mocked block number value, used only for testing purposes\n    */\n    function mockSetBlockNumber(uint256 _number) external {\n        mockedSetBlockNumber = _number;\n    }\n\n    /**\n    * @dev Advances the mocked block number value, used only for testing purposes\n    */\n    function mockAdvanceBlocks(uint256 _number) external {\n        if (mockedSetBlockNumber != 0) {\n            mockedAdvancedBlockNumber = mockedSetBlockNumber.add(_number);\n            mockedSetBlockNumber = 0;\n        }\n        else if (mockedAdvancedBlockNumber != 0) mockedAdvancedBlockNumber = mockedAdvancedBlockNumber.add(_number);\n        else mockedAdvancedBlockNumber = block.number.add(_number);\n    }\n\n    /**\n    * @dev Sets a mocked timestamp value, used only for testing purposes\n    */\n    function mockSetTimestamp(uint256 _timestamp) external {\n        mockedTimestamp = _timestamp;\n    }\n\n    /**\n    * @dev Increases the mocked timestamp value, used only for testing purposes\n    */\n    function mockIncreaseTime(uint256 _seconds) external {\n        if (mockedTimestamp != 0) mockedTimestamp = mockedTimestamp.add(_seconds);\n        else mockedTimestamp = block.timestamp.add(_seconds);\n    }\n\n    /**\n    * @dev Internal function to get the mocked block number if it was set, or current `block.number`\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        if (mockedSetBlockNumber != 0) return mockedSetBlockNumber;\n        uint256 realBlockNumber = super.getBlockNumber();\n        return (mockedAdvancedBlockNumber > realBlockNumber) ? mockedAdvancedBlockNumber : realBlockNumber;\n    }\n\n    /**\n    * @dev Internal function to get the mocked timestamp if it was set, or current `block.timestamp`\n    */\n    function getTimestamp() internal view returns (uint256) {\n        if (mockedTimestamp != 0) return mockedTimestamp;\n        return super.getTimestamp();\n    }\n}\n"
    },
    "contracts/test/court/controller/ControlledMock.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../../court/controller/Controlled.sol\";\n\n\ncontract ControlledMock is Controlled {\n    event OnlyConfigGovernorCalled();\n\n    constructor(Controller _controller) Controlled(_controller) public {}\n\n    function onlyConfigGovernorFn() external onlyConfigGovernor {\n        emit OnlyConfigGovernorCalled();\n    }\n}\n"
    },
    "contracts/test/court/controller/ControlledRecoverableMock.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../../court/controller/Controller.sol\";\nimport \"../../../court/controller/ControlledRecoverable.sol\";\n\n\ncontract ControlledRecoverableMock is ControlledRecoverable {\n    constructor(Controller _controller) ControlledRecoverable(_controller) public {}\n}\n"
    },
    "contracts/test/disputes/DisputeManagerMockForRegistry.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../court/controller/Controlled.sol\";\nimport \"../../court/controller/Controller.sol\";\n\n\ncontract DisputeManagerMockForRegistry is Controlled {\n    event Slashed(uint256 collected);\n    event Collected(bool collected);\n    event Drafted(address[] addresses, uint256 length);\n\n    constructor(Controller _controller) Controlled(_controller) public {}\n\n    function assignTokens(address _juror, uint256 _amount) external {\n        _jurorsRegistry().assignTokens(_juror, _amount);\n    }\n\n    function burnTokens(uint256 _amount) external {\n        _jurorsRegistry().burnTokens(_amount);\n    }\n\n    function slashOrUnlock(address[] calldata _jurors, uint256[] calldata _lockedAmounts, bool[] calldata _rewardedJurors) external {\n        uint256 collectedTokens = _jurorsRegistry().slashOrUnlock(_getLastEnsuredTermId(), _jurors, _lockedAmounts, _rewardedJurors);\n        emit Slashed(collectedTokens);\n    }\n\n    function collect(address _juror, uint256 _amount) external {\n        bool collected = _jurorsRegistry().collectTokens(_juror, _amount, _getLastEnsuredTermId());\n        emit Collected(collected);\n    }\n\n    function draft(\n        bytes32 _termRandomness,\n        uint256 _disputeId,\n        uint256 _selectedJurors,\n        uint256 _batchRequestedJurors,\n        uint64 _roundRequestedJurors,\n        uint16 _lockPct\n    )\n        external\n    {\n        uint256[7] memory draftParams = [\n            uint256(_termRandomness),\n            _disputeId,\n            _getLastEnsuredTermId(),\n            _selectedJurors,\n            _batchRequestedJurors,\n            _roundRequestedJurors,\n            _lockPct\n        ];\n\n        (address[] memory jurors, uint256 length) = _jurorsRegistry().draft(draftParams);\n        emit Drafted(jurors, length);\n    }\n}\n"
    },
    "contracts/test/disputes/DisputeManagerMockForVoting.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../voting/ICRVoting.sol\";\nimport \"../../voting/ICRVotingOwner.sol\";\nimport \"../../court/controller/Controller.sol\";\nimport \"../../court/controller/Controlled.sol\";\n\n\ncontract DisputeManagerMockForVoting is ICRVotingOwner, Controlled {\n    string private constant ERROR_VOTER_WEIGHT_ZERO = \"DM_VOTER_WEIGHT_ZERO\";\n    string private constant ERROR_OWNER_MOCK_COMMIT_CHECK_REVERTED = \"CRV_OWNER_MOCK_COMMIT_CHECK_REVERTED\";\n    string private constant ERROR_OWNER_MOCK_REVEAL_CHECK_REVERTED = \"CRV_OWNER_MOCK_REVEAL_CHECK_REVERTED\";\n\n    bool internal failing;\n    mapping (address => uint64) internal weights;\n\n    constructor(Controller _controller) Controlled(_controller) public {}\n\n    function mockChecksFailing(bool _failing) external {\n        failing = _failing;\n    }\n\n    function mockVoterWeight(address _voter, uint64 _weight) external {\n        weights[_voter] = _weight;\n    }\n\n    function create(uint256 _voteId, uint8 _ruling) external {\n        _voting().create(_voteId, _ruling);\n    }\n\n    function ensureCanCommit(uint256 /* _voteId */) external {\n        require(!failing, ERROR_OWNER_MOCK_COMMIT_CHECK_REVERTED);\n    }\n\n    function ensureCanCommit(uint256 /* _voteId */, address _voter) external {\n        require(!failing, ERROR_OWNER_MOCK_COMMIT_CHECK_REVERTED);\n        require(weights[_voter] > 0, ERROR_VOTER_WEIGHT_ZERO);\n    }\n\n    function ensureCanReveal(uint256 /* _voteId */, address _voter) external returns (uint64) {\n        require(!failing, ERROR_OWNER_MOCK_REVEAL_CHECK_REVERTED);\n        return weights[_voter];\n    }\n}\n"
    },
    "contracts/test/lib/CheckpointingMock.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../lib/Checkpointing.sol\";\n\n\ncontract CheckpointingMock {\n    using Checkpointing for Checkpointing.History;\n\n    Checkpointing.History internal history;\n\n    function add(uint64 _time, uint256 _value) public {\n        history.add(_time, _value);\n    }\n\n    function getLast() public view returns (uint256) {\n        return history.getLast();\n    }\n\n    function get(uint64 _time) public view returns (uint256) {\n        return history.get(_time);\n    }\n\n    function getRecent(uint64 _time) public view returns (uint256) {\n        return history.getRecent(_time);\n    }\n}\n"
    },
    "contracts/test/lib/HexSumTreeGasProfiler.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../lib/HexSumTree.sol\";\n\n\ncontract HexSumTreeGasProfiler {\n    using HexSumTree for HexSumTree.Tree;\n    using Checkpointing for Checkpointing.History;\n\n    uint256 private constant BITS_IN_NIBBLE = 4;\n\n    HexSumTree.Tree internal tree;\n\n    event GasConsumed(uint256 gas);\n\n    modifier profileGas {\n        uint256 initialGas = gasleft();\n        _;\n        emit GasConsumed(initialGas - gasleft());\n    }\n\n    function init() external {\n        tree.init();\n    }\n\n    function insert(uint64 _time, uint256 _value) external profileGas {\n        tree.insert(_time, _value);\n    }\n\n    function set(uint256 _key, uint64 _time, uint256 _value) external profileGas {\n        tree.set(_key, _time, _value);\n    }\n\n    function update(uint256 _key, uint64 _time, uint256 _delta, bool _positive) external profileGas {\n        tree.update(_key, _time, _delta, _positive);\n    }\n\n    function search(uint256[] calldata _values, uint64 _time) external profileGas {\n        tree.search(_values, _time);\n    }\n\n    function mockNextKey(uint64 _time, uint256 _nextKey) external {\n        // Compute new height\n        uint256 newHeight = 0;\n        for (uint256 key = _nextKey; key > 0; newHeight++) {\n            key = key >> BITS_IN_NIBBLE;\n        }\n\n        // Update fake values\n        tree.nextKey = _nextKey;\n        tree.height.add(_time, newHeight);\n    }\n\n    function nextKey() external view returns (uint256) {\n        return tree.nextKey;\n    }\n\n    function height() external view returns (uint256) {\n        return tree.getHeight();\n    }\n\n    function total() public view returns (uint256) {\n        return tree.getTotal();\n    }\n}\n"
    },
    "contracts/test/lib/HexSumTreeMock.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../lib/HexSumTree.sol\";\n\n\ncontract HexSumTreeMock {\n    using HexSumTree for HexSumTree.Tree;\n\n    HexSumTree.Tree internal tree;\n\n    function init() external {\n        tree.init();\n    }\n\n    function insert(uint64 _time, uint256 _value) external returns (uint256) {\n        return tree.insert(_time, _value);\n    }\n\n    function set(uint256 _key, uint64 _time, uint256 _value) external {\n        tree.set(_key, _time, _value);\n    }\n\n    function update(uint256 _key, uint64 _time, uint256 _delta, bool _positive) external {\n        tree.update(_key, _time, _delta, _positive);\n    }\n\n    function nextKey() external view returns (uint256) {\n        return tree.nextKey;\n    }\n\n    function total() external view returns (uint256) {\n        return tree.getTotal();\n    }\n\n    function totalAt(uint64 _time) external view returns (uint256) {\n        return tree.getTotalAt(_time);\n    }\n\n    function node(uint256 _level, uint256 _key) external view returns (uint256) {\n        return tree.getNode(_level, _key);\n    }\n\n    function nodeAt(uint256 _level, uint256 _key, uint64 _time) external view returns (uint256) {\n        return tree.getNodeAt(_level, _key, _time);\n    }\n\n    function item(uint256 _key) external view returns (uint256) {\n        return tree.getItem(_key);\n    }\n\n    function itemAt(uint256 _key, uint64 _time) external view returns (uint256) {\n        return tree.getItemAt(_key, _time);\n    }\n\n    function height() external view returns (uint256) {\n        return tree.getHeight();\n    }\n\n    function heightAt(uint64 _time) external view returns (uint256) {\n        return tree.getRecentHeightAt(_time);\n    }\n\n    function search(uint256[] calldata _values, uint64 _time) external view returns (uint256[] memory keys, uint256[] memory values) {\n        return tree.search(_values, _time);\n    }\n}\n"
    },
    "contracts/test/lib/JurorsTreeSortitionMock.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"./HexSumTreeMock.sol\";\nimport \"../../lib/JurorsTreeSortition.sol\";\n\n\ncontract JurorsTreeSortitionMock is HexSumTreeMock {\n    using JurorsTreeSortition for HexSumTree.Tree;\n\n    function batchedRandomSearch(\n        bytes32 _termRandomness,\n        uint256 _disputeId,\n        uint64 _termId,\n        uint256 _selectedJurors,\n        uint256 _batchRequestedJurors,\n        uint256 _roundRequestedJurors,\n        uint256 _sortitionIteration\n    )\n        public\n        view\n        returns (uint256[] memory jurorsIds, uint256[] memory activeBalances)\n    {\n        return tree.batchedRandomSearch(_termRandomness, _disputeId, _termId, _selectedJurors, _batchRequestedJurors, _roundRequestedJurors, _sortitionIteration);\n    }\n\n    function getSearchBatchBounds(uint64 _termId, uint256 _selectedJurors, uint256 _batchRequestedJurors, uint256 _roundRequestedJurors)\n        public\n        view\n        returns (uint256 low, uint256 high)\n    {\n        return tree.getSearchBatchBounds(_termId, _selectedJurors, _batchRequestedJurors, _roundRequestedJurors);\n    }\n\n    function computeSearchRandomBalances(\n        bytes32 _termRandomness,\n        uint256 _disputeId,\n        uint256 _sortitionIteration,\n        uint256 _batchRequestedJurors,\n        uint256 _lowActiveBalanceBatchBound,\n        uint256 _highActiveBalanceBatchBound\n    )\n        public\n        pure\n        returns (uint256[] memory)\n    {\n        return JurorsTreeSortition._computeSearchRandomBalances(_termRandomness, _disputeId, _sortitionIteration, _batchRequestedJurors, _lowActiveBalanceBatchBound, _highActiveBalanceBatchBound);\n    }\n}\n"
    },
    "contracts/test/registry/JurorsRegistryMock.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../registry/JurorsRegistry.sol\";\n\n\ncontract JurorsRegistryMock is JurorsRegistry {\n    string private constant ERROR_INVALID_MOCK_LOCK_AMOUNT = 'JR_INVALID_MOCK_LOCK_AMOUNT';\n\n    bool internal nextDraftMocked;\n    address[] internal mockedSelectedJurors;\n\n    constructor (Controller _controller, ERC20 _jurorToken, uint256 _totalActiveBalanceLimit)\n        public\n        JurorsRegistry(_controller, _jurorToken, _totalActiveBalanceLimit)\n    {}\n\n    function mockLock(address _juror, uint256 _leftUnlockedAmount) external {\n        Juror storage juror = jurorsByAddress[_juror];\n        uint256 active = _existsJuror(juror) ? tree.getItem(juror.id) : 0;\n        require(_leftUnlockedAmount < active, ERROR_INVALID_MOCK_LOCK_AMOUNT);\n        juror.lockedBalance = active - _leftUnlockedAmount;\n    }\n\n    function collect(address _juror, uint256 _amount) external {\n        Juror storage juror = jurorsByAddress[_juror];\n        uint64 nextTermId = _getLastEnsuredTermId() + 1;\n        tree.update(juror.id, nextTermId, _amount, false);\n    }\n\n    function mockNextDraft(address[] calldata _selectedJurors, uint256[] calldata _weights) external {\n        nextDraftMocked = true;\n\n        delete mockedSelectedJurors;\n        for (uint256 i = 0; i < _selectedJurors.length; i++) {\n            for (uint256 j = 0; j < _weights[i]; j++) {\n                mockedSelectedJurors.push(_selectedJurors[i]);\n            }\n        }\n    }\n\n    function _treeSearch(DraftParams memory _params) internal view returns (uint256[] memory, uint256[] memory) {\n        if (nextDraftMocked) {\n            return _runMockedSearch(_params);\n        }\n        return super._treeSearch(_params);\n    }\n\n    function _runMockedSearch(DraftParams memory _params) internal view returns (uint256[] memory ids, uint256[] memory activeBalances) {\n        uint256 length = mockedSelectedJurors.length;\n        ids = new uint256[](length);\n        activeBalances = new uint256[](length);\n\n        for (uint256 i = 0; i < mockedSelectedJurors.length; i++) {\n            address juror = mockedSelectedJurors[i];\n            uint256 id = jurorsByAddress[juror].id;\n            uint256 activeBalance = tree.getItemAt(id, _params.termId);\n\n            ids[i] = id;\n            activeBalances[i] = activeBalance;\n        }\n    }\n}\n"
    },
    "contracts/test/standards/ERC20Mock.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../lib/os/SafeMath.sol\";\n\nimport \"../../standards/ApproveAndCall.sol\";\n\n\ncontract ERC20Mock {\n    using SafeMath for uint256;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    bool private allowTransfer_;\n    mapping (address => uint256) private balances;\n    mapping (address => mapping (address => uint256)) private allowed;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) public {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        allowTransfer_ = true;\n    }\n\n    /**\n    * @dev Mint a certain amount of tokens for an address\n    * @param _to The address that will receive the tokens\n    * @param _amount The amount of tokens to be minted\n    */\n    function generateTokens(address _to, uint _amount) public {\n        totalSupply = totalSupply.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Transfer(address(0), _to, _amount);\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param _owner The address to query the the balance of.\n    * @return The amount owned by the passed address.\n    */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n    /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param _owner The address which owns the funds.\n    * @param _spender The address which will spend the funds.\n    * @return The amount of tokens still available for the spender.\n    */\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n    * @dev Set whether the token is transferable or not\n    * @param _allowTransfer Should token be transferable\n    */\n    function setAllowTransfer(bool _allowTransfer) public {\n        allowTransfer_ = _allowTransfer;\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _amount The amount to be transferred.\n    */\n    function transfer(address _to, uint256 _amount) public returns (bool) {\n        require(allowTransfer_, 'ERROR_TRANSFERS_NOT_ALLOWED');\n        require(_amount <= balances[msg.sender], 'ERROR_NOT_ENOUGH_BALANCE');\n        require(_to != address(0), 'ERROR_RECIPIENT_ZERO');\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds.\n    * @param _amount The amount of tokens to be spent.\n    */\n    function approve(address _spender, uint256 _amount) public returns (bool) {\n        // Assume we want to protect for the race condition\n        require(_amount == 0 || allowed[msg.sender][_spender] == 0, 'ERROR_ALLOWANCE_MUST_BE_ZERO');\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n    * @dev `msg.sender` approves `_spender` to send `_amount` tokens on its behalf, and then a function is\n    *       triggered in the contract that is being approved, `_spender`. This allows users to use their\n    *       tokens to interact with contracts in one function call instead of two\n    * @param _spender Address of the contract able to transfer the tokens\n    * @param _amount The amount of tokens to be approved for transfer\n    * @return True if the function call was successful\n    */\n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool) {\n        require(approve(address(_spender), _amount), 'ERROR_APPROVE_FAILED');\n        _spender.receiveApproval(msg.sender, _amount, address(this), _extraData);\n        return true;\n    }\n\n    /**\n    * @dev Transfer tokens from one address to another\n    * @param _from The address which you want to send tokens from\n    * @param _to The address which you want to transfer to\n    * @param _amount The amount of tokens to be transferred\n    */\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {\n        require(allowTransfer_, 'ERROR_TRANSFERS_NOT_ALLOWED');\n        require(_amount <= balances[_from], 'ERROR_NOT_ENOUGH_BALANCE');\n        require(_amount <= allowed[_from][msg.sender], 'ERROR_NOT_ENOUGH_ALLOWED_BALANCE');\n        require(_to != address(0), 'ERROR_RECIPIENT_ZERO');\n\n        balances[_from] = balances[_from].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n}\n"
    },
    "contracts/test/subscriptions/SubscriptionsMock.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../../subscriptions/ISubscriptions.sol\";\nimport \"../../subscriptions/CourtSubscriptions.sol\";\n\n\ncontract SubscriptionsMock is CourtSubscriptions {\n    bool internal upToDate;\n\n    constructor(Controller _controller, uint64 _periodDuration, ERC20 _feeToken, uint16 _governorSharePct)\n        CourtSubscriptions(_controller, _periodDuration, _feeToken, _governorSharePct)\n        public\n    {}\n\n    function mockUpToDate(bool _upToDate) external {\n        upToDate = _upToDate;\n    }\n\n    function isUpToDate(address) external view returns (bool) {\n        return upToDate;\n    }\n}\n"
    },
    "contracts/test/TestImports.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../lib/os/Migrations.sol\";\n\n\ncontract TestImports {\n    constructor() public {\n        // solium-disable-previous-line no-empty-blocks\n    }\n}\n"
    },
    "contracts/treasury/CourtTreasury.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../lib/os/ERC20.sol\";\nimport \"../lib/os/SafeMath.sol\";\nimport \"../lib/os/SafeERC20.sol\";\n\nimport \"./ITreasury.sol\";\nimport \"../court/controller/Controller.sol\";\nimport \"../court/controller/ControlledRecoverable.sol\";\n\n\ncontract CourtTreasury is ControlledRecoverable, ITreasury {\n    using SafeERC20 for ERC20;\n    using SafeMath for uint256;\n\n    string private constant ERROR_DEPOSIT_AMOUNT_ZERO = \"TREASURY_DEPOSIT_AMOUNT_ZERO\";\n    string private constant ERROR_WITHDRAW_FAILED = \"TREASURY_WITHDRAW_FAILED\";\n    string private constant ERROR_WITHDRAW_AMOUNT_ZERO = \"TREASURY_WITHDRAW_AMOUNT_ZERO\";\n    string private constant ERROR_WITHDRAW_INVALID_AMOUNT = \"TREASURY_WITHDRAW_INVALID_AMOUNT\";\n    string private constant ERROR_WITHDRAWS_DISALLOWED = \"TREASURY_WITHDRAWALS_DISALLOWED\";\n\n    // List of balances indexed by token and holder address\n    mapping (address => mapping (address => uint256)) internal balances;\n\n    event Assign(ERC20 indexed token, address indexed from, address indexed to, uint256 amount);\n    event Withdraw(ERC20 indexed token, address indexed from, address indexed to, uint256 amount);\n\n    /**\n    * @dev Constructor function\n    * @param _controller Address of the controller\n    */\n    constructor(Controller _controller) ControlledRecoverable(_controller) public {\n        // solium-disable-previous-line no-empty-blocks\n        // No need to explicitly call `Controlled` constructor since `ControlledRecoverable` is already doing it\n    }\n\n    /**\n    * @notice Assign `@tokenAmount(_token, _amount)` to `_to`\n    * @param _token ERC20 token to be assigned\n    * @param _to Address of the recipient that will be assigned the tokens to\n    * @param _amount Amount of tokens to be assigned to the recipient\n    */\n    function assign(ERC20 _token, address _to, uint256 _amount) external onlyDisputeManager {\n        require(_amount > 0, ERROR_DEPOSIT_AMOUNT_ZERO);\n\n        address tokenAddress = address(_token);\n        balances[tokenAddress][_to] = balances[tokenAddress][_to].add(_amount);\n        emit Assign(_token, msg.sender, _to, _amount);\n    }\n\n    /**\n    * @notice Withdraw `@tokenAmount(_token, _amount)` from sender to `_to`\n    * @param _token ERC20 token to be withdrawn\n    * @param _to Address of the recipient that will receive the tokens\n    * @param _amount Amount of tokens to be withdrawn from the sender\n    */\n    function withdraw(ERC20 _token, address _to, uint256 _amount) external {\n        _withdraw(_token, msg.sender, _to, _amount);\n    }\n\n    /**\n    * @notice Withdraw all the tokens from `_to` to themself\n    * @param _token ERC20 token to be withdrawn\n    * @param _to Address of the recipient that will receive their tokens\n    */\n    function withdrawAll(ERC20 _token, address _to) external {\n        IConfig config = _courtConfig();\n        require(config.areWithdrawalsAllowedFor(_to), ERROR_WITHDRAWS_DISALLOWED);\n\n        uint256 amount = _balanceOf(_token, _to);\n        _withdraw(_token, _to, _to, amount);\n    }\n\n    /**\n    * @dev Tell the token balance of a certain holder\n    * @param _token ERC20 token balance being queried\n    * @param _holder Address of the holder querying the balance of\n    * @return Amount of tokens the holder owns\n    */\n    function balanceOf(ERC20 _token, address _holder) external view returns (uint256) {\n        return _balanceOf(_token, _holder);\n    }\n\n    /**\n    * @dev Internal function to withdraw tokens from an account\n    * @param _token ERC20 token to be withdrawn\n    * @param _from Address where the tokens will be removed from\n    * @param _to Address of the recipient that will receive the corresponding tokens\n    * @param _amount Amount of tokens to be withdrawn from the sender\n    */\n    function _withdraw(ERC20 _token, address _from, address _to, uint256 _amount) internal {\n        require(_amount > 0, ERROR_WITHDRAW_AMOUNT_ZERO);\n        uint256 balance = _balanceOf(_token, _from);\n        require(balance >= _amount, ERROR_WITHDRAW_INVALID_AMOUNT);\n\n        address tokenAddress = address(_token);\n        // No need for SafeMath: checked above\n        balances[tokenAddress][_from] = balance - _amount;\n        emit Withdraw(_token, _from, _to, _amount);\n\n        require(_token.safeTransfer(_to, _amount), ERROR_WITHDRAW_FAILED);\n    }\n\n    /**\n    * @dev Internal function to tell the token balance of a certain holder\n    * @param _token ERC20 token balance being queried\n    * @param _holder Address of the holder querying the balance of\n    * @return Amount of tokens the holder owns\n    */\n    function _balanceOf(ERC20 _token, address _holder) internal view returns (uint256) {\n        return balances[address(_token)][_holder];\n    }\n}\n"
    },
    "contracts/voting/CRVoting.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"../lib/os/SafeMath.sol\";\n\nimport \"./ICRVoting.sol\";\nimport \"./ICRVotingOwner.sol\";\nimport \"../court/controller/Controlled.sol\";\nimport \"../court/controller/Controller.sol\";\n\n\ncontract CRVoting is Controlled, ICRVoting {\n    using SafeMath for uint256;\n\n    string private constant ERROR_VOTE_ALREADY_EXISTS = \"CRV_VOTE_ALREADY_EXISTS\";\n    string private constant ERROR_VOTE_DOES_NOT_EXIST = \"CRV_VOTE_DOES_NOT_EXIST\";\n    string private constant ERROR_VOTE_ALREADY_COMMITTED = \"CRV_VOTE_ALREADY_COMMITTED\";\n    string private constant ERROR_VOTE_ALREADY_REVEALED = \"CRV_VOTE_ALREADY_REVEALED\";\n    string private constant ERROR_INVALID_OUTCOME = \"CRV_INVALID_OUTCOME\";\n    string private constant ERROR_INVALID_OUTCOMES_AMOUNT = \"CRV_INVALID_OUTCOMES_AMOUNT\";\n    string private constant ERROR_INVALID_COMMITMENT_SALT = \"CRV_INVALID_COMMITMENT_SALT\";\n\n    // Outcome nr. 0 is used to denote a missing vote (default)\n    uint8 internal constant OUTCOME_MISSING = uint8(0);\n    // Outcome nr. 1 is used to denote a leaked vote\n    uint8 internal constant OUTCOME_LEAKED = uint8(1);\n    // Outcome nr. 2 is used to denote a refused vote\n    uint8 internal constant OUTCOME_REFUSED = uint8(2);\n    // Besides the options listed above, every vote instance must provide at least 2 outcomes\n    uint8 internal constant MIN_POSSIBLE_OUTCOMES = uint8(2);\n    // Max number of outcomes excluding the default ones\n    uint8 internal constant MAX_POSSIBLE_OUTCOMES = uint8(-1) - 3;\n\n    struct CastVote {\n        bytes32 commitment;                         // Hash of the outcome casted by the voter\n        uint8 outcome;                              // Outcome submitted by the voter\n    }\n\n    struct Vote {\n        uint8 winningOutcome;                       // Outcome winner of a vote instance\n        uint8 maxAllowedOutcome;                    // Highest outcome allowed for the vote instance\n        mapping (address => CastVote) votes;        // Mapping of voters addresses to their casted votes\n        mapping (uint8 => uint256) outcomesTally;   // Tally for each of the possible outcomes\n    }\n\n    // Vote records indexed by their ID\n    mapping (uint256 => Vote) internal voteRecords;\n\n    event VotingCreated(uint256 indexed voteId, uint8 possibleOutcomes);\n    event VoteCommitted(uint256 indexed voteId, address indexed voter, bytes32 commitment);\n    event VoteRevealed(uint256 indexed voteId, address indexed voter, uint8 outcome, address revealer);\n    event VoteLeaked(uint256 indexed voteId, address indexed voter, uint8 outcome, address leaker);\n\n    /**\n    * @dev Ensure a certain vote exists\n    * @param _voteId Identification number of the vote to be checked\n    */\n    modifier voteExists(uint256 _voteId) {\n        Vote storage vote = voteRecords[_voteId];\n        require(_existsVote(vote), ERROR_VOTE_DOES_NOT_EXIST);\n        _;\n    }\n\n    /**\n    * @dev Constructor function\n    * @param _controller Address of the controller\n    */\n    constructor(Controller _controller) Controlled(_controller) public {\n        // solium-disable-previous-line no-empty-blocks\n    }\n\n    /**\n    * @notice Create a new vote instance with ID #`_voteId` and `_possibleOutcomes` possible outcomes\n    * @dev This function can only be called by the CRVoting owner\n    * @param _voteId ID of the new vote instance to be created\n    * @param _possibleOutcomes Number of possible outcomes for the new vote instance to be created\n    */\n    function create(uint256 _voteId, uint8 _possibleOutcomes) external onlyDisputeManager {\n        require(_possibleOutcomes >= MIN_POSSIBLE_OUTCOMES && _possibleOutcomes <= MAX_POSSIBLE_OUTCOMES, ERROR_INVALID_OUTCOMES_AMOUNT);\n\n        Vote storage vote = voteRecords[_voteId];\n        require(!_existsVote(vote), ERROR_VOTE_ALREADY_EXISTS);\n\n        // No need for SafeMath: we already checked the number of outcomes above\n        vote.maxAllowedOutcome = OUTCOME_REFUSED + _possibleOutcomes;\n        emit VotingCreated(_voteId, _possibleOutcomes);\n    }\n\n    /**\n    * @notice Commit a vote for vote #`_voteId`\n    * @param _voteId ID of the vote instance to commit a vote to\n    * @param _commitment Hashed outcome to be stored for future reveal\n    */\n    function commit(uint256 _voteId, bytes32 _commitment) external voteExists(_voteId) {\n        CastVote storage castVote = voteRecords[_voteId].votes[msg.sender];\n        require(castVote.commitment == bytes32(0), ERROR_VOTE_ALREADY_COMMITTED);\n        _ensureVoterCanCommit(_voteId, msg.sender);\n\n        castVote.commitment = _commitment;\n        emit VoteCommitted(_voteId, msg.sender, _commitment);\n    }\n\n    /**\n    * @notice Leak `_outcome` vote of `_voter` for vote #`_voteId`\n    * @param _voteId ID of the vote instance to leak a vote of\n    * @param _voter Address of the voter to leak a vote of\n    * @param _outcome Outcome leaked for the voter\n    * @param _salt Salt to decrypt and validate the committed vote of the voter\n    */\n    function leak(uint256 _voteId, address _voter, uint8 _outcome, bytes32 _salt) external voteExists(_voteId) {\n        CastVote storage castVote = voteRecords[_voteId].votes[_voter];\n        _checkValidSalt(castVote, _outcome, _salt);\n        _ensureCanCommit(_voteId);\n\n        // There is no need to check if an outcome is valid if it was leaked.\n        // Additionally, leaked votes are not considered for the tally.\n        castVote.outcome = OUTCOME_LEAKED;\n        emit VoteLeaked(_voteId, _voter, _outcome, msg.sender);\n    }\n\n    /**\n    * @notice Reveal `_outcome` vote of `_voter` for vote #`_voteId`\n    * @param _voteId ID of the vote instance to reveal a vote of\n    * @param _voter Address of the voter to reveal a vote for\n    * @param _outcome Outcome revealed by the voter\n    * @param _salt Salt to decrypt and validate the committed vote of the voter\n    */\n    function reveal(uint256 _voteId, address _voter, uint8 _outcome, bytes32 _salt) external voteExists(_voteId) {\n        Vote storage vote = voteRecords[_voteId];\n        CastVote storage castVote = vote.votes[_voter];\n        _checkValidSalt(castVote, _outcome, _salt);\n        require(_isValidOutcome(vote, _outcome), ERROR_INVALID_OUTCOME);\n\n        uint256 weight = _ensureVoterCanReveal(_voteId, _voter);\n\n        castVote.outcome = _outcome;\n        _updateTally(vote, _outcome, weight);\n        emit VoteRevealed(_voteId, _voter, _outcome, msg.sender);\n    }\n\n    /**\n    * @dev Get the maximum allowed outcome for a given vote instance\n    * @param _voteId ID of the vote instance querying the max allowed outcome of\n    * @return Max allowed outcome for the given vote instance\n    */\n    function getMaxAllowedOutcome(uint256 _voteId) external view voteExists(_voteId) returns (uint8) {\n        Vote storage vote = voteRecords[_voteId];\n        return vote.maxAllowedOutcome;\n    }\n\n    /**\n    * @dev Get the winning outcome of a vote instance. If the winning outcome is missing, which means no one voted in\n    *      the given vote instance, it will be considered refused.\n    * @param _voteId ID of the vote instance querying the winning outcome of\n    * @return Winning outcome of the given vote instance or refused in case it's missing\n    */\n    function getWinningOutcome(uint256 _voteId) external view voteExists(_voteId) returns (uint8) {\n        Vote storage vote = voteRecords[_voteId];\n        uint8 winningOutcome = vote.winningOutcome;\n        return winningOutcome == OUTCOME_MISSING ? OUTCOME_REFUSED : winningOutcome;\n    }\n\n    /**\n    * @dev Get the tally of an outcome for a certain vote instance\n    * @param _voteId ID of the vote instance querying the tally of\n    * @param _outcome Outcome querying the tally of\n    * @return Tally of the outcome being queried for the given vote instance\n    */\n    function getOutcomeTally(uint256 _voteId, uint8 _outcome) external view voteExists(_voteId) returns (uint256) {\n        Vote storage vote = voteRecords[_voteId];\n        return vote.outcomesTally[_outcome];\n    }\n\n    /**\n    * @dev Tell whether an outcome is valid for a given vote instance or not. Missing and leaked outcomes are not considered\n    *      valid. The only valid outcomes are refused or any of the custom outcomes of the given vote instance.\n    * @param _voteId ID of the vote instance to check the outcome of\n    * @param _outcome Outcome to check if valid or not\n    * @return True if the given outcome is valid for the requested vote instance, false otherwise.\n    */\n    function isValidOutcome(uint256 _voteId, uint8 _outcome) external view voteExists(_voteId) returns (bool) {\n        Vote storage vote = voteRecords[_voteId];\n        return _isValidOutcome(vote, _outcome);\n    }\n\n    /**\n    * @dev Get the outcome voted by a voter for a certain vote instance\n    * @param _voteId ID of the vote instance querying the outcome of\n    * @param _voter Address of the voter querying the outcome of\n    * @return Outcome of the voter for the given vote instance\n    */\n    function getVoterOutcome(uint256 _voteId, address _voter) external view voteExists(_voteId) returns (uint8) {\n        Vote storage vote = voteRecords[_voteId];\n        return vote.votes[_voter].outcome;\n    }\n\n    /**\n    * @dev Tell whether a voter voted in favor of a certain outcome in a vote instance or not.\n    * @param _voteId ID of the vote instance to query if a voter voted in favor of a certain outcome\n    * @param _outcome Outcome to query if the given voter voted in favor of\n    * @param _voter Address of the voter to query if voted in favor of the given outcome\n    * @return True if the given voter voted in favor of the given outcome, false otherwise\n    */\n    function hasVotedInFavorOf(uint256 _voteId, uint8 _outcome, address _voter) external view voteExists(_voteId) returns (bool) {\n        Vote storage vote = voteRecords[_voteId];\n        return vote.votes[_voter].outcome == _outcome;\n    }\n\n    /**\n    * @dev Filter a list of voters based on whether they voted in favor of a certain outcome in a vote instance or not.\n    *      Note that if there was no winning outcome, it means that no one voted, then all voters will be considered\n    *      voting against any of the given outcomes.\n    * @param _voteId ID of the vote instance to be checked\n    * @param _outcome Outcome to filter the list of voters of\n    * @param _voters List of addresses of the voters to be filtered\n    * @return List of results to tell whether a voter voted in favor of the given outcome or not\n    */\n    function getVotersInFavorOf(uint256 _voteId, uint8 _outcome, address[] calldata _voters) external view voteExists(_voteId)\n        returns (bool[] memory)\n    {\n        Vote storage vote = voteRecords[_voteId];\n        bool[] memory votersInFavor = new bool[](_voters.length);\n\n        // If there was a winning outcome, filter those voters that voted in favor of the given outcome.\n        for (uint256 i = 0; i < _voters.length; i++) {\n            votersInFavor[i] = _outcome == vote.votes[_voters[i]].outcome;\n        }\n        return votersInFavor;\n    }\n\n    /**\n    * @dev Hash a vote outcome using a given salt\n    * @param _outcome Outcome to be hashed\n    * @param _salt Encryption salt\n    * @return Hashed outcome\n    */\n    function hashVote(uint8 _outcome, bytes32 _salt) external pure returns (bytes32) {\n        return _hashVote(_outcome, _salt);\n    }\n\n    /**\n    * @dev Internal function to ensure votes can be committed for a vote\n    * @param _voteId ID of the vote instance to be checked\n    */\n    function _ensureCanCommit(uint256 _voteId) internal {\n        ICRVotingOwner owner = _votingOwner();\n        owner.ensureCanCommit(_voteId);\n    }\n\n    /**\n    * @dev Internal function to ensure a voter can commit votes\n    * @param _voteId ID of the vote instance to be checked\n    * @param _voter Address of the voter willing to commit a vote\n    */\n    function _ensureVoterCanCommit(uint256 _voteId, address _voter) internal {\n        ICRVotingOwner owner = _votingOwner();\n        owner.ensureCanCommit(_voteId, _voter);\n    }\n\n    /**\n    * @dev Internal function to ensure a voter can reveal votes\n    * @param _voteId ID of the vote instance to be checked\n    * @param _voter Address of the voter willing to reveal a vote\n    * @return Weight of the voter willing to reveal a vote\n    */\n    function _ensureVoterCanReveal(uint256 _voteId, address _voter) internal returns (uint256) {\n        // There's no need to check voter weight, as this was done on commit\n        ICRVotingOwner owner = _votingOwner();\n        uint64 weight = owner.ensureCanReveal(_voteId, _voter);\n        return uint256(weight);\n    }\n\n    /**\n    * @dev Internal function to check if a vote can be revealed for the given outcome and salt\n    * @param _castVote Cast vote to be revealed\n    * @param _outcome Outcome of the cast vote to be proved\n    * @param _salt Salt to decrypt and validate the provided outcome for a cast vote\n    */\n    function _checkValidSalt(CastVote storage _castVote, uint8 _outcome, bytes32 _salt) internal view {\n        require(_castVote.outcome == OUTCOME_MISSING, ERROR_VOTE_ALREADY_REVEALED);\n        require(_castVote.commitment == _hashVote(_outcome, _salt), ERROR_INVALID_COMMITMENT_SALT);\n    }\n\n    /**\n    * @dev Internal function to tell whether a certain outcome is valid for a given vote instance or not. Note that\n    *      the missing and leaked outcomes are not considered valid. The only outcomes considered valid are refused\n    *      or any of the possible outcomes of the given vote instance. This function assumes the given vote exists.\n    * @param _vote Vote instance to check the outcome of\n    * @param _outcome Outcome to check if valid or not\n    * @return True if the given outcome is valid for the requested vote instance, false otherwise.\n    */\n    function _isValidOutcome(Vote storage _vote, uint8 _outcome) internal view returns (bool) {\n        return _outcome >= OUTCOME_REFUSED && _outcome <= _vote.maxAllowedOutcome;\n    }\n\n    /**\n    * @dev Internal function to check if a vote instance was already created\n    * @param _vote Vote instance to be checked\n    * @return True if the given vote instance was already created, false otherwise\n    */\n    function _existsVote(Vote storage _vote) internal view returns (bool) {\n        return _vote.maxAllowedOutcome != OUTCOME_MISSING;\n    }\n\n    /**\n    * @dev Internal function to hash a vote outcome using a given salt\n    * @param _outcome Outcome to be hashed\n    * @param _salt Encryption salt\n    * @return Hashed outcome\n    */\n    function _hashVote(uint8 _outcome, bytes32 _salt) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_outcome, _salt));\n    }\n\n    /**\n    * @dev Private function to update the tally of a given vote instance based on a new weight in favor of an outcome.\n    *      This function assumes the vote instance exists.\n    * @param _vote Vote instance to update the tally of\n    * @param _outcome Outcome of the vote instance to update the tally of\n    * @param _weight Weight to be added to the given outcome of the vote instance\n    */\n    function _updateTally(Vote storage _vote, uint8 _outcome, uint256 _weight) private {\n        // Check if the given outcome is valid. Missing and leaked votes are ignored for the tally.\n        if (!_isValidOutcome(_vote, _outcome)) {\n            return;\n        }\n\n        uint256 newOutcomeTally = _vote.outcomesTally[_outcome].add(_weight);\n        _vote.outcomesTally[_outcome] = newOutcomeTally;\n\n        // Update the winning outcome only if its support was passed or if the given outcome represents a lowest\n        // option than the winning outcome in case of a tie.\n        uint8 winningOutcome = _vote.winningOutcome;\n        uint256 winningOutcomeTally = _vote.outcomesTally[winningOutcome];\n        if (newOutcomeTally > winningOutcomeTally || (newOutcomeTally == winningOutcomeTally && _outcome < winningOutcome)) {\n            _vote.winningOutcome = _outcome;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 3000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}